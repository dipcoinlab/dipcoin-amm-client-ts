{"version":3,"file":"index.mjs","sources":["../node_modules/@mysten/sui/dist/esm/version.js","../node_modules/@mysten/sui/dist/esm/client/errors.js","../node_modules/@mysten/sui/dist/esm/client/rpc-websocket-client.js","../node_modules/@mysten/sui/dist/esm/client/http-transport.js","../node_modules/@mysten/sui/dist/esm/client/network.js","../node_modules/@scure/base/lib/esm/index.js","../node_modules/@mysten/bcs/dist/esm/b58.js","../node_modules/@mysten/bcs/dist/esm/b64.js","../node_modules/@mysten/bcs/dist/esm/hex.js","../node_modules/@mysten/bcs/dist/esm/uleb.js","../node_modules/@mysten/bcs/dist/esm/reader.js","../node_modules/@mysten/bcs/dist/esm/utils.js","../node_modules/@mysten/bcs/dist/esm/writer.js","../node_modules/@mysten/bcs/dist/esm/bcs-type.js","../node_modules/@mysten/bcs/dist/esm/bcs.js","../node_modules/@mysten/sui/dist/esm/experimental/client.js","../node_modules/@mysten/sui/dist/esm/utils/suins.js","../node_modules/@mysten/sui/dist/esm/utils/move-registry.js","../node_modules/@mysten/sui/dist/esm/utils/sui-types.js","../node_modules/@mysten/sui/dist/esm/bcs/type-tag-serializer.js","../node_modules/@mysten/sui/dist/esm/bcs/bcs.js","../node_modules/@mysten/sui/dist/esm/bcs/effects.js","../node_modules/@mysten/sui/dist/esm/bcs/pure.js","../node_modules/@mysten/sui/dist/esm/bcs/index.js","../node_modules/valibot/dist/index.js","../node_modules/@mysten/sui/dist/esm/transactions/data/internal.js","../node_modules/@mysten/sui/dist/esm/transactions/Commands.js","../node_modules/@mysten/sui/dist/esm/transactions/data/v1.js","../node_modules/@mysten/sui/dist/esm/transactions/data/v2.js","../node_modules/@mysten/sui/dist/esm/transactions/Inputs.js","../node_modules/@mysten/sui/dist/esm/utils/constants.js","../node_modules/@noble/hashes/esm/_assert.js","../node_modules/@noble/hashes/esm/utils.js","../node_modules/@noble/hashes/esm/_blake.js","../node_modules/@noble/hashes/esm/_u64.js","../node_modules/@noble/hashes/esm/blake2b.js","../node_modules/@mysten/sui/dist/esm/transactions/serializer.js","../node_modules/@mysten/sui/dist/esm/transactions/json-rpc-resolver.js","../node_modules/@mysten/sui/dist/esm/transactions/pure.js","../node_modules/@mysten/sui/dist/esm/transactions/TransactionData.js","../node_modules/@mysten/sui/dist/esm/transactions/hash.js","../node_modules/@mysten/sui/dist/esm/transactions/utils.js","../node_modules/@mysten/sui/dist/esm/transactions/Transaction.js","../node_modules/@mysten/sui/dist/esm/transactions/object.js","../node_modules/@mysten/sui/dist/esm/experimental/core.js","../node_modules/@mysten/sui/dist/esm/experimental/errors.js","../node_modules/@mysten/sui/dist/esm/experimental/transports/jsonRPC.js","../node_modules/@mysten/sui/dist/esm/transactions/plugins/utils.js","../node_modules/@mysten/sui/dist/esm/transactions/intents/CoinWithBalance.js","../node_modules/@mysten/sui/dist/esm/client/client.js","../node_modules/bignumber.js/bignumber.mjs","../node_modules/bs58/index.js","../node_modules/base-x/src/index.js","../node_modules/fast-sha256/sha256.js","../node_modules/@benfen/bcs/dist/index.mjs","../node_modules/ieee754/index.js","../node_modules/buffer/index.js","../node_modules/base64-js/index.js","../src/utils/utils.ts","../src/utils/swap_math.ts","../src/constants/constants.ts","../src/sdk/sdk.ts","../src/config/mainnet.ts","../src/config/testnet.ts","../src/config/config.ts"],"sourcesContent":["const PACKAGE_VERSION = \"1.26.0\";\nconst TARGETED_RPC_VERSION = \"1.47.0\";\nexport {\n  PACKAGE_VERSION,\n  TARGETED_RPC_VERSION\n};\n//# sourceMappingURL=version.js.map\n","const CODE_TO_ERROR_TYPE = {\n  \"-32700\": \"ParseError\",\n  \"-32701\": \"OversizedRequest\",\n  \"-32702\": \"OversizedResponse\",\n  \"-32600\": \"InvalidRequest\",\n  \"-32601\": \"MethodNotFound\",\n  \"-32602\": \"InvalidParams\",\n  \"-32603\": \"InternalError\",\n  \"-32604\": \"ServerBusy\",\n  \"-32000\": \"CallExecutionFailed\",\n  \"-32001\": \"UnknownError\",\n  \"-32003\": \"SubscriptionClosed\",\n  \"-32004\": \"SubscriptionClosedWithError\",\n  \"-32005\": \"BatchesNotSupported\",\n  \"-32006\": \"TooManySubscriptions\",\n  \"-32050\": \"TransientError\",\n  \"-32002\": \"TransactionExecutionClientError\"\n};\nclass SuiHTTPTransportError extends Error {\n}\nclass JsonRpcError extends SuiHTTPTransportError {\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n    this.type = CODE_TO_ERROR_TYPE[code] ?? \"ServerError\";\n  }\n}\nclass SuiHTTPStatusError extends SuiHTTPTransportError {\n  constructor(message, status, statusText) {\n    super(message);\n    this.status = status;\n    this.statusText = statusText;\n  }\n}\nexport {\n  JsonRpcError,\n  SuiHTTPStatusError,\n  SuiHTTPTransportError\n};\n//# sourceMappingURL=errors.js.map\n","var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar __privateWrapper = (obj, member, setter, getter) => ({\n  set _(value) {\n    __privateSet(obj, member, value, setter);\n  },\n  get _() {\n    return __privateGet(obj, member, getter);\n  }\n});\nvar _requestId, _disconnects, _webSocket, _connectionPromise, _subscriptions, _pendingRequests, _WebsocketClient_instances, setupWebSocket_fn, reconnect_fn;\nimport { JsonRpcError } from \"./errors.js\";\nfunction getWebsocketUrl(httpUrl) {\n  const url = new URL(httpUrl);\n  url.protocol = url.protocol.replace(\"http\", \"ws\");\n  return url.toString();\n}\nconst DEFAULT_CLIENT_OPTIONS = {\n  // We fudge the typing because we also check for undefined in the constructor:\n  WebSocketConstructor: typeof WebSocket !== \"undefined\" ? WebSocket : void 0,\n  callTimeout: 3e4,\n  reconnectTimeout: 3e3,\n  maxReconnects: 5\n};\nclass WebsocketClient {\n  constructor(endpoint, options = {}) {\n    __privateAdd(this, _WebsocketClient_instances);\n    __privateAdd(this, _requestId, 0);\n    __privateAdd(this, _disconnects, 0);\n    __privateAdd(this, _webSocket, null);\n    __privateAdd(this, _connectionPromise, null);\n    __privateAdd(this, _subscriptions, /* @__PURE__ */ new Set());\n    __privateAdd(this, _pendingRequests, /* @__PURE__ */ new Map());\n    this.endpoint = endpoint;\n    this.options = { ...DEFAULT_CLIENT_OPTIONS, ...options };\n    if (!this.options.WebSocketConstructor) {\n      throw new Error(\"Missing WebSocket constructor\");\n    }\n    if (this.endpoint.startsWith(\"http\")) {\n      this.endpoint = getWebsocketUrl(this.endpoint);\n    }\n  }\n  async makeRequest(method, params) {\n    const webSocket = await __privateMethod(this, _WebsocketClient_instances, setupWebSocket_fn).call(this);\n    return new Promise((resolve, reject) => {\n      __privateSet(this, _requestId, __privateGet(this, _requestId) + 1);\n      __privateGet(this, _pendingRequests).set(__privateGet(this, _requestId), {\n        resolve,\n        reject,\n        timeout: setTimeout(() => {\n          __privateGet(this, _pendingRequests).delete(__privateGet(this, _requestId));\n          reject(new Error(`Request timeout: ${method}`));\n        }, this.options.callTimeout)\n      });\n      webSocket.send(JSON.stringify({ jsonrpc: \"2.0\", id: __privateGet(this, _requestId), method, params }));\n    }).then(({ error, result }) => {\n      if (error) {\n        throw new JsonRpcError(error.message, error.code);\n      }\n      return result;\n    });\n  }\n  async subscribe(input) {\n    const subscription = new RpcSubscription(input);\n    __privateGet(this, _subscriptions).add(subscription);\n    await subscription.subscribe(this);\n    return () => subscription.unsubscribe(this);\n  }\n}\n_requestId = new WeakMap();\n_disconnects = new WeakMap();\n_webSocket = new WeakMap();\n_connectionPromise = new WeakMap();\n_subscriptions = new WeakMap();\n_pendingRequests = new WeakMap();\n_WebsocketClient_instances = new WeakSet();\nsetupWebSocket_fn = function() {\n  if (__privateGet(this, _connectionPromise)) {\n    return __privateGet(this, _connectionPromise);\n  }\n  __privateSet(this, _connectionPromise, new Promise((resolve) => {\n    __privateGet(this, _webSocket)?.close();\n    __privateSet(this, _webSocket, new this.options.WebSocketConstructor(this.endpoint));\n    __privateGet(this, _webSocket).addEventListener(\"open\", () => {\n      __privateSet(this, _disconnects, 0);\n      resolve(__privateGet(this, _webSocket));\n    });\n    __privateGet(this, _webSocket).addEventListener(\"close\", () => {\n      __privateWrapper(this, _disconnects)._++;\n      if (__privateGet(this, _disconnects) <= this.options.maxReconnects) {\n        setTimeout(() => {\n          __privateMethod(this, _WebsocketClient_instances, reconnect_fn).call(this);\n        }, this.options.reconnectTimeout);\n      }\n    });\n    __privateGet(this, _webSocket).addEventListener(\"message\", ({ data }) => {\n      let json;\n      try {\n        json = JSON.parse(data);\n      } catch (error) {\n        console.error(new Error(`Failed to parse RPC message: ${data}`, { cause: error }));\n        return;\n      }\n      if (\"id\" in json && json.id != null && __privateGet(this, _pendingRequests).has(json.id)) {\n        const { resolve: resolve2, timeout } = __privateGet(this, _pendingRequests).get(json.id);\n        clearTimeout(timeout);\n        resolve2(json);\n      } else if (\"params\" in json) {\n        const { params } = json;\n        __privateGet(this, _subscriptions).forEach((subscription) => {\n          if (subscription.subscriptionId === params.subscription) {\n            if (params.subscription === subscription.subscriptionId) {\n              subscription.onMessage(params.result);\n            }\n          }\n        });\n      }\n    });\n  }));\n  return __privateGet(this, _connectionPromise);\n};\nreconnect_fn = async function() {\n  __privateGet(this, _webSocket)?.close();\n  __privateSet(this, _connectionPromise, null);\n  return Promise.allSettled(\n    [...__privateGet(this, _subscriptions)].map((subscription) => subscription.subscribe(this))\n  );\n};\nclass RpcSubscription {\n  constructor(input) {\n    this.subscriptionId = null;\n    this.subscribed = false;\n    this.input = input;\n  }\n  onMessage(message) {\n    if (this.subscribed) {\n      this.input.onMessage(message);\n    }\n  }\n  async unsubscribe(client) {\n    const { subscriptionId } = this;\n    this.subscribed = false;\n    if (subscriptionId == null) return false;\n    this.subscriptionId = null;\n    return client.makeRequest(this.input.unsubscribe, [subscriptionId]);\n  }\n  async subscribe(client) {\n    this.subscriptionId = null;\n    this.subscribed = true;\n    const newSubscriptionId = await client.makeRequest(\n      this.input.method,\n      this.input.params\n    );\n    if (this.subscribed) {\n      this.subscriptionId = newSubscriptionId;\n    }\n  }\n}\nexport {\n  DEFAULT_CLIENT_OPTIONS,\n  WebsocketClient\n};\n//# sourceMappingURL=rpc-websocket-client.js.map\n","var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _requestId, _options, _websocketClient, _SuiHTTPTransport_instances, getWebsocketClient_fn;\nimport { PACKAGE_VERSION, TARGETED_RPC_VERSION } from \"../version.js\";\nimport { JsonRpcError, SuiHTTPStatusError } from \"./errors.js\";\nimport { WebsocketClient } from \"./rpc-websocket-client.js\";\nclass SuiHTTPTransport {\n  constructor(options) {\n    __privateAdd(this, _SuiHTTPTransport_instances);\n    __privateAdd(this, _requestId, 0);\n    __privateAdd(this, _options);\n    __privateAdd(this, _websocketClient);\n    __privateSet(this, _options, options);\n  }\n  fetch(input, init) {\n    const fetchFn = __privateGet(this, _options).fetch ?? fetch;\n    if (!fetchFn) {\n      throw new Error(\n        \"The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport.\"\n      );\n    }\n    return fetchFn(input, init);\n  }\n  async request(input) {\n    __privateSet(this, _requestId, __privateGet(this, _requestId) + 1);\n    const res = await this.fetch(__privateGet(this, _options).rpc?.url ?? __privateGet(this, _options).url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Client-Sdk-Type\": \"typescript\",\n        \"Client-Sdk-Version\": PACKAGE_VERSION,\n        \"Client-Target-Api-Version\": TARGETED_RPC_VERSION,\n        \"Client-Request-Method\": input.method,\n        ...__privateGet(this, _options).rpc?.headers\n      },\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: __privateGet(this, _requestId),\n        method: input.method,\n        params: input.params\n      })\n    });\n    if (!res.ok) {\n      throw new SuiHTTPStatusError(\n        `Unexpected status code: ${res.status}`,\n        res.status,\n        res.statusText\n      );\n    }\n    const data = await res.json();\n    if (\"error\" in data && data.error != null) {\n      throw new JsonRpcError(data.error.message, data.error.code);\n    }\n    return data.result;\n  }\n  async subscribe(input) {\n    const unsubscribe = await __privateMethod(this, _SuiHTTPTransport_instances, getWebsocketClient_fn).call(this).subscribe(input);\n    return async () => !!await unsubscribe();\n  }\n}\n_requestId = new WeakMap();\n_options = new WeakMap();\n_websocketClient = new WeakMap();\n_SuiHTTPTransport_instances = new WeakSet();\ngetWebsocketClient_fn = function() {\n  if (!__privateGet(this, _websocketClient)) {\n    const WebSocketConstructor = __privateGet(this, _options).WebSocketConstructor ?? WebSocket;\n    if (!WebSocketConstructor) {\n      throw new Error(\n        \"The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport.\"\n      );\n    }\n    __privateSet(this, _websocketClient, new WebsocketClient(\n      __privateGet(this, _options).websocket?.url ?? __privateGet(this, _options).url,\n      {\n        WebSocketConstructor,\n        ...__privateGet(this, _options).websocket\n      }\n    ));\n  }\n  return __privateGet(this, _websocketClient);\n};\nexport {\n  SuiHTTPTransport\n};\n//# sourceMappingURL=http-transport.js.map\n","function getFullnodeUrl(network) {\n  switch (network) {\n    case \"mainnet\":\n      return \"https://fullnode.mainnet.sui.io:443\";\n    case \"testnet\":\n      return \"https://fullnode.testnet.sui.io:443\";\n    case \"devnet\":\n      return \"https://fullnode.devnet.sui.io:443\";\n    case \"localnet\":\n      return \"http://127.0.0.1:9000\";\n    default:\n      throw new Error(`Unknown network: ${network}`);\n  }\n}\nexport {\n  getFullnodeUrl\n};\n//# sourceMappingURL=network.js.map\n","/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction isArrayOf(isString, arr) {\n    if (!Array.isArray(arr))\n        return false;\n    if (arr.length === 0)\n        return true;\n    if (isString) {\n        return arr.every((item) => typeof item === 'string');\n    }\n    else {\n        return arr.every((item) => Number.isSafeInteger(item));\n    }\n}\n// no abytes: seems to have 10% slowdown. Why?!\nfunction afn(input) {\n    if (typeof input !== 'function')\n        throw new Error('function expected');\n    return true;\n}\nfunction astr(label, input) {\n    if (typeof input !== 'string')\n        throw new Error(`${label}: string expected`);\n    return true;\n}\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`invalid integer: ${n}`);\n}\nexport const assertNumber = anumber;\nfunction aArr(input) {\n    if (!Array.isArray(input))\n        throw new Error('array expected');\n}\nfunction astrArr(label, input) {\n    if (!isArrayOf(true, input))\n        throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label, input) {\n    if (!isArrayOf(false, input))\n        throw new Error(`${label}: array of numbers expected`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters) {\n    // mapping 1 to \"b\"\n    const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n    const len = lettersA.length;\n    astrArr('alphabet', lettersA);\n    // mapping \"b\" to 1\n    const indexes = new Map(lettersA.map((l, i) => [l, i]));\n    return {\n        encode: (digits) => {\n            aArr(digits);\n            return digits.map((i) => {\n                if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n                    throw new Error(`alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`);\n                return lettersA[i];\n            });\n        },\n        decode: (input) => {\n            aArr(input);\n            return input.map((letter) => {\n                astr('alphabet.decode', letter);\n                const i = indexes.get(letter);\n                if (i === undefined)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n                return i;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    astr('join', separator);\n    return {\n        encode: (from) => {\n            astrArr('join.decode', from);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            astr('join.decode', to);\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    anumber(bits);\n    astr('padding', chr);\n    return {\n        encode(data) {\n            astrArr('padding.encode', data);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            astrArr('padding.decode', input);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('padding: invalid, string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                const last = end - 1;\n                const byte = last * bits;\n                if (byte % 8 === 0)\n                    throw new Error('padding: invalid, string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    afn(fn);\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n    aArr(data);\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data, (d) => {\n        anumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`invalid integer: ${d}`);\n        return d;\n    });\n    const dlen = digits.length;\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < dlen; i++) {\n            const digit = digits[i];\n            const fromCarry = from * carry;\n            const digitBase = fromCarry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                fromCarry / from !== carry ||\n                digitBase - digit !== fromCarry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            const div = digitBase / to;\n            carry = digitBase % to;\n            const rounded = Math.floor(div);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\nconst powers = /* @__PURE__ */ (() => {\n    let res = [];\n    for (let i = 0; i < 40; i++)\n        res.push(2 ** i);\n    return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data, from, to, padding) {\n    aArr(data);\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const max = powers[from];\n    const mask = powers[to] - 1;\n    const res = [];\n    for (const n of data) {\n        anumber(n);\n        if (n >= max)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        const pow = powers[pos];\n        if (pow === undefined)\n            throw new Error('invalid carry');\n        carry &= pow - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry > 0)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    anumber(num);\n    const _256 = 2 ** 8;\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), _256, num);\n        },\n        decode: (digits) => {\n            anumArr('radix.decode', digits);\n            return Uint8Array.from(convertRadix(digits, num, _256));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    anumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            anumArr('radix2.decode', digits);\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    afn(fn);\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    anumber(len);\n    afn(fn);\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const sum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(sum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const oldChecksum = data.slice(-len);\n            const newChecksum = fn(payload).slice(0, len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nexport const utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\n/**\n * base16 encoding.\n */\nexport const base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexport const base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexport const base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));\nexport const base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexport const base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));\nexport const base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\n/**\n * base64 with padding. For no padding, use `base64nopad`.\n * @example\n * const b = base64.decode('A951'); // Uint8Array.from([ 3, 222, 117 ])\n * base64.encode(b); // 'A951'\n */\nexport const base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\n/**\n * base64 without padding.\n */\nexport const base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\nexport const base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nexport const base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => chain(radix(58), alphabet(abc), join(''));\n/**\n * Base58: base64 without characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n */\nexport const base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexport const base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexport const base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n/**\n * XMR version of base58.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nexport const createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check = createBase58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        astr('bech32.encode prefix', prefix);\n        if (isBytes(words))\n            words = Array.from(words);\n        anumArr('bech32.encode', words);\n        const plen = prefix.length;\n        if (plen === 0)\n            throw new TypeError(`Invalid prefix length ${plen}`);\n        const actualLength = plen + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        astr('bech32.decode input', str);\n        const slen = str.length;\n        if (slen < 8 || (limit !== false && slen > limit))\n            throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords,\n    };\n}\n/**\n * Low-level bech32 operations. Operates on words.\n */\nexport const bech32 = genBech32('bech32');\nexport const bech32m = genBech32('bech32m');\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n */\nexport const utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\n/**\n * hex string decoder.\n * @example\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n */\nexport const hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2 !== 0)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nexport const bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexport const str = bytesToString; // as in python, but for bytes only\nexport const stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexport const bytes = stringToBytes;\n//# sourceMappingURL=index.js.map","import { base58 } from \"@scure/base\";\nconst toBase58 = (buffer) => base58.encode(buffer);\nconst fromBase58 = (str) => base58.decode(str);\nconst toB58 = toBase58;\nconst fromB58 = fromBase58;\nexport {\n  fromB58,\n  fromBase58,\n  toB58,\n  toBase58\n};\n//# sourceMappingURL=b58.js.map\n","function fromBase64(base64String) {\n  return Uint8Array.from(atob(base64String), (char) => char.charCodeAt(0));\n}\nconst CHUNK_SIZE = 8192;\nfunction toBase64(bytes) {\n  if (bytes.length < CHUNK_SIZE) {\n    return btoa(String.fromCharCode(...bytes));\n  }\n  let output = \"\";\n  for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {\n    const chunk = bytes.slice(i, i + CHUNK_SIZE);\n    output += String.fromCharCode(...chunk);\n  }\n  return btoa(output);\n}\nconst toB64 = toBase64;\nconst fromB64 = fromBase64;\nexport {\n  fromB64,\n  fromBase64,\n  toB64,\n  toBase64\n};\n//# sourceMappingURL=b64.js.map\n","function fromHex(hexStr) {\n  const normalized = hexStr.startsWith(\"0x\") ? hexStr.slice(2) : hexStr;\n  const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}`;\n  const intArr = padded.match(/[0-9a-fA-F]{2}/g)?.map((byte) => parseInt(byte, 16)) ?? [];\n  if (intArr.length !== padded.length / 2) {\n    throw new Error(`Invalid hex string ${hexStr}`);\n  }\n  return Uint8Array.from(intArr);\n}\nfunction toHex(bytes) {\n  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nconst toHEX = toHex;\nconst fromHEX = fromHex;\nexport {\n  fromHEX,\n  fromHex,\n  toHEX,\n  toHex\n};\n//# sourceMappingURL=hex.js.map\n","function ulebEncode(num) {\n  let arr = [];\n  let len = 0;\n  if (num === 0) {\n    return [0];\n  }\n  while (num > 0) {\n    arr[len] = num & 127;\n    if (num >>= 7) {\n      arr[len] |= 128;\n    }\n    len += 1;\n  }\n  return arr;\n}\nfunction ulebDecode(arr) {\n  let total = 0;\n  let shift = 0;\n  let len = 0;\n  while (true) {\n    let byte = arr[len];\n    len += 1;\n    total |= (byte & 127) << shift;\n    if ((byte & 128) === 0) {\n      break;\n    }\n    shift += 7;\n  }\n  return {\n    value: total,\n    length: len\n  };\n}\nexport {\n  ulebDecode,\n  ulebEncode\n};\n//# sourceMappingURL=uleb.js.map\n","import { ulebDecode } from \"./uleb.js\";\nclass BcsReader {\n  /**\n   * @param {Uint8Array} data Data to use as a buffer.\n   */\n  constructor(data) {\n    this.bytePosition = 0;\n    this.dataView = new DataView(data.buffer);\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Read U8 value from the buffer and shift cursor by 1.\n   * @returns\n   */\n  read8() {\n    let value = this.dataView.getUint8(this.bytePosition);\n    this.shift(1);\n    return value;\n  }\n  /**\n   * Read U16 value from the buffer and shift cursor by 2.\n   * @returns\n   */\n  read16() {\n    let value = this.dataView.getUint16(this.bytePosition, true);\n    this.shift(2);\n    return value;\n  }\n  /**\n   * Read U32 value from the buffer and shift cursor by 4.\n   * @returns\n   */\n  read32() {\n    let value = this.dataView.getUint32(this.bytePosition, true);\n    this.shift(4);\n    return value;\n  }\n  /**\n   * Read U64 value from the buffer and shift cursor by 8.\n   * @returns\n   */\n  read64() {\n    let value1 = this.read32();\n    let value2 = this.read32();\n    let result = value2.toString(16) + value1.toString(16).padStart(8, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 16.\n   */\n  read128() {\n    let value1 = BigInt(this.read64());\n    let value2 = BigInt(this.read64());\n    let result = value2.toString(16) + value1.toString(16).padStart(16, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 32.\n   * @returns\n   */\n  read256() {\n    let value1 = BigInt(this.read128());\n    let value2 = BigInt(this.read128());\n    let result = value2.toString(16) + value1.toString(16).padStart(32, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read `num` number of bytes from the buffer and shift cursor by `num`.\n   * @param num Number of bytes to read.\n   */\n  readBytes(num) {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let value = new Uint8Array(this.dataView.buffer, start, num);\n    this.shift(num);\n    return value;\n  }\n  /**\n   * Read ULEB value - an integer of varying size. Used for enum indexes and\n   * vector lengths.\n   * @returns {Number} The ULEB value.\n   */\n  readULEB() {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let buffer = new Uint8Array(this.dataView.buffer, start);\n    let { value, length } = ulebDecode(buffer);\n    this.shift(length);\n    return value;\n  }\n  /**\n   * Read a BCS vector: read a length and then apply function `cb` X times\n   * where X is the length of the vector, defined as ULEB in BCS bytes.\n   * @param cb Callback to process elements of vector.\n   * @returns {Array<Any>} Array of the resulting values, returned by callback.\n   */\n  readVec(cb) {\n    let length = this.readULEB();\n    let result = [];\n    for (let i = 0; i < length; i++) {\n      result.push(cb(this, i, length));\n    }\n    return result;\n  }\n}\nexport {\n  BcsReader\n};\n//# sourceMappingURL=reader.js.map\n","import { fromBase58, toBase58 } from \"./b58.js\";\nimport { fromBase64, toBase64 } from \"./b64.js\";\nimport { fromHex, toHex } from \"./hex.js\";\nfunction encodeStr(data, encoding) {\n  switch (encoding) {\n    case \"base58\":\n      return toBase58(data);\n    case \"base64\":\n      return toBase64(data);\n    case \"hex\":\n      return toHex(data);\n    default:\n      throw new Error(\"Unsupported encoding, supported values are: base64, hex\");\n  }\n}\nfunction decodeStr(data, encoding) {\n  switch (encoding) {\n    case \"base58\":\n      return fromBase58(data);\n    case \"base64\":\n      return fromBase64(data);\n    case \"hex\":\n      return fromHex(data);\n    default:\n      throw new Error(\"Unsupported encoding, supported values are: base64, hex\");\n  }\n}\nfunction splitGenericParameters(str, genericSeparators = [\"<\", \">\"]) {\n  const [left, right] = genericSeparators;\n  const tok = [];\n  let word = \"\";\n  let nestedAngleBrackets = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n    if (char === left) {\n      nestedAngleBrackets++;\n    }\n    if (char === right) {\n      nestedAngleBrackets--;\n    }\n    if (nestedAngleBrackets === 0 && char === \",\") {\n      tok.push(word.trim());\n      word = \"\";\n      continue;\n    }\n    word += char;\n  }\n  tok.push(word.trim());\n  return tok;\n}\nexport {\n  decodeStr,\n  encodeStr,\n  splitGenericParameters\n};\n//# sourceMappingURL=utils.js.map\n","import { ulebEncode } from \"./uleb.js\";\nimport { encodeStr } from \"./utils.js\";\nclass BcsWriter {\n  constructor({\n    initialSize = 1024,\n    maxSize = Infinity,\n    allocateSize = 1024\n  } = {}) {\n    this.bytePosition = 0;\n    this.size = initialSize;\n    this.maxSize = maxSize;\n    this.allocateSize = allocateSize;\n    this.dataView = new DataView(new ArrayBuffer(initialSize));\n  }\n  ensureSizeOrGrow(bytes) {\n    const requiredSize = this.bytePosition + bytes;\n    if (requiredSize > this.size) {\n      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n      if (requiredSize > nextSize) {\n        throw new Error(\n          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`\n        );\n      }\n      this.size = nextSize;\n      const nextBuffer = new ArrayBuffer(this.size);\n      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n      this.dataView = new DataView(nextBuffer);\n    }\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Write a U8 value into a buffer and shift cursor position by 1.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write8(value) {\n    this.ensureSizeOrGrow(1);\n    this.dataView.setUint8(this.bytePosition, Number(value));\n    return this.shift(1);\n  }\n  /**\n   * Write a U16 value into a buffer and shift cursor position by 2.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write16(value) {\n    this.ensureSizeOrGrow(2);\n    this.dataView.setUint16(this.bytePosition, Number(value), true);\n    return this.shift(2);\n  }\n  /**\n   * Write a U32 value into a buffer and shift cursor position by 4.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write32(value) {\n    this.ensureSizeOrGrow(4);\n    this.dataView.setUint32(this.bytePosition, Number(value), true);\n    return this.shift(4);\n  }\n  /**\n   * Write a U64 value into a buffer and shift cursor position by 8.\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write64(value) {\n    toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U128 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write128(value) {\n    toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U256 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write256(value) {\n    toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a ULEB value into a buffer and shift cursor position by number of bytes\n   * written.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  writeULEB(value) {\n    ulebEncode(value).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a vector into a buffer by first writing the vector length and then calling\n   * a callback on each passed value.\n   *\n   * @param {Array<Any>} vector Array of elements to write.\n   * @param {WriteVecCb} cb Callback to call on each element of the vector.\n   * @returns {this}\n   */\n  writeVec(vector, cb) {\n    this.writeULEB(vector.length);\n    Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n    return this;\n  }\n  /**\n   * Adds support for iterations over the object.\n   * @returns {Uint8Array}\n   */\n  *[Symbol.iterator]() {\n    for (let i = 0; i < this.bytePosition; i++) {\n      yield this.dataView.getUint8(i);\n    }\n    return this.toBytes();\n  }\n  /**\n   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n   * @returns {Uint8Array} Resulting bcs.\n   */\n  toBytes() {\n    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n  }\n  /**\n   * Represent data as 'hex' or 'base64'\n   * @param encoding Encoding to use: 'base64' or 'hex'\n   */\n  toString(encoding) {\n    return encodeStr(this.toBytes(), encoding);\n  }\n}\nfunction toLittleEndian(bigint, size) {\n  let result = new Uint8Array(size);\n  let i = 0;\n  while (bigint > 0) {\n    result[i] = Number(bigint % BigInt(256));\n    bigint = bigint / BigInt(256);\n    i += 1;\n  }\n  return result;\n}\nexport {\n  BcsWriter\n};\n//# sourceMappingURL=writer.js.map\n","var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _write, _serialize, _schema, _bytes;\nimport { fromBase58, toBase58 } from \"./b58.js\";\nimport { fromBase64, toBase64 } from \"./b64.js\";\nimport { fromHex, toHex } from \"./hex.js\";\nimport { BcsReader } from \"./reader.js\";\nimport { ulebEncode } from \"./uleb.js\";\nimport { BcsWriter } from \"./writer.js\";\nconst _BcsType = class _BcsType {\n  constructor(options) {\n    __privateAdd(this, _write);\n    __privateAdd(this, _serialize);\n    this.name = options.name;\n    this.read = options.read;\n    this.serializedSize = options.serializedSize ?? (() => null);\n    __privateSet(this, _write, options.write);\n    __privateSet(this, _serialize, options.serialize ?? ((value, options2) => {\n      const writer = new BcsWriter({\n        initialSize: this.serializedSize(value) ?? void 0,\n        ...options2\n      });\n      __privateGet(this, _write).call(this, value, writer);\n      return writer.toBytes();\n    }));\n    this.validate = options.validate ?? (() => {\n    });\n  }\n  write(value, writer) {\n    this.validate(value);\n    __privateGet(this, _write).call(this, value, writer);\n  }\n  serialize(value, options) {\n    this.validate(value);\n    return new SerializedBcs(this, __privateGet(this, _serialize).call(this, value, options));\n  }\n  parse(bytes) {\n    const reader = new BcsReader(bytes);\n    return this.read(reader);\n  }\n  fromHex(hex) {\n    return this.parse(fromHex(hex));\n  }\n  fromBase58(b64) {\n    return this.parse(fromBase58(b64));\n  }\n  fromBase64(b64) {\n    return this.parse(fromBase64(b64));\n  }\n  transform({\n    name,\n    input,\n    output,\n    validate\n  }) {\n    return new _BcsType({\n      name: name ?? this.name,\n      read: (reader) => output ? output(this.read(reader)) : this.read(reader),\n      write: (value, writer) => __privateGet(this, _write).call(this, input ? input(value) : value, writer),\n      serializedSize: (value) => this.serializedSize(input ? input(value) : value),\n      serialize: (value, options) => __privateGet(this, _serialize).call(this, input ? input(value) : value, options),\n      validate: (value) => {\n        validate?.(value);\n        this.validate(input ? input(value) : value);\n      }\n    });\n  }\n};\n_write = new WeakMap();\n_serialize = new WeakMap();\nlet BcsType = _BcsType;\nconst SERIALIZED_BCS_BRAND = Symbol.for(\"@mysten/serialized-bcs\");\nfunction isSerializedBcs(obj) {\n  return !!obj && typeof obj === \"object\" && obj[SERIALIZED_BCS_BRAND] === true;\n}\nclass SerializedBcs {\n  constructor(type, schema) {\n    __privateAdd(this, _schema);\n    __privateAdd(this, _bytes);\n    __privateSet(this, _schema, type);\n    __privateSet(this, _bytes, schema);\n  }\n  // Used to brand SerializedBcs so that they can be identified, even between multiple copies\n  // of the @mysten/bcs package are installed\n  get [SERIALIZED_BCS_BRAND]() {\n    return true;\n  }\n  toBytes() {\n    return __privateGet(this, _bytes);\n  }\n  toHex() {\n    return toHex(__privateGet(this, _bytes));\n  }\n  toBase64() {\n    return toBase64(__privateGet(this, _bytes));\n  }\n  toBase58() {\n    return toBase58(__privateGet(this, _bytes));\n  }\n  parse() {\n    return __privateGet(this, _schema).parse(__privateGet(this, _bytes));\n  }\n}\n_schema = new WeakMap();\n_bytes = new WeakMap();\nfunction fixedSizeBcsType({\n  size,\n  ...options\n}) {\n  return new BcsType({\n    ...options,\n    serializedSize: () => size\n  });\n}\nfunction uIntBcsType({\n  readMethod,\n  writeMethod,\n  ...options\n}) {\n  return fixedSizeBcsType({\n    ...options,\n    read: (reader) => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](value),\n    validate: (value) => {\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(\n          `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`\n        );\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction bigUIntBcsType({\n  readMethod,\n  writeMethod,\n  ...options\n}) {\n  return fixedSizeBcsType({\n    ...options,\n    read: (reader) => reader[readMethod](),\n    write: (value, writer) => writer[writeMethod](BigInt(value)),\n    validate: (val) => {\n      const value = BigInt(val);\n      if (value < 0 || value > options.maxValue) {\n        throw new TypeError(\n          `Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`\n        );\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction dynamicSizeBcsType({\n  serialize,\n  ...options\n}) {\n  const type = new BcsType({\n    ...options,\n    serialize,\n    write: (value, writer) => {\n      for (const byte of type.serialize(value).toBytes()) {\n        writer.write8(byte);\n      }\n    }\n  });\n  return type;\n}\nfunction stringLikeBcsType({\n  toBytes,\n  fromBytes,\n  ...options\n}) {\n  return new BcsType({\n    ...options,\n    read: (reader) => {\n      const length = reader.readULEB();\n      const bytes = reader.readBytes(length);\n      return fromBytes(bytes);\n    },\n    write: (hex, writer) => {\n      const bytes = toBytes(hex);\n      writer.writeULEB(bytes.length);\n      for (let i = 0; i < bytes.length; i++) {\n        writer.write8(bytes[i]);\n      }\n    },\n    serialize: (value) => {\n      const bytes = toBytes(value);\n      const size = ulebEncode(bytes.length);\n      const result = new Uint8Array(size.length + bytes.length);\n      result.set(size, 0);\n      result.set(bytes, size.length);\n      return result;\n    },\n    validate: (value) => {\n      if (typeof value !== \"string\") {\n        throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n      }\n      options.validate?.(value);\n    }\n  });\n}\nfunction lazyBcsType(cb) {\n  let lazyType = null;\n  function getType() {\n    if (!lazyType) {\n      lazyType = cb();\n    }\n    return lazyType;\n  }\n  return new BcsType({\n    name: \"lazy\",\n    read: (data) => getType().read(data),\n    serializedSize: (value) => getType().serializedSize(value),\n    write: (value, writer) => getType().write(value, writer),\n    serialize: (value, options) => getType().serialize(value, options).toBytes()\n  });\n}\nexport {\n  BcsType,\n  SerializedBcs,\n  bigUIntBcsType,\n  dynamicSizeBcsType,\n  fixedSizeBcsType,\n  isSerializedBcs,\n  lazyBcsType,\n  stringLikeBcsType,\n  uIntBcsType\n};\n//# sourceMappingURL=bcs-type.js.map\n","import {\n  BcsType,\n  bigUIntBcsType,\n  dynamicSizeBcsType,\n  fixedSizeBcsType,\n  lazyBcsType,\n  stringLikeBcsType,\n  uIntBcsType\n} from \"./bcs-type.js\";\nimport { ulebEncode } from \"./uleb.js\";\nconst bcs = {\n  /**\n   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n   * @example\n   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n   */\n  u8(options) {\n    return uIntBcsType({\n      name: \"u8\",\n      readMethod: \"read8\",\n      writeMethod: \"write8\",\n      size: 1,\n      maxValue: 2 ** 8 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n   * @example\n   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n   */\n  u16(options) {\n    return uIntBcsType({\n      name: \"u16\",\n      readMethod: \"read16\",\n      writeMethod: \"write16\",\n      size: 2,\n      maxValue: 2 ** 16 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n   * @example\n   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n   */\n  u32(options) {\n    return uIntBcsType({\n      name: \"u32\",\n      readMethod: \"read32\",\n      writeMethod: \"write32\",\n      size: 4,\n      maxValue: 2 ** 32 - 1,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n   * @example\n   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n   */\n  u64(options) {\n    return bigUIntBcsType({\n      name: \"u64\",\n      readMethod: \"read64\",\n      writeMethod: \"write64\",\n      size: 8,\n      maxValue: 2n ** 64n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n   * @example\n   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u128(options) {\n    return bigUIntBcsType({\n      name: \"u128\",\n      readMethod: \"read128\",\n      writeMethod: \"write128\",\n      size: 16,\n      maxValue: 2n ** 128n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n   * @example\n   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */\n  u256(options) {\n    return bigUIntBcsType({\n      name: \"u256\",\n      readMethod: \"read256\",\n      writeMethod: \"write256\",\n      size: 32,\n      maxValue: 2n ** 256n - 1n,\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write boolean values.\n   * @example\n   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n   */\n  bool(options) {\n    return fixedSizeBcsType({\n      name: \"bool\",\n      size: 1,\n      read: (reader) => reader.read8() === 1,\n      write: (value, writer) => writer.write8(value ? 1 : 0),\n      ...options,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (typeof value !== \"boolean\") {\n          throw new TypeError(`Expected boolean, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n   * @example\n   *\n   */\n  uleb128(options) {\n    return dynamicSizeBcsType({\n      name: \"uleb128\",\n      read: (reader) => reader.readULEB(),\n      serialize: (value) => {\n        return Uint8Array.from(ulebEncode(value));\n      },\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType representing a fixed length byte array\n   * @param size The number of bytes this types represents\n   * @example\n   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n   */\n  bytes(size, options) {\n    return fixedSizeBcsType({\n      name: `bytes[${size}]`,\n      size,\n      read: (reader) => reader.readBytes(size),\n      write: (value, writer) => {\n        const array = new Uint8Array(value);\n        for (let i = 0; i < size; i++) {\n          writer.write8(array[i] ?? 0);\n        }\n      },\n      ...options,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== size) {\n          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a variable length byte array\n   *\n   * @example\n   * bcs.byteVector().serialize([1, 2, 3]).toBytes() // Uint8Array [3, 1, 2, 3]\n   */\n  byteVector(options) {\n    return new BcsType({\n      name: `bytesVector`,\n      read: (reader) => {\n        const length = reader.readULEB();\n        return reader.readBytes(length);\n      },\n      write: (value, writer) => {\n        const array = new Uint8Array(value);\n        writer.writeULEB(array.length);\n        for (let i = 0; i < array.length; i++) {\n          writer.write8(array[i] ?? 0);\n        }\n      },\n      ...options,\n      serializedSize: (value) => {\n        const length = \"length\" in value ? value.length : null;\n        return length == null ? null : ulebEncode(length).length + length;\n      },\n      validate: (value) => {\n        options?.validate?.(value);\n        if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n   * @example\n   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n   */\n  string(options) {\n    return stringLikeBcsType({\n      name: \"string\",\n      toBytes: (value) => new TextEncoder().encode(value),\n      fromBytes: (bytes) => new TextDecoder().decode(bytes),\n      ...options\n    });\n  },\n  /**\n   * Creates a BcsType that represents a fixed length array of a given type\n   * @param size The number of elements in the array\n   * @param type The BcsType of each element in the array\n   * @example\n   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n   */\n  fixedArray(size, type, options) {\n    return new BcsType({\n      name: `${type.name}[${size}]`,\n      read: (reader) => {\n        const result = new Array(size);\n        for (let i = 0; i < size; i++) {\n          result[i] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (const item of value) {\n          type.write(item, writer);\n        }\n      },\n      ...options,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== size) {\n          throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing an optional value\n   * @param type The BcsType of the optional value\n   * @example\n   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n   */\n  option(type) {\n    return bcs.enum(`Option<${type.name}>`, {\n      None: null,\n      Some: type\n    }).transform({\n      input: (value) => {\n        if (value == null) {\n          return { None: true };\n        }\n        return { Some: value };\n      },\n      output: (value) => {\n        if (value.$kind === \"Some\") {\n          return value.Some;\n        }\n        return null;\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a variable length vector of a given type\n   * @param type The BcsType of each element in the vector\n   *\n   * @example\n   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n   */\n  vector(type, options) {\n    return new BcsType({\n      name: `vector<${type.name}>`,\n      read: (reader) => {\n        const length = reader.readULEB();\n        const result = new Array(length);\n        for (let i = 0; i < length; i++) {\n          result[i] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        writer.writeULEB(value.length);\n        for (const item of value) {\n          type.write(item, writer);\n        }\n      },\n      ...options,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (!value || typeof value !== \"object\" || !(\"length\" in value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a tuple of a given set of types\n   * @param types The BcsTypes for each element in the tuple\n   *\n   * @example\n   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n   */\n  tuple(types, options) {\n    return new BcsType({\n      name: `(${types.map((t) => t.name).join(\", \")})`,\n      serializedSize: (values) => {\n        let total = 0;\n        for (let i = 0; i < types.length; i++) {\n          const size = types[i].serializedSize(values[i]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: (reader) => {\n        const result = [];\n        for (const type of types) {\n          result.push(type.read(reader));\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (let i = 0; i < types.length; i++) {\n          types[i].write(value[i], writer);\n        }\n      },\n      ...options,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (!Array.isArray(value)) {\n          throw new TypeError(`Expected array, found ${typeof value}`);\n        }\n        if (value.length !== types.length) {\n          throw new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a struct of a given set of fields\n   * @param name The name of the struct\n   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n   *\n   * @example\n   * const struct = bcs.struct('MyStruct', {\n   *  a: bcs.u8(),\n   *  b: bcs.string(),\n   * })\n   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   */\n  struct(name, fields, options) {\n    const canonicalOrder = Object.entries(fields);\n    return new BcsType({\n      name,\n      serializedSize: (values) => {\n        let total = 0;\n        for (const [field, type] of canonicalOrder) {\n          const size = type.serializedSize(values[field]);\n          if (size == null) {\n            return null;\n          }\n          total += size;\n        }\n        return total;\n      },\n      read: (reader) => {\n        const result = {};\n        for (const [field, type] of canonicalOrder) {\n          result[field] = type.read(reader);\n        }\n        return result;\n      },\n      write: (value, writer) => {\n        for (const [field, type] of canonicalOrder) {\n          type.write(value[field], writer);\n        }\n      },\n      ...options,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(`Expected object, found ${typeof value}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing an enum of a given set of options\n   * @param name The name of the enum\n   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n   * null can be used to represent a variant with no data.\n   *\n   * @example\n   * const enum = bcs.enum('MyEnum', {\n   *   A: bcs.u8(),\n   *   B: bcs.string(),\n   *   C: null,\n   * })\n   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n   */\n  enum(name, values, options) {\n    const canonicalOrder = Object.entries(values);\n    return new BcsType({\n      name,\n      read: (reader) => {\n        const index = reader.readULEB();\n        const enumEntry = canonicalOrder[index];\n        if (!enumEntry) {\n          throw new TypeError(`Unknown value ${index} for enum ${name}`);\n        }\n        const [kind, type] = enumEntry;\n        return {\n          [kind]: type?.read(reader) ?? true,\n          $kind: kind\n        };\n      },\n      write: (value, writer) => {\n        const [name2, val] = Object.entries(value).filter(\n          ([name3]) => Object.hasOwn(values, name3)\n        )[0];\n        for (let i = 0; i < canonicalOrder.length; i++) {\n          const [optionName, optionType] = canonicalOrder[i];\n          if (optionName === name2) {\n            writer.writeULEB(i);\n            optionType?.write(val, writer);\n            return;\n          }\n        }\n      },\n      ...options,\n      validate: (value) => {\n        options?.validate?.(value);\n        if (typeof value !== \"object\" || value == null) {\n          throw new TypeError(`Expected object, found ${typeof value}`);\n        }\n        const keys = Object.keys(value).filter(\n          (k) => value[k] !== void 0 && Object.hasOwn(values, k)\n        );\n        if (keys.length !== 1) {\n          throw new TypeError(\n            `Expected object with one key, but found ${keys.length} for type ${name}}`\n          );\n        }\n        const [variant] = keys;\n        if (!Object.hasOwn(values, variant)) {\n          throw new TypeError(`Invalid enum variant ${variant}`);\n        }\n      }\n    });\n  },\n  /**\n   * Creates a BcsType representing a map of a given key and value type\n   * @param keyType The BcsType of the key\n   * @param valueType The BcsType of the value\n   * @example\n   * const map = bcs.map(bcs.u8(), bcs.string())\n   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n   */\n  map(keyType, valueType) {\n    return bcs.vector(bcs.tuple([keyType, valueType])).transform({\n      name: `Map<${keyType.name}, ${valueType.name}>`,\n      input: (value) => {\n        return [...value.entries()];\n      },\n      output: (value) => {\n        const result = /* @__PURE__ */ new Map();\n        for (const [key, val] of value) {\n          result.set(key, val);\n        }\n        return result;\n      }\n    });\n  },\n  /**\n   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n   * @param cb A callback that returns the BcsType\n   */\n  lazy(cb) {\n    return lazyBcsType(cb);\n  }\n};\nexport {\n  bcs\n};\n//# sourceMappingURL=bcs.js.map\n","class Experimental_SuiClient {\n  constructor({ network }) {\n    this.network = network;\n  }\n  $extend(...registrations) {\n    return Object.create(\n      this,\n      Object.fromEntries(\n        registrations.map((registration) => {\n          if (\"experimental_asClientExtension\" in registration) {\n            const { name, register } = registration.experimental_asClientExtension();\n            return [name, { value: register(this) }];\n          }\n          return [registration.name, { value: registration.register(this) }];\n        })\n      )\n    );\n  }\n}\nexport {\n  Experimental_SuiClient\n};\n//# sourceMappingURL=client.js.map\n","const SUI_NS_NAME_REGEX = /^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i;\nconst SUI_NS_DOMAIN_REGEX = /^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\\.)+sui$/i;\nconst MAX_SUI_NS_NAME_LENGTH = 235;\nfunction isValidSuiNSName(name) {\n  if (name.length > MAX_SUI_NS_NAME_LENGTH) {\n    return false;\n  }\n  if (name.includes(\"@\")) {\n    return SUI_NS_NAME_REGEX.test(name);\n  }\n  return SUI_NS_DOMAIN_REGEX.test(name);\n}\nfunction normalizeSuiNSName(name, format = \"at\") {\n  const lowerCase = name.toLowerCase();\n  let parts;\n  if (lowerCase.includes(\"@\")) {\n    if (!SUI_NS_NAME_REGEX.test(lowerCase)) {\n      throw new Error(`Invalid SuiNS name ${name}`);\n    }\n    const [labels, domain] = lowerCase.split(\"@\");\n    parts = [...labels ? labels.split(\".\") : [], domain];\n  } else {\n    if (!SUI_NS_DOMAIN_REGEX.test(lowerCase)) {\n      throw new Error(`Invalid SuiNS name ${name}`);\n    }\n    parts = lowerCase.split(\".\").slice(0, -1);\n  }\n  if (format === \"dot\") {\n    return `${parts.join(\".\")}.sui`;\n  }\n  return `${parts.slice(0, -1).join(\".\")}@${parts[parts.length - 1]}`;\n}\nexport {\n  isValidSuiNSName,\n  normalizeSuiNSName\n};\n//# sourceMappingURL=suins.js.map\n","import { isValidSuiNSName } from \"./suins.js\";\nconst NAME_PATTERN = /^([a-z0-9]+(?:-[a-z0-9]+)*)$/;\nconst VERSION_REGEX = /^\\d+$/;\nconst MAX_APP_SIZE = 64;\nconst NAME_SEPARATOR = \"/\";\nconst isValidNamedPackage = (name) => {\n  const parts = name.split(NAME_SEPARATOR);\n  if (parts.length < 2 || parts.length > 3) return false;\n  const [org, app, version] = parts;\n  if (version !== void 0 && !VERSION_REGEX.test(version)) return false;\n  if (!isValidSuiNSName(org)) return false;\n  return NAME_PATTERN.test(app) && app.length < MAX_APP_SIZE;\n};\nconst isValidNamedType = (type) => {\n  const splitType = type.split(/::|<|>|,/);\n  for (const t of splitType) {\n    if (t.includes(NAME_SEPARATOR) && !isValidNamedPackage(t)) return false;\n  }\n  return true;\n};\nexport {\n  isValidNamedPackage,\n  isValidNamedType\n};\n//# sourceMappingURL=move-registry.js.map\n","import { fromBase58, splitGenericParameters } from \"@mysten/bcs\";\nimport { isValidNamedPackage } from \"./move-registry.js\";\nconst TX_DIGEST_LENGTH = 32;\nfunction isValidTransactionDigest(value) {\n  try {\n    const buffer = fromBase58(value);\n    return buffer.length === TX_DIGEST_LENGTH;\n  } catch (e) {\n    return false;\n  }\n}\nconst SUI_ADDRESS_LENGTH = 32;\nfunction isValidSuiAddress(value) {\n  return isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\nfunction isValidSuiObjectId(value) {\n  return isValidSuiAddress(value);\n}\nfunction parseTypeTag(type) {\n  if (!type.includes(\"::\")) return type;\n  return parseStructTag(type);\n}\nfunction parseStructTag(type) {\n  const [address, module] = type.split(\"::\");\n  const isMvrPackage = isValidNamedPackage(address);\n  const rest = type.slice(address.length + module.length + 4);\n  const name = rest.includes(\"<\") ? rest.slice(0, rest.indexOf(\"<\")) : rest;\n  const typeParams = rest.includes(\"<\") ? splitGenericParameters(rest.slice(rest.indexOf(\"<\") + 1, rest.lastIndexOf(\">\"))).map(\n    (typeParam) => parseTypeTag(typeParam.trim())\n  ) : [];\n  return {\n    address: isMvrPackage ? address : normalizeSuiAddress(address),\n    module,\n    name,\n    typeParams\n  };\n}\nfunction normalizeStructTag(type) {\n  const { address, module, name, typeParams } = typeof type === \"string\" ? parseStructTag(type) : type;\n  const formattedTypeParams = typeParams?.length > 0 ? `<${typeParams.map(\n    (typeParam) => typeof typeParam === \"string\" ? typeParam : normalizeStructTag(typeParam)\n  ).join(\",\")}>` : \"\";\n  return `${address}::${module}::${name}${formattedTypeParams}`;\n}\nfunction normalizeSuiAddress(value, forceAdd0x = false) {\n  let address = value.toLowerCase();\n  if (!forceAdd0x && address.startsWith(\"0x\")) {\n    address = address.slice(2);\n  }\n  return `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, \"0\")}`;\n}\nfunction normalizeSuiObjectId(value, forceAdd0x = false) {\n  return normalizeSuiAddress(value, forceAdd0x);\n}\nfunction isHex(value) {\n  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\nfunction getHexByteLength(value) {\n  return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\nexport {\n  SUI_ADDRESS_LENGTH,\n  isValidSuiAddress,\n  isValidSuiObjectId,\n  isValidTransactionDigest,\n  normalizeStructTag,\n  normalizeSuiAddress,\n  normalizeSuiObjectId,\n  parseStructTag\n};\n//# sourceMappingURL=sui-types.js.map\n","import { splitGenericParameters } from \"@mysten/bcs\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\nclass TypeTagSerializer {\n  static parseFromStr(str, normalizeAddress = false) {\n    if (str === \"address\") {\n      return { address: null };\n    } else if (str === \"bool\") {\n      return { bool: null };\n    } else if (str === \"u8\") {\n      return { u8: null };\n    } else if (str === \"u16\") {\n      return { u16: null };\n    } else if (str === \"u32\") {\n      return { u32: null };\n    } else if (str === \"u64\") {\n      return { u64: null };\n    } else if (str === \"u128\") {\n      return { u128: null };\n    } else if (str === \"u256\") {\n      return { u256: null };\n    } else if (str === \"signer\") {\n      return { signer: null };\n    }\n    const vectorMatch = str.match(VECTOR_REGEX);\n    if (vectorMatch) {\n      return {\n        vector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress)\n      };\n    }\n    const structMatch = str.match(STRUCT_REGEX);\n    if (structMatch) {\n      const address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n      return {\n        struct: {\n          address,\n          module: structMatch[2],\n          name: structMatch[3],\n          typeParams: structMatch[5] === void 0 ? [] : TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress)\n        }\n      };\n    }\n    throw new Error(`Encountered unexpected token when parsing type args for ${str}`);\n  }\n  static parseStructTypeArgs(str, normalizeAddress = false) {\n    return splitGenericParameters(str).map(\n      (tok) => TypeTagSerializer.parseFromStr(tok, normalizeAddress)\n    );\n  }\n  static tagToString(tag) {\n    if (\"bool\" in tag) {\n      return \"bool\";\n    }\n    if (\"u8\" in tag) {\n      return \"u8\";\n    }\n    if (\"u16\" in tag) {\n      return \"u16\";\n    }\n    if (\"u32\" in tag) {\n      return \"u32\";\n    }\n    if (\"u64\" in tag) {\n      return \"u64\";\n    }\n    if (\"u128\" in tag) {\n      return \"u128\";\n    }\n    if (\"u256\" in tag) {\n      return \"u256\";\n    }\n    if (\"address\" in tag) {\n      return \"address\";\n    }\n    if (\"signer\" in tag) {\n      return \"signer\";\n    }\n    if (\"vector\" in tag) {\n      return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n    }\n    if (\"struct\" in tag) {\n      const struct = tag.struct;\n      const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(\", \");\n      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : \"\"}`;\n    }\n    throw new Error(\"Invalid TypeTag\");\n  }\n}\nexport {\n  TypeTagSerializer\n};\n//# sourceMappingURL=type-tag-serializer.js.map\n","import { bcs, fromBase58, fromBase64, fromHex, toBase58, toBase64, toHex } from \"@mysten/bcs\";\nimport { isValidSuiAddress, normalizeSuiAddress, SUI_ADDRESS_LENGTH } from \"../utils/sui-types.js\";\nimport { TypeTagSerializer } from \"./type-tag-serializer.js\";\nfunction unsafe_u64(options) {\n  return bcs.u64({\n    name: \"unsafe_u64\",\n    ...options\n  }).transform({\n    input: (val) => val,\n    output: (val) => Number(val)\n  });\n}\nfunction optionEnum(type) {\n  return bcs.enum(\"Option\", {\n    None: null,\n    Some: type\n  });\n}\nconst Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n  validate: (val) => {\n    const address = typeof val === \"string\" ? val : toHex(val);\n    if (!address || !isValidSuiAddress(normalizeSuiAddress(address))) {\n      throw new Error(`Invalid Sui address ${address}`);\n    }\n  },\n  input: (val) => typeof val === \"string\" ? fromHex(normalizeSuiAddress(val)) : val,\n  output: (val) => normalizeSuiAddress(toHex(val))\n});\nconst ObjectDigest = bcs.vector(bcs.u8()).transform({\n  name: \"ObjectDigest\",\n  input: (value) => fromBase58(value),\n  output: (value) => toBase58(new Uint8Array(value)),\n  validate: (value) => {\n    if (fromBase58(value).length !== 32) {\n      throw new Error(\"ObjectDigest must be 32 bytes\");\n    }\n  }\n});\nconst SuiObjectRef = bcs.struct(\"SuiObjectRef\", {\n  objectId: Address,\n  version: bcs.u64(),\n  digest: ObjectDigest\n});\nconst SharedObjectRef = bcs.struct(\"SharedObjectRef\", {\n  objectId: Address,\n  initialSharedVersion: bcs.u64(),\n  mutable: bcs.bool()\n});\nconst ObjectArg = bcs.enum(\"ObjectArg\", {\n  ImmOrOwnedObject: SuiObjectRef,\n  SharedObject: SharedObjectRef,\n  Receiving: SuiObjectRef\n});\nconst CallArg = bcs.enum(\"CallArg\", {\n  Pure: bcs.struct(\"Pure\", {\n    bytes: bcs.vector(bcs.u8()).transform({\n      input: (val) => typeof val === \"string\" ? fromBase64(val) : val,\n      output: (val) => toBase64(new Uint8Array(val))\n    })\n  }),\n  Object: ObjectArg\n});\nconst InnerTypeTag = bcs.enum(\"TypeTag\", {\n  bool: null,\n  u8: null,\n  u64: null,\n  u128: null,\n  address: null,\n  signer: null,\n  vector: bcs.lazy(() => InnerTypeTag),\n  struct: bcs.lazy(() => StructTag),\n  u16: null,\n  u32: null,\n  u256: null\n});\nconst TypeTag = InnerTypeTag.transform({\n  input: (typeTag) => typeof typeTag === \"string\" ? TypeTagSerializer.parseFromStr(typeTag, true) : typeTag,\n  output: (typeTag) => TypeTagSerializer.tagToString(typeTag)\n});\nconst Argument = bcs.enum(\"Argument\", {\n  GasCoin: null,\n  Input: bcs.u16(),\n  Result: bcs.u16(),\n  NestedResult: bcs.tuple([bcs.u16(), bcs.u16()])\n});\nconst ProgrammableMoveCall = bcs.struct(\"ProgrammableMoveCall\", {\n  package: Address,\n  module: bcs.string(),\n  function: bcs.string(),\n  typeArguments: bcs.vector(TypeTag),\n  arguments: bcs.vector(Argument)\n});\nconst Command = bcs.enum(\"Command\", {\n  /**\n   * A Move Call - any public Move function can be called via\n   * this transaction. The results can be used that instant to pass\n   * into the next transaction.\n   */\n  MoveCall: ProgrammableMoveCall,\n  /**\n   * Transfer vector of objects to a receiver.\n   */\n  TransferObjects: bcs.struct(\"TransferObjects\", {\n    objects: bcs.vector(Argument),\n    address: Argument\n  }),\n  // /**\n  //  * Split `amount` from a `coin`.\n  //  */\n  SplitCoins: bcs.struct(\"SplitCoins\", {\n    coin: Argument,\n    amounts: bcs.vector(Argument)\n  }),\n  // /**\n  //  * Merge Vector of Coins (`sources`) into a `destination`.\n  //  */\n  MergeCoins: bcs.struct(\"MergeCoins\", {\n    destination: Argument,\n    sources: bcs.vector(Argument)\n  }),\n  // /**\n  //  * Publish a Move module.\n  //  */\n  Publish: bcs.struct(\"Publish\", {\n    modules: bcs.vector(\n      bcs.vector(bcs.u8()).transform({\n        input: (val) => typeof val === \"string\" ? fromBase64(val) : val,\n        output: (val) => toBase64(new Uint8Array(val))\n      })\n    ),\n    dependencies: bcs.vector(Address)\n  }),\n  // /**\n  //  * Build a vector of objects using the input arguments.\n  //  * It is impossible to export construct a `vector<T: key>` otherwise,\n  //  * so this call serves a utility function.\n  //  */\n  MakeMoveVec: bcs.struct(\"MakeMoveVec\", {\n    type: optionEnum(TypeTag).transform({\n      input: (val) => val === null ? {\n        None: true\n      } : {\n        Some: val\n      },\n      output: (val) => val.Some ?? null\n    }),\n    elements: bcs.vector(Argument)\n  }),\n  Upgrade: bcs.struct(\"Upgrade\", {\n    modules: bcs.vector(\n      bcs.vector(bcs.u8()).transform({\n        input: (val) => typeof val === \"string\" ? fromBase64(val) : val,\n        output: (val) => toBase64(new Uint8Array(val))\n      })\n    ),\n    dependencies: bcs.vector(Address),\n    package: Address,\n    ticket: Argument\n  })\n});\nconst ProgrammableTransaction = bcs.struct(\"ProgrammableTransaction\", {\n  inputs: bcs.vector(CallArg),\n  commands: bcs.vector(Command)\n});\nconst TransactionKind = bcs.enum(\"TransactionKind\", {\n  ProgrammableTransaction,\n  ChangeEpoch: null,\n  Genesis: null,\n  ConsensusCommitPrologue: null\n});\nconst TransactionExpiration = bcs.enum(\"TransactionExpiration\", {\n  None: null,\n  Epoch: unsafe_u64()\n});\nconst StructTag = bcs.struct(\"StructTag\", {\n  address: Address,\n  module: bcs.string(),\n  name: bcs.string(),\n  typeParams: bcs.vector(InnerTypeTag)\n});\nconst GasData = bcs.struct(\"GasData\", {\n  payment: bcs.vector(SuiObjectRef),\n  owner: Address,\n  price: bcs.u64(),\n  budget: bcs.u64()\n});\nconst TransactionDataV1 = bcs.struct(\"TransactionDataV1\", {\n  kind: TransactionKind,\n  sender: Address,\n  gasData: GasData,\n  expiration: TransactionExpiration\n});\nconst TransactionData = bcs.enum(\"TransactionData\", {\n  V1: TransactionDataV1\n});\nconst IntentScope = bcs.enum(\"IntentScope\", {\n  TransactionData: null,\n  TransactionEffects: null,\n  CheckpointSummary: null,\n  PersonalMessage: null\n});\nconst IntentVersion = bcs.enum(\"IntentVersion\", {\n  V0: null\n});\nconst AppId = bcs.enum(\"AppId\", {\n  Sui: null\n});\nconst Intent = bcs.struct(\"Intent\", {\n  scope: IntentScope,\n  version: IntentVersion,\n  appId: AppId\n});\nfunction IntentMessage(T) {\n  return bcs.struct(`IntentMessage<${T.name}>`, {\n    intent: Intent,\n    value: T\n  });\n}\nconst CompressedSignature = bcs.enum(\"CompressedSignature\", {\n  ED25519: bcs.fixedArray(64, bcs.u8()),\n  Secp256k1: bcs.fixedArray(64, bcs.u8()),\n  Secp256r1: bcs.fixedArray(64, bcs.u8()),\n  ZkLogin: bcs.vector(bcs.u8())\n});\nconst PublicKey = bcs.enum(\"PublicKey\", {\n  ED25519: bcs.fixedArray(32, bcs.u8()),\n  Secp256k1: bcs.fixedArray(33, bcs.u8()),\n  Secp256r1: bcs.fixedArray(33, bcs.u8()),\n  ZkLogin: bcs.vector(bcs.u8())\n});\nconst MultiSigPkMap = bcs.struct(\"MultiSigPkMap\", {\n  pubKey: PublicKey,\n  weight: bcs.u8()\n});\nconst MultiSigPublicKey = bcs.struct(\"MultiSigPublicKey\", {\n  pk_map: bcs.vector(MultiSigPkMap),\n  threshold: bcs.u16()\n});\nconst MultiSig = bcs.struct(\"MultiSig\", {\n  sigs: bcs.vector(CompressedSignature),\n  bitmap: bcs.u16(),\n  multisig_pk: MultiSigPublicKey\n});\nconst base64String = bcs.vector(bcs.u8()).transform({\n  input: (val) => typeof val === \"string\" ? fromBase64(val) : val,\n  output: (val) => toBase64(new Uint8Array(val))\n});\nconst SenderSignedTransaction = bcs.struct(\"SenderSignedTransaction\", {\n  intentMessage: IntentMessage(TransactionData),\n  txSignatures: bcs.vector(base64String)\n});\nconst SenderSignedData = bcs.vector(SenderSignedTransaction, {\n  name: \"SenderSignedData\"\n});\nconst PasskeyAuthenticator = bcs.struct(\"PasskeyAuthenticator\", {\n  authenticatorData: bcs.vector(bcs.u8()),\n  clientDataJson: bcs.string(),\n  userSignature: bcs.vector(bcs.u8())\n});\nexport {\n  Address,\n  AppId,\n  Argument,\n  CallArg,\n  Command,\n  CompressedSignature,\n  GasData,\n  Intent,\n  IntentMessage,\n  IntentScope,\n  IntentVersion,\n  MultiSig,\n  MultiSigPkMap,\n  MultiSigPublicKey,\n  ObjectArg,\n  ObjectDigest,\n  PasskeyAuthenticator,\n  ProgrammableMoveCall,\n  ProgrammableTransaction,\n  PublicKey,\n  SenderSignedData,\n  SenderSignedTransaction,\n  SharedObjectRef,\n  StructTag,\n  SuiObjectRef,\n  TransactionData,\n  TransactionDataV1,\n  TransactionExpiration,\n  TransactionKind,\n  TypeTag,\n  base64String\n};\n//# sourceMappingURL=bcs.js.map\n","import { bcs } from \"@mysten/bcs\";\nimport { Address, ObjectDigest, SuiObjectRef } from \"./bcs.js\";\nconst PackageUpgradeError = bcs.enum(\"PackageUpgradeError\", {\n  UnableToFetchPackage: bcs.struct(\"UnableToFetchPackage\", { packageId: Address }),\n  NotAPackage: bcs.struct(\"NotAPackage\", { objectId: Address }),\n  IncompatibleUpgrade: null,\n  DigestDoesNotMatch: bcs.struct(\"DigestDoesNotMatch\", { digest: bcs.vector(bcs.u8()) }),\n  UnknownUpgradePolicy: bcs.struct(\"UnknownUpgradePolicy\", { policy: bcs.u8() }),\n  PackageIDDoesNotMatch: bcs.struct(\"PackageIDDoesNotMatch\", {\n    packageId: Address,\n    ticketId: Address\n  })\n});\nconst ModuleId = bcs.struct(\"ModuleId\", {\n  address: Address,\n  name: bcs.string()\n});\nconst MoveLocation = bcs.struct(\"MoveLocation\", {\n  module: ModuleId,\n  function: bcs.u16(),\n  instruction: bcs.u16(),\n  functionName: bcs.option(bcs.string())\n});\nconst CommandArgumentError = bcs.enum(\"CommandArgumentError\", {\n  TypeMismatch: null,\n  InvalidBCSBytes: null,\n  InvalidUsageOfPureArg: null,\n  InvalidArgumentToPrivateEntryFunction: null,\n  IndexOutOfBounds: bcs.struct(\"IndexOutOfBounds\", { idx: bcs.u16() }),\n  SecondaryIndexOutOfBounds: bcs.struct(\"SecondaryIndexOutOfBounds\", {\n    resultIdx: bcs.u16(),\n    secondaryIdx: bcs.u16()\n  }),\n  InvalidResultArity: bcs.struct(\"InvalidResultArity\", { resultIdx: bcs.u16() }),\n  InvalidGasCoinUsage: null,\n  InvalidValueUsage: null,\n  InvalidObjectByValue: null,\n  InvalidObjectByMutRef: null,\n  SharedObjectOperationNotAllowed: null\n});\nconst TypeArgumentError = bcs.enum(\"TypeArgumentError\", {\n  TypeNotFound: null,\n  ConstraintNotSatisfied: null\n});\nconst ExecutionFailureStatus = bcs.enum(\"ExecutionFailureStatus\", {\n  InsufficientGas: null,\n  InvalidGasObject: null,\n  InvariantViolation: null,\n  FeatureNotYetSupported: null,\n  MoveObjectTooBig: bcs.struct(\"MoveObjectTooBig\", {\n    objectSize: bcs.u64(),\n    maxObjectSize: bcs.u64()\n  }),\n  MovePackageTooBig: bcs.struct(\"MovePackageTooBig\", {\n    objectSize: bcs.u64(),\n    maxObjectSize: bcs.u64()\n  }),\n  CircularObjectOwnership: bcs.struct(\"CircularObjectOwnership\", { object: Address }),\n  InsufficientCoinBalance: null,\n  CoinBalanceOverflow: null,\n  PublishErrorNonZeroAddress: null,\n  SuiMoveVerificationError: null,\n  MovePrimitiveRuntimeError: bcs.option(MoveLocation),\n  MoveAbort: bcs.tuple([MoveLocation, bcs.u64()]),\n  VMVerificationOrDeserializationError: null,\n  VMInvariantViolation: null,\n  FunctionNotFound: null,\n  ArityMismatch: null,\n  TypeArityMismatch: null,\n  NonEntryFunctionInvoked: null,\n  CommandArgumentError: bcs.struct(\"CommandArgumentError\", {\n    argIdx: bcs.u16(),\n    kind: CommandArgumentError\n  }),\n  TypeArgumentError: bcs.struct(\"TypeArgumentError\", {\n    argumentIdx: bcs.u16(),\n    kind: TypeArgumentError\n  }),\n  UnusedValueWithoutDrop: bcs.struct(\"UnusedValueWithoutDrop\", {\n    resultIdx: bcs.u16(),\n    secondaryIdx: bcs.u16()\n  }),\n  InvalidPublicFunctionReturnType: bcs.struct(\"InvalidPublicFunctionReturnType\", {\n    idx: bcs.u16()\n  }),\n  InvalidTransferObject: null,\n  EffectsTooLarge: bcs.struct(\"EffectsTooLarge\", { currentSize: bcs.u64(), maxSize: bcs.u64() }),\n  PublishUpgradeMissingDependency: null,\n  PublishUpgradeDependencyDowngrade: null,\n  PackageUpgradeError: bcs.struct(\"PackageUpgradeError\", { upgradeError: PackageUpgradeError }),\n  WrittenObjectsTooLarge: bcs.struct(\"WrittenObjectsTooLarge\", {\n    currentSize: bcs.u64(),\n    maxSize: bcs.u64()\n  }),\n  CertificateDenied: null,\n  SuiMoveVerificationTimedout: null,\n  SharedObjectOperationNotAllowed: null,\n  InputObjectDeleted: null,\n  ExecutionCancelledDueToSharedObjectCongestion: bcs.struct(\n    \"ExecutionCancelledDueToSharedObjectCongestion\",\n    {\n      congestedObjects: bcs.vector(Address)\n    }\n  ),\n  AddressDeniedForCoin: bcs.struct(\"AddressDeniedForCoin\", {\n    address: Address,\n    coinType: bcs.string()\n  }),\n  CoinTypeGlobalPause: bcs.struct(\"CoinTypeGlobalPause\", { coinType: bcs.string() }),\n  ExecutionCancelledDueToRandomnessUnavailable: null\n});\nconst ExecutionStatus = bcs.enum(\"ExecutionStatus\", {\n  Success: null,\n  Failed: bcs.struct(\"ExecutionFailed\", {\n    error: ExecutionFailureStatus,\n    command: bcs.option(bcs.u64())\n  })\n});\nconst GasCostSummary = bcs.struct(\"GasCostSummary\", {\n  computationCost: bcs.u64(),\n  storageCost: bcs.u64(),\n  storageRebate: bcs.u64(),\n  nonRefundableStorageFee: bcs.u64()\n});\nconst Owner = bcs.enum(\"Owner\", {\n  AddressOwner: Address,\n  ObjectOwner: Address,\n  Shared: bcs.struct(\"Shared\", {\n    initialSharedVersion: bcs.u64()\n  }),\n  Immutable: null\n});\nconst TransactionEffectsV1 = bcs.struct(\"TransactionEffectsV1\", {\n  status: ExecutionStatus,\n  executedEpoch: bcs.u64(),\n  gasUsed: GasCostSummary,\n  modifiedAtVersions: bcs.vector(bcs.tuple([Address, bcs.u64()])),\n  sharedObjects: bcs.vector(SuiObjectRef),\n  transactionDigest: ObjectDigest,\n  created: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n  mutated: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n  unwrapped: bcs.vector(bcs.tuple([SuiObjectRef, Owner])),\n  deleted: bcs.vector(SuiObjectRef),\n  unwrappedThenDeleted: bcs.vector(SuiObjectRef),\n  wrapped: bcs.vector(SuiObjectRef),\n  gasObject: bcs.tuple([SuiObjectRef, Owner]),\n  eventsDigest: bcs.option(ObjectDigest),\n  dependencies: bcs.vector(ObjectDigest)\n});\nconst VersionDigest = bcs.tuple([bcs.u64(), ObjectDigest]);\nconst ObjectIn = bcs.enum(\"ObjectIn\", {\n  NotExist: null,\n  Exist: bcs.tuple([VersionDigest, Owner])\n});\nconst ObjectOut = bcs.enum(\"ObjectOut\", {\n  NotExist: null,\n  ObjectWrite: bcs.tuple([ObjectDigest, Owner]),\n  PackageWrite: VersionDigest\n});\nconst IDOperation = bcs.enum(\"IDOperation\", {\n  None: null,\n  Created: null,\n  Deleted: null\n});\nconst EffectsObjectChange = bcs.struct(\"EffectsObjectChange\", {\n  inputState: ObjectIn,\n  outputState: ObjectOut,\n  idOperation: IDOperation\n});\nconst UnchangedSharedKind = bcs.enum(\"UnchangedSharedKind\", {\n  ReadOnlyRoot: VersionDigest,\n  MutateDeleted: bcs.u64(),\n  ReadDeleted: bcs.u64(),\n  Cancelled: bcs.u64(),\n  PerEpochConfig: null\n});\nconst TransactionEffectsV2 = bcs.struct(\"TransactionEffectsV2\", {\n  status: ExecutionStatus,\n  executedEpoch: bcs.u64(),\n  gasUsed: GasCostSummary,\n  transactionDigest: ObjectDigest,\n  gasObjectIndex: bcs.option(bcs.u32()),\n  eventsDigest: bcs.option(ObjectDigest),\n  dependencies: bcs.vector(ObjectDigest),\n  lamportVersion: bcs.u64(),\n  changedObjects: bcs.vector(bcs.tuple([Address, EffectsObjectChange])),\n  unchangedSharedObjects: bcs.vector(bcs.tuple([Address, UnchangedSharedKind])),\n  auxDataDigest: bcs.option(ObjectDigest)\n});\nconst TransactionEffects = bcs.enum(\"TransactionEffects\", {\n  V1: TransactionEffectsV1,\n  V2: TransactionEffectsV2\n});\nexport {\n  TransactionEffects\n};\n//# sourceMappingURL=effects.js.map\n","import { bcs } from \"@mysten/bcs\";\nimport { Address } from \"./bcs.js\";\nfunction pureBcsSchemaFromTypeName(name) {\n  switch (name) {\n    case \"u8\":\n      return bcs.u8();\n    case \"u16\":\n      return bcs.u16();\n    case \"u32\":\n      return bcs.u32();\n    case \"u64\":\n      return bcs.u64();\n    case \"u128\":\n      return bcs.u128();\n    case \"u256\":\n      return bcs.u256();\n    case \"bool\":\n      return bcs.bool();\n    case \"string\":\n      return bcs.string();\n    case \"id\":\n    case \"address\":\n      return Address;\n  }\n  const generic = name.match(/^(vector|option)<(.+)>$/);\n  if (generic) {\n    const [kind, inner] = generic.slice(1);\n    if (kind === \"vector\") {\n      return bcs.vector(pureBcsSchemaFromTypeName(inner));\n    } else {\n      return bcs.option(pureBcsSchemaFromTypeName(inner));\n    }\n  }\n  throw new Error(`Invalid Pure type name: ${name}`);\n}\nexport {\n  pureBcsSchemaFromTypeName\n};\n//# sourceMappingURL=pure.js.map\n","import { bcs } from \"@mysten/bcs\";\nimport {\n  Address,\n  AppId,\n  Argument,\n  CallArg,\n  Command,\n  CompressedSignature,\n  GasData,\n  Intent,\n  IntentMessage,\n  IntentScope,\n  IntentVersion,\n  MultiSig,\n  MultiSigPkMap,\n  MultiSigPublicKey,\n  ObjectArg,\n  ObjectDigest,\n  PasskeyAuthenticator,\n  ProgrammableMoveCall,\n  ProgrammableTransaction,\n  PublicKey,\n  SenderSignedData,\n  SenderSignedTransaction,\n  SharedObjectRef,\n  StructTag,\n  SuiObjectRef,\n  TransactionData,\n  TransactionDataV1,\n  TransactionExpiration,\n  TransactionKind,\n  TypeTag\n} from \"./bcs.js\";\nimport { TransactionEffects } from \"./effects.js\";\nimport { TypeTagSerializer } from \"./type-tag-serializer.js\";\nimport { BcsType } from \"@mysten/bcs\";\nconst suiBcs = {\n  ...bcs,\n  U8: bcs.u8(),\n  U16: bcs.u16(),\n  U32: bcs.u32(),\n  U64: bcs.u64(),\n  U128: bcs.u128(),\n  U256: bcs.u256(),\n  ULEB128: bcs.uleb128(),\n  Bool: bcs.bool(),\n  String: bcs.string(),\n  Address,\n  AppId,\n  Argument,\n  CallArg,\n  CompressedSignature,\n  GasData,\n  Intent,\n  IntentMessage,\n  IntentScope,\n  IntentVersion,\n  MultiSig,\n  MultiSigPkMap,\n  MultiSigPublicKey,\n  ObjectArg,\n  ObjectDigest,\n  ProgrammableMoveCall,\n  ProgrammableTransaction,\n  PublicKey,\n  SenderSignedData,\n  SenderSignedTransaction,\n  SharedObjectRef,\n  StructTag,\n  SuiObjectRef,\n  Command,\n  TransactionData,\n  TransactionDataV1,\n  TransactionExpiration,\n  TransactionKind,\n  TypeTag,\n  TransactionEffects,\n  PasskeyAuthenticator\n};\nimport {\n  pureBcsSchemaFromTypeName\n} from \"./pure.js\";\nexport {\n  BcsType,\n  TypeTagSerializer,\n  suiBcs as bcs,\n  pureBcsSchemaFromTypeName\n};\n//# sourceMappingURL=index.js.map\n","// src/actions/await/awaitAsync.ts\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async _run(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\\d]{2}(?:[A-Z\\d]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar HEXADECIMAL_REGEX = /^(?:0h|0x)?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-f]{3,4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    // @ts-expect-error\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? // @ts-expect-error\n  context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message) {\n    issue.message = typeof message === \"function\" ? message(issue) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * The error issues.\n   */\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/bic/bic.ts\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value > this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: requirement.map((option) => `\"${option}\"`).join(\" | \") || \"never\",\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value < this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    _run(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\nfunction _isPartiallyTyped(dataset, pathList) {\n  if (dataset.issues) {\n    for (const path of pathList) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (path[index] !== issue.path[index].key) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\nfunction partialCheck(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\nfunction partialCheckAsync(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async _run(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    _run(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async _run(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    _run(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async _run(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    _run(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async _run(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/config/config.ts\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    _run(dataset, config_) {\n      return schema._run(dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    _run(dataset, config2) {\n      schema._run(dataset, config2);\n      return dataset.issues ? { typed: true, value: getFallback(this, dataset, config2) } : dataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    async _run(dataset, config2) {\n      schema._run(dataset, config2);\n      return dataset.issues ? (\n        // @ts-expect-error\n        { typed: true, value: await getFallback(this, dataset, config2) }\n      ) : dataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\nfunction forward(action, pathKeys) {\n  return {\n    ...action,\n    _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\nfunction forwardAsync(action, pathKeys) {\n  return {\n    ...action,\n    async: true,\n    async _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      await action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input) {\n  return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item._run({ typed: false, value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item._run({ typed: false, value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    _run(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    async _run(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum__, message) {\n  const options = Object.entries(enum__).filter(([key]) => isNaN(+key)).map(([, value2]) => value2);\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: options.map(_stringify).join(\" | \") || \"never\",\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/file/file.ts\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema._run(\n            { typed: false, value: input },\n            config2\n          );\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map(\n            (schema) => schema._run({ typed: false, value: input }, config2)\n          )\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    _run(dataset, config2) {\n      return this.getter(dataset.value)._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    async _run(dataset, config2) {\n      return (await this.getter(dataset.value))._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key._run(\n            { typed: false, value: inputKey },\n            config2\n          );\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key._run({ typed: false, value: inputKey }, config2),\n              this.value._run({ typed: false, value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"!null & !undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"!null & !undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `${wrapped.expects} | null`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `${wrapped.expects} | null`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `${wrapped.expects} | null | undefined`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `${wrapped.expects} | null | undefined`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/number/number.ts\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const value2 = input[key];\n              const valueDataset = this.rest._run(\n                { typed: false, value: value2 },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal entry\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, schema]) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await schema._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other entries with rest schema\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest._run({ typed: false, value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueDataset] of normalDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `${wrapped.expects} | undefined`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `${wrapped.expects} | undefined`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: options.map(_stringify).join(\" | \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key._run(\n              { typed: false, value: entryKey },\n              config2\n            );\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value._run(\n              { typed: false, value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key._run({ typed: false, value: entryKey }, config2),\n              this.value._run({ typed: false, value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value._run(\n                { typed: false, value: inputValue },\n                config2\n              )\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest._run({ typed: false, value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/utils/_discriminators/_discriminators.ts\nfunction _discriminators(key, options, set2 = /* @__PURE__ */ new Set()) {\n  for (const schema of options) {\n    if (schema.type === \"variant\") {\n      _discriminators(key, schema.options, set2);\n    } else {\n      set2.add(schema.entries[key].expects);\n    }\n  }\n  return set2;\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            ).issues) {\n              const optionDataset = schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !(await schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            )).issues) {\n              const optionDataset = await schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pipe/pipe.ts\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    _run(dataset, config2) {\n      for (let index = 0; index < pipe2.length; index++) {\n        if (dataset.issues && (pipe2[index].kind === \"schema\" || pipe2[index].kind === \"transformation\")) {\n          dataset.typed = false;\n          break;\n        }\n        if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n          dataset = pipe2[index]._run(dataset, config2);\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    async _run(dataset, config2) {\n      for (let index = 0; index < pipe2.length; index++) {\n        if (dataset.issues && (pipe2[index].kind === \"schema\" || pipe2[index].kind === \"transformation\")) {\n          dataset.typed = false;\n          break;\n        }\n        if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n          dataset = await pipe2[index]._run(dataset, config2);\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  OCTAL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _stringify,\n  any,\n  array,\n  arrayAsync,\n  awaitAsync,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxLength,\n  maxSize,\n  maxValue,\n  mimeType,\n  minBytes,\n  minLength,\n  minSize,\n  minValue,\n  multipleOf,\n  nan,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notLength,\n  notSize,\n  notValue,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_\n};\n","import {\n  array,\n  boolean,\n  check,\n  integer,\n  lazy,\n  literal,\n  nullable,\n  nullish,\n  number,\n  object,\n  optional,\n  pipe,\n  record,\n  string,\n  transform,\n  tuple,\n  union,\n  unknown\n} from \"valibot\";\nimport { isValidSuiAddress, normalizeSuiAddress } from \"../../utils/sui-types.js\";\nfunction safeEnum(options) {\n  const unionOptions = Object.entries(options).map(([key, value]) => object({ [key]: value }));\n  return pipe(\n    union(unionOptions),\n    transform((value) => ({\n      ...value,\n      $kind: Object.keys(value)[0]\n    }))\n  );\n}\nconst SuiAddress = pipe(\n  string(),\n  transform((value) => normalizeSuiAddress(value)),\n  check(isValidSuiAddress)\n);\nconst ObjectID = SuiAddress;\nconst BCSBytes = string();\nconst JsonU64 = pipe(\n  union([string(), pipe(number(), integer())]),\n  check((val) => {\n    try {\n      BigInt(val);\n      return BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;\n    } catch {\n      return false;\n    }\n  }, \"Invalid u64\")\n);\nconst ObjectRef = object({\n  objectId: SuiAddress,\n  version: JsonU64,\n  digest: string()\n});\nconst Argument = pipe(\n  union([\n    object({ GasCoin: literal(true) }),\n    object({ Input: pipe(number(), integer()), type: optional(literal(\"pure\")) }),\n    object({ Input: pipe(number(), integer()), type: optional(literal(\"object\")) }),\n    object({ Result: pipe(number(), integer()) }),\n    object({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) })\n  ]),\n  transform((value) => ({\n    ...value,\n    $kind: Object.keys(value)[0]\n  }))\n  // Defined manually to add `type?: 'pure' | 'object'` to Input\n);\nconst GasData = object({\n  budget: nullable(JsonU64),\n  price: nullable(JsonU64),\n  owner: nullable(SuiAddress),\n  payment: nullable(array(ObjectRef))\n});\nconst StructTag = object({\n  address: string(),\n  module: string(),\n  name: string(),\n  // type_params in rust, should be updated to use camelCase\n  typeParams: array(string())\n});\nconst OpenMoveTypeSignatureBody = union([\n  literal(\"address\"),\n  literal(\"bool\"),\n  literal(\"u8\"),\n  literal(\"u16\"),\n  literal(\"u32\"),\n  literal(\"u64\"),\n  literal(\"u128\"),\n  literal(\"u256\"),\n  object({ vector: lazy(() => OpenMoveTypeSignatureBody) }),\n  object({\n    datatype: object({\n      package: string(),\n      module: string(),\n      type: string(),\n      typeParameters: array(lazy(() => OpenMoveTypeSignatureBody))\n    })\n  }),\n  object({ typeParameter: pipe(number(), integer()) })\n]);\nconst OpenMoveTypeSignature = object({\n  ref: nullable(union([literal(\"&\"), literal(\"&mut\")])),\n  body: OpenMoveTypeSignatureBody\n});\nconst ProgrammableMoveCall = object({\n  package: ObjectID,\n  module: string(),\n  function: string(),\n  // snake case in rust\n  typeArguments: array(string()),\n  arguments: array(Argument),\n  _argumentTypes: optional(nullable(array(OpenMoveTypeSignature)))\n});\nconst $Intent = object({\n  name: string(),\n  inputs: record(string(), union([Argument, array(Argument)])),\n  data: record(string(), unknown())\n});\nconst Command = safeEnum({\n  MoveCall: ProgrammableMoveCall,\n  TransferObjects: object({\n    objects: array(Argument),\n    address: Argument\n  }),\n  SplitCoins: object({\n    coin: Argument,\n    amounts: array(Argument)\n  }),\n  MergeCoins: object({\n    destination: Argument,\n    sources: array(Argument)\n  }),\n  Publish: object({\n    modules: array(BCSBytes),\n    dependencies: array(ObjectID)\n  }),\n  MakeMoveVec: object({\n    type: nullable(string()),\n    elements: array(Argument)\n  }),\n  Upgrade: object({\n    modules: array(BCSBytes),\n    dependencies: array(ObjectID),\n    package: ObjectID,\n    ticket: Argument\n  }),\n  $Intent\n});\nconst ObjectArg = safeEnum({\n  ImmOrOwnedObject: ObjectRef,\n  SharedObject: object({\n    objectId: ObjectID,\n    // snake case in rust\n    initialSharedVersion: JsonU64,\n    mutable: boolean()\n  }),\n  Receiving: ObjectRef\n});\nconst CallArg = safeEnum({\n  Object: ObjectArg,\n  Pure: object({\n    bytes: BCSBytes\n  }),\n  UnresolvedPure: object({\n    value: unknown()\n  }),\n  UnresolvedObject: object({\n    objectId: ObjectID,\n    version: optional(nullable(JsonU64)),\n    digest: optional(nullable(string())),\n    initialSharedVersion: optional(nullable(JsonU64))\n  })\n});\nconst NormalizedCallArg = safeEnum({\n  Object: ObjectArg,\n  Pure: object({\n    bytes: BCSBytes\n  })\n});\nconst TransactionExpiration = safeEnum({\n  None: literal(true),\n  Epoch: JsonU64\n});\nconst TransactionData = object({\n  version: literal(2),\n  sender: nullish(SuiAddress),\n  expiration: nullish(TransactionExpiration),\n  gasData: GasData,\n  inputs: array(CallArg),\n  commands: array(Command)\n});\nexport {\n  $Intent,\n  Argument,\n  BCSBytes,\n  Command,\n  GasData,\n  JsonU64,\n  NormalizedCallArg,\n  ObjectArg,\n  ObjectID,\n  ObjectRef,\n  OpenMoveTypeSignature,\n  OpenMoveTypeSignatureBody,\n  StructTag,\n  SuiAddress,\n  TransactionData,\n  TransactionExpiration,\n  safeEnum\n};\n//# sourceMappingURL=internal.js.map\n","import { toBase64 } from \"@mysten/bcs\";\nimport { parse } from \"valibot\";\nimport { normalizeSuiObjectId } from \"../utils/sui-types.js\";\nimport { Argument } from \"./data/internal.js\";\nvar UpgradePolicy = /* @__PURE__ */ ((UpgradePolicy2) => {\n  UpgradePolicy2[UpgradePolicy2[\"COMPATIBLE\"] = 0] = \"COMPATIBLE\";\n  UpgradePolicy2[UpgradePolicy2[\"ADDITIVE\"] = 128] = \"ADDITIVE\";\n  UpgradePolicy2[UpgradePolicy2[\"DEP_ONLY\"] = 192] = \"DEP_ONLY\";\n  return UpgradePolicy2;\n})(UpgradePolicy || {});\nconst Commands = {\n  MoveCall(input) {\n    const [pkg, mod = \"\", fn = \"\"] = \"target\" in input ? input.target.split(\"::\") : [input.package, input.module, input.function];\n    return {\n      $kind: \"MoveCall\",\n      MoveCall: {\n        package: pkg,\n        module: mod,\n        function: fn,\n        typeArguments: input.typeArguments ?? [],\n        arguments: input.arguments ?? []\n      }\n    };\n  },\n  TransferObjects(objects, address) {\n    return {\n      $kind: \"TransferObjects\",\n      TransferObjects: {\n        objects: objects.map((o) => parse(Argument, o)),\n        address: parse(Argument, address)\n      }\n    };\n  },\n  SplitCoins(coin, amounts) {\n    return {\n      $kind: \"SplitCoins\",\n      SplitCoins: {\n        coin: parse(Argument, coin),\n        amounts: amounts.map((o) => parse(Argument, o))\n      }\n    };\n  },\n  MergeCoins(destination, sources) {\n    return {\n      $kind: \"MergeCoins\",\n      MergeCoins: {\n        destination: parse(Argument, destination),\n        sources: sources.map((o) => parse(Argument, o))\n      }\n    };\n  },\n  Publish({\n    modules,\n    dependencies\n  }) {\n    return {\n      $kind: \"Publish\",\n      Publish: {\n        modules: modules.map(\n          (module) => typeof module === \"string\" ? module : toBase64(new Uint8Array(module))\n        ),\n        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep))\n      }\n    };\n  },\n  Upgrade({\n    modules,\n    dependencies,\n    package: packageId,\n    ticket\n  }) {\n    return {\n      $kind: \"Upgrade\",\n      Upgrade: {\n        modules: modules.map(\n          (module) => typeof module === \"string\" ? module : toBase64(new Uint8Array(module))\n        ),\n        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n        package: packageId,\n        ticket: parse(Argument, ticket)\n      }\n    };\n  },\n  MakeMoveVec({\n    type,\n    elements\n  }) {\n    return {\n      $kind: \"MakeMoveVec\",\n      MakeMoveVec: {\n        type: type ?? null,\n        elements: elements.map((o) => parse(Argument, o))\n      }\n    };\n  },\n  Intent({\n    name,\n    inputs = {},\n    data = {}\n  }) {\n    return {\n      $kind: \"$Intent\",\n      $Intent: {\n        name,\n        inputs: Object.fromEntries(\n          Object.entries(inputs).map(([key, value]) => [\n            key,\n            Array.isArray(value) ? value.map((o) => parse(Argument, o)) : parse(Argument, value)\n          ])\n        ),\n        data\n      }\n    };\n  }\n};\nexport {\n  Commands,\n  UpgradePolicy\n};\n//# sourceMappingURL=Commands.js.map\n","import { fromBase64, toBase64 } from \"@mysten/bcs\";\nimport {\n  array,\n  bigint,\n  boolean,\n  check,\n  integer,\n  is,\n  lazy,\n  literal,\n  nullable,\n  nullish,\n  number,\n  object,\n  optional,\n  parse,\n  pipe,\n  string,\n  union,\n  unknown\n} from \"valibot\";\nimport { TypeTagSerializer } from \"../../bcs/index.js\";\nimport { JsonU64, ObjectID, safeEnum, TransactionData } from \"./internal.js\";\nconst ObjectRef = object({\n  digest: string(),\n  objectId: string(),\n  version: union([pipe(number(), integer()), string(), bigint()])\n});\nconst ObjectArg = safeEnum({\n  ImmOrOwned: ObjectRef,\n  Shared: object({\n    objectId: ObjectID,\n    initialSharedVersion: JsonU64,\n    mutable: boolean()\n  }),\n  Receiving: ObjectRef\n});\nconst NormalizedCallArg = safeEnum({\n  Object: ObjectArg,\n  Pure: array(pipe(number(), integer()))\n});\nconst TransactionInput = union([\n  object({\n    kind: literal(\"Input\"),\n    index: pipe(number(), integer()),\n    value: unknown(),\n    type: optional(literal(\"object\"))\n  }),\n  object({\n    kind: literal(\"Input\"),\n    index: pipe(number(), integer()),\n    value: unknown(),\n    type: literal(\"pure\")\n  })\n]);\nconst TransactionExpiration = union([\n  object({ Epoch: pipe(number(), integer()) }),\n  object({ None: nullable(literal(true)) })\n]);\nconst StringEncodedBigint = pipe(\n  union([number(), string(), bigint()]),\n  check((val) => {\n    if (![\"string\", \"number\", \"bigint\"].includes(typeof val)) return false;\n    try {\n      BigInt(val);\n      return true;\n    } catch {\n      return false;\n    }\n  })\n);\nconst TypeTag = union([\n  object({ bool: nullable(literal(true)) }),\n  object({ u8: nullable(literal(true)) }),\n  object({ u64: nullable(literal(true)) }),\n  object({ u128: nullable(literal(true)) }),\n  object({ address: nullable(literal(true)) }),\n  object({ signer: nullable(literal(true)) }),\n  object({ vector: lazy(() => TypeTag) }),\n  object({ struct: lazy(() => StructTag) }),\n  object({ u16: nullable(literal(true)) }),\n  object({ u32: nullable(literal(true)) }),\n  object({ u256: nullable(literal(true)) })\n]);\nconst StructTag = object({\n  address: string(),\n  module: string(),\n  name: string(),\n  typeParams: array(TypeTag)\n});\nconst GasConfig = object({\n  budget: optional(StringEncodedBigint),\n  price: optional(StringEncodedBigint),\n  payment: optional(array(ObjectRef)),\n  owner: optional(string())\n});\nconst TransactionArgumentTypes = [\n  TransactionInput,\n  object({ kind: literal(\"GasCoin\") }),\n  object({ kind: literal(\"Result\"), index: pipe(number(), integer()) }),\n  object({\n    kind: literal(\"NestedResult\"),\n    index: pipe(number(), integer()),\n    resultIndex: pipe(number(), integer())\n  })\n];\nconst TransactionArgument = union([...TransactionArgumentTypes]);\nconst MoveCallTransaction = object({\n  kind: literal(\"MoveCall\"),\n  target: pipe(\n    string(),\n    check((target) => target.split(\"::\").length === 3)\n  ),\n  typeArguments: array(string()),\n  arguments: array(TransactionArgument)\n});\nconst TransferObjectsTransaction = object({\n  kind: literal(\"TransferObjects\"),\n  objects: array(TransactionArgument),\n  address: TransactionArgument\n});\nconst SplitCoinsTransaction = object({\n  kind: literal(\"SplitCoins\"),\n  coin: TransactionArgument,\n  amounts: array(TransactionArgument)\n});\nconst MergeCoinsTransaction = object({\n  kind: literal(\"MergeCoins\"),\n  destination: TransactionArgument,\n  sources: array(TransactionArgument)\n});\nconst MakeMoveVecTransaction = object({\n  kind: literal(\"MakeMoveVec\"),\n  type: union([object({ Some: TypeTag }), object({ None: nullable(literal(true)) })]),\n  objects: array(TransactionArgument)\n});\nconst PublishTransaction = object({\n  kind: literal(\"Publish\"),\n  modules: array(array(pipe(number(), integer()))),\n  dependencies: array(string())\n});\nconst UpgradeTransaction = object({\n  kind: literal(\"Upgrade\"),\n  modules: array(array(pipe(number(), integer()))),\n  dependencies: array(string()),\n  packageId: string(),\n  ticket: TransactionArgument\n});\nconst TransactionTypes = [\n  MoveCallTransaction,\n  TransferObjectsTransaction,\n  SplitCoinsTransaction,\n  MergeCoinsTransaction,\n  PublishTransaction,\n  UpgradeTransaction,\n  MakeMoveVecTransaction\n];\nconst TransactionType = union([...TransactionTypes]);\nconst SerializedTransactionDataV1 = object({\n  version: literal(1),\n  sender: optional(string()),\n  expiration: nullish(TransactionExpiration),\n  gasConfig: GasConfig,\n  inputs: array(TransactionInput),\n  transactions: array(TransactionType)\n});\nfunction serializeV1TransactionData(transactionData) {\n  const inputs = transactionData.inputs.map(\n    (input, index) => {\n      if (input.Object) {\n        return {\n          kind: \"Input\",\n          index,\n          value: {\n            Object: input.Object.ImmOrOwnedObject ? {\n              ImmOrOwned: input.Object.ImmOrOwnedObject\n            } : input.Object.Receiving ? {\n              Receiving: {\n                digest: input.Object.Receiving.digest,\n                version: input.Object.Receiving.version,\n                objectId: input.Object.Receiving.objectId\n              }\n            } : {\n              Shared: {\n                mutable: input.Object.SharedObject.mutable,\n                initialSharedVersion: input.Object.SharedObject.initialSharedVersion,\n                objectId: input.Object.SharedObject.objectId\n              }\n            }\n          },\n          type: \"object\"\n        };\n      }\n      if (input.Pure) {\n        return {\n          kind: \"Input\",\n          index,\n          value: {\n            Pure: Array.from(fromBase64(input.Pure.bytes))\n          },\n          type: \"pure\"\n        };\n      }\n      if (input.UnresolvedPure) {\n        return {\n          kind: \"Input\",\n          type: \"pure\",\n          index,\n          value: input.UnresolvedPure.value\n        };\n      }\n      if (input.UnresolvedObject) {\n        return {\n          kind: \"Input\",\n          type: \"object\",\n          index,\n          value: input.UnresolvedObject.objectId\n        };\n      }\n      throw new Error(\"Invalid input\");\n    }\n  );\n  return {\n    version: 1,\n    sender: transactionData.sender ?? void 0,\n    expiration: transactionData.expiration?.$kind === \"Epoch\" ? { Epoch: Number(transactionData.expiration.Epoch) } : transactionData.expiration ? { None: true } : null,\n    gasConfig: {\n      owner: transactionData.gasData.owner ?? void 0,\n      budget: transactionData.gasData.budget ?? void 0,\n      price: transactionData.gasData.price ?? void 0,\n      payment: transactionData.gasData.payment ?? void 0\n    },\n    inputs,\n    transactions: transactionData.commands.map((command) => {\n      if (command.MakeMoveVec) {\n        return {\n          kind: \"MakeMoveVec\",\n          type: command.MakeMoveVec.type === null ? { None: true } : { Some: TypeTagSerializer.parseFromStr(command.MakeMoveVec.type) },\n          objects: command.MakeMoveVec.elements.map(\n            (arg) => convertTransactionArgument(arg, inputs)\n          )\n        };\n      }\n      if (command.MergeCoins) {\n        return {\n          kind: \"MergeCoins\",\n          destination: convertTransactionArgument(command.MergeCoins.destination, inputs),\n          sources: command.MergeCoins.sources.map((arg) => convertTransactionArgument(arg, inputs))\n        };\n      }\n      if (command.MoveCall) {\n        return {\n          kind: \"MoveCall\",\n          target: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,\n          typeArguments: command.MoveCall.typeArguments,\n          arguments: command.MoveCall.arguments.map(\n            (arg) => convertTransactionArgument(arg, inputs)\n          )\n        };\n      }\n      if (command.Publish) {\n        return {\n          kind: \"Publish\",\n          modules: command.Publish.modules.map((mod) => Array.from(fromBase64(mod))),\n          dependencies: command.Publish.dependencies\n        };\n      }\n      if (command.SplitCoins) {\n        return {\n          kind: \"SplitCoins\",\n          coin: convertTransactionArgument(command.SplitCoins.coin, inputs),\n          amounts: command.SplitCoins.amounts.map((arg) => convertTransactionArgument(arg, inputs))\n        };\n      }\n      if (command.TransferObjects) {\n        return {\n          kind: \"TransferObjects\",\n          objects: command.TransferObjects.objects.map(\n            (arg) => convertTransactionArgument(arg, inputs)\n          ),\n          address: convertTransactionArgument(command.TransferObjects.address, inputs)\n        };\n      }\n      if (command.Upgrade) {\n        return {\n          kind: \"Upgrade\",\n          modules: command.Upgrade.modules.map((mod) => Array.from(fromBase64(mod))),\n          dependencies: command.Upgrade.dependencies,\n          packageId: command.Upgrade.package,\n          ticket: convertTransactionArgument(command.Upgrade.ticket, inputs)\n        };\n      }\n      throw new Error(`Unknown transaction ${Object.keys(command)}`);\n    })\n  };\n}\nfunction convertTransactionArgument(arg, inputs) {\n  if (arg.$kind === \"GasCoin\") {\n    return { kind: \"GasCoin\" };\n  }\n  if (arg.$kind === \"Result\") {\n    return { kind: \"Result\", index: arg.Result };\n  }\n  if (arg.$kind === \"NestedResult\") {\n    return { kind: \"NestedResult\", index: arg.NestedResult[0], resultIndex: arg.NestedResult[1] };\n  }\n  if (arg.$kind === \"Input\") {\n    return inputs[arg.Input];\n  }\n  throw new Error(`Invalid argument ${Object.keys(arg)}`);\n}\nfunction transactionDataFromV1(data) {\n  return parse(TransactionData, {\n    version: 2,\n    sender: data.sender ?? null,\n    expiration: data.expiration ? \"Epoch\" in data.expiration ? { Epoch: data.expiration.Epoch } : { None: true } : null,\n    gasData: {\n      owner: data.gasConfig.owner ?? null,\n      budget: data.gasConfig.budget?.toString() ?? null,\n      price: data.gasConfig.price?.toString() ?? null,\n      payment: data.gasConfig.payment?.map((ref) => ({\n        digest: ref.digest,\n        objectId: ref.objectId,\n        version: ref.version.toString()\n      })) ?? null\n    },\n    inputs: data.inputs.map((input) => {\n      if (input.kind === \"Input\") {\n        if (is(NormalizedCallArg, input.value)) {\n          const value = parse(NormalizedCallArg, input.value);\n          if (value.Object) {\n            if (value.Object.ImmOrOwned) {\n              return {\n                Object: {\n                  ImmOrOwnedObject: {\n                    objectId: value.Object.ImmOrOwned.objectId,\n                    version: String(value.Object.ImmOrOwned.version),\n                    digest: value.Object.ImmOrOwned.digest\n                  }\n                }\n              };\n            }\n            if (value.Object.Shared) {\n              return {\n                Object: {\n                  SharedObject: {\n                    mutable: value.Object.Shared.mutable ?? null,\n                    initialSharedVersion: value.Object.Shared.initialSharedVersion,\n                    objectId: value.Object.Shared.objectId\n                  }\n                }\n              };\n            }\n            if (value.Object.Receiving) {\n              return {\n                Object: {\n                  Receiving: {\n                    digest: value.Object.Receiving.digest,\n                    version: String(value.Object.Receiving.version),\n                    objectId: value.Object.Receiving.objectId\n                  }\n                }\n              };\n            }\n            throw new Error(\"Invalid object input\");\n          }\n          return {\n            Pure: {\n              bytes: toBase64(new Uint8Array(value.Pure))\n            }\n          };\n        }\n        if (input.type === \"object\") {\n          return {\n            UnresolvedObject: {\n              objectId: input.value\n            }\n          };\n        }\n        return {\n          UnresolvedPure: {\n            value: input.value\n          }\n        };\n      }\n      throw new Error(\"Invalid input\");\n    }),\n    commands: data.transactions.map((transaction) => {\n      switch (transaction.kind) {\n        case \"MakeMoveVec\":\n          return {\n            MakeMoveVec: {\n              type: \"Some\" in transaction.type ? TypeTagSerializer.tagToString(transaction.type.Some) : null,\n              elements: transaction.objects.map((arg) => parseV1TransactionArgument(arg))\n            }\n          };\n        case \"MergeCoins\": {\n          return {\n            MergeCoins: {\n              destination: parseV1TransactionArgument(transaction.destination),\n              sources: transaction.sources.map((arg) => parseV1TransactionArgument(arg))\n            }\n          };\n        }\n        case \"MoveCall\": {\n          const [pkg, mod, fn] = transaction.target.split(\"::\");\n          return {\n            MoveCall: {\n              package: pkg,\n              module: mod,\n              function: fn,\n              typeArguments: transaction.typeArguments,\n              arguments: transaction.arguments.map((arg) => parseV1TransactionArgument(arg))\n            }\n          };\n        }\n        case \"Publish\": {\n          return {\n            Publish: {\n              modules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n              dependencies: transaction.dependencies\n            }\n          };\n        }\n        case \"SplitCoins\": {\n          return {\n            SplitCoins: {\n              coin: parseV1TransactionArgument(transaction.coin),\n              amounts: transaction.amounts.map((arg) => parseV1TransactionArgument(arg))\n            }\n          };\n        }\n        case \"TransferObjects\": {\n          return {\n            TransferObjects: {\n              objects: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),\n              address: parseV1TransactionArgument(transaction.address)\n            }\n          };\n        }\n        case \"Upgrade\": {\n          return {\n            Upgrade: {\n              modules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n              dependencies: transaction.dependencies,\n              package: transaction.packageId,\n              ticket: parseV1TransactionArgument(transaction.ticket)\n            }\n          };\n        }\n      }\n      throw new Error(`Unknown transaction ${Object.keys(transaction)}`);\n    })\n  });\n}\nfunction parseV1TransactionArgument(arg) {\n  switch (arg.kind) {\n    case \"GasCoin\": {\n      return { GasCoin: true };\n    }\n    case \"Result\":\n      return { Result: arg.index };\n    case \"NestedResult\": {\n      return { NestedResult: [arg.index, arg.resultIndex] };\n    }\n    case \"Input\": {\n      return { Input: arg.index };\n    }\n  }\n}\nexport {\n  NormalizedCallArg,\n  ObjectRef,\n  SerializedTransactionDataV1,\n  StructTag,\n  TransactionArgument,\n  TypeTag,\n  serializeV1TransactionData,\n  transactionDataFromV1\n};\n//# sourceMappingURL=v1.js.map\n","import {\n  array,\n  boolean,\n  integer,\n  literal,\n  nullable,\n  nullish,\n  number,\n  object,\n  optional,\n  pipe,\n  record,\n  string,\n  tuple,\n  union,\n  unknown\n} from \"valibot\";\nimport { BCSBytes, JsonU64, ObjectID, ObjectRef, SuiAddress } from \"./internal.js\";\nfunction enumUnion(options) {\n  return union(\n    Object.entries(options).map(([key, value]) => object({ [key]: value }))\n  );\n}\nconst Argument = enumUnion({\n  GasCoin: literal(true),\n  Input: pipe(number(), integer()),\n  Result: pipe(number(), integer()),\n  NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())])\n});\nconst GasData = object({\n  budget: nullable(JsonU64),\n  price: nullable(JsonU64),\n  owner: nullable(SuiAddress),\n  payment: nullable(array(ObjectRef))\n});\nconst ProgrammableMoveCall = object({\n  package: ObjectID,\n  module: string(),\n  function: string(),\n  // snake case in rust\n  typeArguments: array(string()),\n  arguments: array(Argument)\n});\nconst $Intent = object({\n  name: string(),\n  inputs: record(string(), union([Argument, array(Argument)])),\n  data: record(string(), unknown())\n});\nconst Command = enumUnion({\n  MoveCall: ProgrammableMoveCall,\n  TransferObjects: object({\n    objects: array(Argument),\n    address: Argument\n  }),\n  SplitCoins: object({\n    coin: Argument,\n    amounts: array(Argument)\n  }),\n  MergeCoins: object({\n    destination: Argument,\n    sources: array(Argument)\n  }),\n  Publish: object({\n    modules: array(BCSBytes),\n    dependencies: array(ObjectID)\n  }),\n  MakeMoveVec: object({\n    type: nullable(string()),\n    elements: array(Argument)\n  }),\n  Upgrade: object({\n    modules: array(BCSBytes),\n    dependencies: array(ObjectID),\n    package: ObjectID,\n    ticket: Argument\n  }),\n  $Intent\n});\nconst ObjectArg = enumUnion({\n  ImmOrOwnedObject: ObjectRef,\n  SharedObject: object({\n    objectId: ObjectID,\n    // snake case in rust\n    initialSharedVersion: JsonU64,\n    mutable: boolean()\n  }),\n  Receiving: ObjectRef\n});\nconst CallArg = enumUnion({\n  Object: ObjectArg,\n  Pure: object({\n    bytes: BCSBytes\n  }),\n  UnresolvedPure: object({\n    value: unknown()\n  }),\n  UnresolvedObject: object({\n    objectId: ObjectID,\n    version: optional(nullable(JsonU64)),\n    digest: optional(nullable(string())),\n    initialSharedVersion: optional(nullable(JsonU64))\n  })\n});\nconst TransactionExpiration = enumUnion({\n  None: literal(true),\n  Epoch: JsonU64\n});\nconst SerializedTransactionDataV2 = object({\n  version: literal(2),\n  sender: nullish(SuiAddress),\n  expiration: nullish(TransactionExpiration),\n  gasData: GasData,\n  inputs: array(CallArg),\n  commands: array(Command)\n});\nexport {\n  SerializedTransactionDataV2\n};\n//# sourceMappingURL=v2.js.map\n","import { toBase64 } from \"@mysten/bcs\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nfunction Pure(data) {\n  return {\n    $kind: \"Pure\",\n    Pure: {\n      bytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64()\n    }\n  };\n}\nconst Inputs = {\n  Pure,\n  ObjectRef({ objectId, digest, version }) {\n    return {\n      $kind: \"Object\",\n      Object: {\n        $kind: \"ImmOrOwnedObject\",\n        ImmOrOwnedObject: {\n          digest,\n          version,\n          objectId: normalizeSuiAddress(objectId)\n        }\n      }\n    };\n  },\n  SharedObjectRef({\n    objectId,\n    mutable,\n    initialSharedVersion\n  }) {\n    return {\n      $kind: \"Object\",\n      Object: {\n        $kind: \"SharedObject\",\n        SharedObject: {\n          mutable,\n          initialSharedVersion,\n          objectId: normalizeSuiAddress(objectId)\n        }\n      }\n    };\n  },\n  ReceivingRef({ objectId, digest, version }) {\n    return {\n      $kind: \"Object\",\n      Object: {\n        $kind: \"Receiving\",\n        Receiving: {\n          digest,\n          version,\n          objectId: normalizeSuiAddress(objectId)\n        }\n      }\n    };\n  }\n};\nexport {\n  Inputs\n};\n//# sourceMappingURL=Inputs.js.map\n","import { normalizeSuiObjectId } from \"./sui-types.js\";\nconst SUI_DECIMALS = 9;\nconst MIST_PER_SUI = BigInt(1e9);\nconst MOVE_STDLIB_ADDRESS = \"0x1\";\nconst SUI_FRAMEWORK_ADDRESS = \"0x2\";\nconst SUI_SYSTEM_ADDRESS = \"0x3\";\nconst SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId(\"0x6\");\nconst SUI_SYSTEM_MODULE_NAME = \"sui_system\";\nconst SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;\nconst SUI_SYSTEM_STATE_OBJECT_ID = normalizeSuiObjectId(\"0x5\");\nexport {\n  MIST_PER_SUI,\n  MOVE_STDLIB_ADDRESS,\n  SUI_CLOCK_OBJECT_ID,\n  SUI_DECIMALS,\n  SUI_FRAMEWORK_ADDRESS,\n  SUI_SYSTEM_ADDRESS,\n  SUI_SYSTEM_MODULE_NAME,\n  SUI_SYSTEM_STATE_OBJECT_ID,\n  SUI_TYPE_ARG\n};\n//# sourceMappingURL=constants.js.map\n","/**\n * Internal assertion helpers.\n * @module\n */\n/** Asserts something is positive integer. */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Is number an Uint8Array? Copied from utils for perf. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\nexport { anumber, abytes, ahash, aexists, aoutput };\n//# sourceMappingURL=_assert.js.map","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n// Cast array to different type\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n// Cast array to view\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const byteSwapIfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Convert JS string to byte array.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('utf8ToBytes expected string, got ' + typeof str);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n/** For runtime check if class implements interface */\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** Wraps hash function, creating an interface on top of it */\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","/**\n * Internal helpers for blake hash.\n * @module\n */\nimport { aexists, anumber, aoutput } from './_assert.js';\nimport { byteSwap32, byteSwapIfBE, Hash, isLE, toBytes, u32 } from './utils.js';\n/**\n * Internal blake variable.\n * For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n */\n// prettier-ignore\nexport const SIGMA = /* @__PURE__ */ new Uint8Array([\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n    11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n    7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n    9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n    2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n    12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n    13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n    6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n    10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n    14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n    // Blake1, unused in others\n    11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n    7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n    9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n    2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n]);\n/** Class, from which others are subclassed. */\nexport class BLAKE extends Hash {\n    constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.length = 0;\n        this.pos = 0;\n        this.finished = false;\n        this.destroyed = false;\n        anumber(blockLen);\n        anumber(outputLen);\n        anumber(keyLen);\n        if (outputLen < 0 || outputLen > keyLen)\n            throw new Error('outputLen bigger than keyLen');\n        if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen))\n            throw new Error('key length must be undefined or 1..' + keyLen);\n        if (opts.salt !== undefined && opts.salt.length !== saltLen)\n            throw new Error('salt must be undefined or ' + saltLen);\n        if (opts.personalization !== undefined && opts.personalization.length !== persLen)\n            throw new Error('personalization must be undefined or ' + persLen);\n        this.buffer = new Uint8Array(blockLen);\n        this.buffer32 = u32(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        // Main difference with other hashes: there is flag for last block,\n        // so we cannot process current block before we know that there\n        // is the next one. This significantly complicates logic and reduces ability\n        // to do zero-copy processing\n        const { blockLen, buffer, buffer32 } = this;\n        data = toBytes(data);\n        const len = data.length;\n        const offset = data.byteOffset;\n        const buf = data.buffer;\n        for (let pos = 0; pos < len;) {\n            // If buffer is full and we still have input (don't process last block, same as blake2s)\n            if (this.pos === blockLen) {\n                if (!isLE)\n                    byteSwap32(buffer32);\n                this.compress(buffer32, 0, false);\n                if (!isLE)\n                    byteSwap32(buffer32);\n                this.pos = 0;\n            }\n            const take = Math.min(blockLen - this.pos, len - pos);\n            const dataOffset = offset + pos;\n            // full block && aligned to 4 bytes && not last in input\n            if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n                const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n                if (!isLE)\n                    byteSwap32(data32);\n                for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n                    this.length += blockLen;\n                    this.compress(data32, pos32, false);\n                }\n                if (!isLE)\n                    byteSwap32(data32);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            this.length += take;\n            pos += take;\n        }\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        const { pos, buffer32 } = this;\n        this.finished = true;\n        // Padding\n        this.buffer.subarray(pos).fill(0);\n        if (!isLE)\n            byteSwap32(buffer32);\n        this.compress(buffer32, 0, true);\n        if (!isLE)\n            byteSwap32(buffer32);\n        const out32 = u32(out);\n        this.get().forEach((v, i) => (out32[i] = byteSwapIfBE(v)));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        const { buffer, length, finished, destroyed, outputLen, pos } = this;\n        to || (to = new this.constructor({ dkLen: outputLen }));\n        to.set(...this.get());\n        to.length = length;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.outputLen = outputLen;\n        to.buffer.set(buffer);\n        to.pos = pos;\n        return to;\n    }\n}\n//# sourceMappingURL=_blake.js.map","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","/**\n * Blake2b hash function. Focuses on 64-bit platforms, but in JS speed different from Blake2s is negligible.\n * @module\n */\nimport { BLAKE, SIGMA } from './_blake.js';\nimport u64 from './_u64.js';\nimport { byteSwapIfBE, toBytes, u32, wrapConstructorWithOpts } from './utils.js';\n// Same as SHA-512 but LE\n// prettier-ignore\nconst B2B_IV = /* @__PURE__ */ new Uint32Array([\n    0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a,\n    0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19\n]);\n// Temporary buffer\nconst BBUF = /* @__PURE__ */ new Uint32Array(32);\n// Mixing function G splitted in two halfs\nfunction G1b(a, b, c, d, msg, x) {\n    // NOTE: V is LE here\n    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = u64.add3L(Al, Bl, Xl);\n    Ah = u64.add3H(ll, Ah, Bh, Xh);\n    Al = ll | 0;\n    // v[d] = rotr(v[d] ^ v[a], 32)\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: u64.rotr32H(Dh, Dl), Dl: u64.rotr32L(Dh, Dl) });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 24)\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: u64.rotrSH(Bh, Bl, 24), Bl: u64.rotrSL(Bh, Bl, 24) });\n    (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n    (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n    (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n    (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\nfunction G2b(a, b, c, d, msg, x) {\n    // NOTE: V is LE here\n    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = u64.add3L(Al, Bl, Xl);\n    Ah = u64.add3H(ll, Ah, Bh, Xh);\n    Al = ll | 0;\n    // v[d] = rotr(v[d] ^ v[a], 16)\n    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n    ({ Dh, Dl } = { Dh: u64.rotrSH(Dh, Dl, 16), Dl: u64.rotrSL(Dh, Dl, 16) });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = u64.add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 63)\n    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n    ({ Bh, Bl } = { Bh: u64.rotrBH(Bh, Bl, 63), Bl: u64.rotrBL(Bh, Bl, 63) });\n    (BBUF[2 * a] = Al), (BBUF[2 * a + 1] = Ah);\n    (BBUF[2 * b] = Bl), (BBUF[2 * b + 1] = Bh);\n    (BBUF[2 * c] = Cl), (BBUF[2 * c + 1] = Ch);\n    (BBUF[2 * d] = Dl), (BBUF[2 * d + 1] = Dh);\n}\nexport class BLAKE2b extends BLAKE {\n    constructor(opts = {}) {\n        super(128, opts.dkLen === undefined ? 64 : opts.dkLen, opts, 64, 16, 16);\n        // Same as SHA-512, but LE\n        this.v0l = B2B_IV[0] | 0;\n        this.v0h = B2B_IV[1] | 0;\n        this.v1l = B2B_IV[2] | 0;\n        this.v1h = B2B_IV[3] | 0;\n        this.v2l = B2B_IV[4] | 0;\n        this.v2h = B2B_IV[5] | 0;\n        this.v3l = B2B_IV[6] | 0;\n        this.v3h = B2B_IV[7] | 0;\n        this.v4l = B2B_IV[8] | 0;\n        this.v4h = B2B_IV[9] | 0;\n        this.v5l = B2B_IV[10] | 0;\n        this.v5h = B2B_IV[11] | 0;\n        this.v6l = B2B_IV[12] | 0;\n        this.v6h = B2B_IV[13] | 0;\n        this.v7l = B2B_IV[14] | 0;\n        this.v7h = B2B_IV[15] | 0;\n        const keyLength = opts.key ? opts.key.length : 0;\n        this.v0l ^= this.outputLen | (keyLength << 8) | (0x01 << 16) | (0x01 << 24);\n        if (opts.salt) {\n            const salt = u32(toBytes(opts.salt));\n            this.v4l ^= byteSwapIfBE(salt[0]);\n            this.v4h ^= byteSwapIfBE(salt[1]);\n            this.v5l ^= byteSwapIfBE(salt[2]);\n            this.v5h ^= byteSwapIfBE(salt[3]);\n        }\n        if (opts.personalization) {\n            const pers = u32(toBytes(opts.personalization));\n            this.v6l ^= byteSwapIfBE(pers[0]);\n            this.v6h ^= byteSwapIfBE(pers[1]);\n            this.v7l ^= byteSwapIfBE(pers[2]);\n            this.v7h ^= byteSwapIfBE(pers[3]);\n        }\n        if (opts.key) {\n            // Pad to blockLen and update\n            const tmp = new Uint8Array(this.blockLen);\n            tmp.set(toBytes(opts.key));\n            this.update(tmp);\n        }\n    }\n    // prettier-ignore\n    get() {\n        let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;\n        return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\n    }\n    // prettier-ignore\n    set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {\n        this.v0l = v0l | 0;\n        this.v0h = v0h | 0;\n        this.v1l = v1l | 0;\n        this.v1h = v1h | 0;\n        this.v2l = v2l | 0;\n        this.v2h = v2h | 0;\n        this.v3l = v3l | 0;\n        this.v3h = v3h | 0;\n        this.v4l = v4l | 0;\n        this.v4h = v4h | 0;\n        this.v5l = v5l | 0;\n        this.v5h = v5h | 0;\n        this.v6l = v6l | 0;\n        this.v6h = v6h | 0;\n        this.v7l = v7l | 0;\n        this.v7h = v7h | 0;\n    }\n    compress(msg, offset, isLast) {\n        this.get().forEach((v, i) => (BBUF[i] = v)); // First half from state.\n        BBUF.set(B2B_IV, 16); // Second half from IV.\n        let { h, l } = u64.fromBig(BigInt(this.length));\n        BBUF[24] = B2B_IV[8] ^ l; // Low word of the offset.\n        BBUF[25] = B2B_IV[9] ^ h; // High word.\n        // Invert all bits for last block\n        if (isLast) {\n            BBUF[28] = ~BBUF[28];\n            BBUF[29] = ~BBUF[29];\n        }\n        let j = 0;\n        const s = SIGMA;\n        for (let i = 0; i < 12; i++) {\n            G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n            G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n            G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n            G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n            G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n            G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n            G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n            G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n            G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n            G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n            G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n            G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n            G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n            G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n            G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n            G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n        }\n        this.v0l ^= BBUF[0] ^ BBUF[16];\n        this.v0h ^= BBUF[1] ^ BBUF[17];\n        this.v1l ^= BBUF[2] ^ BBUF[18];\n        this.v1h ^= BBUF[3] ^ BBUF[19];\n        this.v2l ^= BBUF[4] ^ BBUF[20];\n        this.v2h ^= BBUF[5] ^ BBUF[21];\n        this.v3l ^= BBUF[6] ^ BBUF[22];\n        this.v3h ^= BBUF[7] ^ BBUF[23];\n        this.v4l ^= BBUF[8] ^ BBUF[24];\n        this.v4h ^= BBUF[9] ^ BBUF[25];\n        this.v5l ^= BBUF[10] ^ BBUF[26];\n        this.v5h ^= BBUF[11] ^ BBUF[27];\n        this.v6l ^= BBUF[12] ^ BBUF[28];\n        this.v6h ^= BBUF[13] ^ BBUF[29];\n        this.v7l ^= BBUF[14] ^ BBUF[30];\n        this.v7h ^= BBUF[15] ^ BBUF[31];\n        BBUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer32.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/**\n * Blake2b hash function. Focuses on 64-bit platforms, but in JS speed different from Blake2s is negligible.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */\nexport const blake2b = /* @__PURE__ */ wrapConstructorWithOpts((opts) => new BLAKE2b(opts));\n//# sourceMappingURL=blake2b.js.map","import { bcs } from \"../bcs/index.js\";\nimport { MOVE_STDLIB_ADDRESS, SUI_FRAMEWORK_ADDRESS } from \"../utils/index.js\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nconst OBJECT_MODULE_NAME = \"object\";\nconst ID_STRUCT_NAME = \"ID\";\nconst STD_ASCII_MODULE_NAME = \"ascii\";\nconst STD_ASCII_STRUCT_NAME = \"String\";\nconst STD_UTF8_MODULE_NAME = \"string\";\nconst STD_UTF8_STRUCT_NAME = \"String\";\nconst STD_OPTION_MODULE_NAME = \"option\";\nconst STD_OPTION_STRUCT_NAME = \"Option\";\nfunction isTxContext(param) {\n  const struct = typeof param.body === \"object\" && \"datatype\" in param.body ? param.body.datatype : null;\n  return !!struct && normalizeSuiAddress(struct.package) === normalizeSuiAddress(\"0x2\") && struct.module === \"tx_context\" && struct.type === \"TxContext\";\n}\nfunction getPureBcsSchema(typeSignature) {\n  if (typeof typeSignature === \"string\") {\n    switch (typeSignature) {\n      case \"address\":\n        return bcs.Address;\n      case \"bool\":\n        return bcs.Bool;\n      case \"u8\":\n        return bcs.U8;\n      case \"u16\":\n        return bcs.U16;\n      case \"u32\":\n        return bcs.U32;\n      case \"u64\":\n        return bcs.U64;\n      case \"u128\":\n        return bcs.U128;\n      case \"u256\":\n        return bcs.U256;\n      default:\n        throw new Error(`Unknown type signature ${typeSignature}`);\n    }\n  }\n  if (\"vector\" in typeSignature) {\n    if (typeSignature.vector === \"u8\") {\n      return bcs.vector(bcs.U8).transform({\n        input: (val) => typeof val === \"string\" ? new TextEncoder().encode(val) : val,\n        output: (val) => val\n      });\n    }\n    const type = getPureBcsSchema(typeSignature.vector);\n    return type ? bcs.vector(type) : null;\n  }\n  if (\"datatype\" in typeSignature) {\n    const pkg = normalizeSuiAddress(typeSignature.datatype.package);\n    if (pkg === normalizeSuiAddress(MOVE_STDLIB_ADDRESS)) {\n      if (typeSignature.datatype.module === STD_ASCII_MODULE_NAME && typeSignature.datatype.type === STD_ASCII_STRUCT_NAME) {\n        return bcs.String;\n      }\n      if (typeSignature.datatype.module === STD_UTF8_MODULE_NAME && typeSignature.datatype.type === STD_UTF8_STRUCT_NAME) {\n        return bcs.String;\n      }\n      if (typeSignature.datatype.module === STD_OPTION_MODULE_NAME && typeSignature.datatype.type === STD_OPTION_STRUCT_NAME) {\n        const type = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);\n        return type ? bcs.vector(type) : null;\n      }\n    }\n    if (pkg === normalizeSuiAddress(SUI_FRAMEWORK_ADDRESS) && typeSignature.datatype.module === OBJECT_MODULE_NAME && typeSignature.datatype.type === ID_STRUCT_NAME) {\n      return bcs.Address;\n    }\n  }\n  return null;\n}\nfunction normalizedTypeToMoveTypeSignature(type) {\n  if (typeof type === \"object\" && \"Reference\" in type) {\n    return {\n      ref: \"&\",\n      body: normalizedTypeToMoveTypeSignatureBody(type.Reference)\n    };\n  }\n  if (typeof type === \"object\" && \"MutableReference\" in type) {\n    return {\n      ref: \"&mut\",\n      body: normalizedTypeToMoveTypeSignatureBody(type.MutableReference)\n    };\n  }\n  return {\n    ref: null,\n    body: normalizedTypeToMoveTypeSignatureBody(type)\n  };\n}\nfunction normalizedTypeToMoveTypeSignatureBody(type) {\n  if (typeof type === \"string\") {\n    switch (type) {\n      case \"Address\":\n        return \"address\";\n      case \"Bool\":\n        return \"bool\";\n      case \"U8\":\n        return \"u8\";\n      case \"U16\":\n        return \"u16\";\n      case \"U32\":\n        return \"u32\";\n      case \"U64\":\n        return \"u64\";\n      case \"U128\":\n        return \"u128\";\n      case \"U256\":\n        return \"u256\";\n      default:\n        throw new Error(`Unexpected type ${type}`);\n    }\n  }\n  if (\"Vector\" in type) {\n    return { vector: normalizedTypeToMoveTypeSignatureBody(type.Vector) };\n  }\n  if (\"Struct\" in type) {\n    return {\n      datatype: {\n        package: type.Struct.address,\n        module: type.Struct.module,\n        type: type.Struct.name,\n        typeParameters: type.Struct.typeArguments.map(normalizedTypeToMoveTypeSignatureBody)\n      }\n    };\n  }\n  if (\"TypeParameter\" in type) {\n    return { typeParameter: type.TypeParameter };\n  }\n  throw new Error(`Unexpected type ${JSON.stringify(type)}`);\n}\nfunction pureBcsSchemaFromOpenMoveTypeSignatureBody(typeSignature) {\n  if (typeof typeSignature === \"string\") {\n    switch (typeSignature) {\n      case \"address\":\n        return bcs.Address;\n      case \"bool\":\n        return bcs.Bool;\n      case \"u8\":\n        return bcs.U8;\n      case \"u16\":\n        return bcs.U16;\n      case \"u32\":\n        return bcs.U32;\n      case \"u64\":\n        return bcs.U64;\n      case \"u128\":\n        return bcs.U128;\n      case \"u256\":\n        return bcs.U256;\n      default:\n        throw new Error(`Unknown type signature ${typeSignature}`);\n    }\n  }\n  if (\"vector\" in typeSignature) {\n    return bcs.vector(pureBcsSchemaFromOpenMoveTypeSignatureBody(typeSignature.vector));\n  }\n  throw new Error(`Expected pure typeSignature, but got ${JSON.stringify(typeSignature)}`);\n}\nexport {\n  getPureBcsSchema,\n  isTxContext,\n  normalizedTypeToMoveTypeSignature,\n  pureBcsSchemaFromOpenMoveTypeSignatureBody\n};\n//# sourceMappingURL=serializer.js.map\n","import { parse } from \"valibot\";\nimport { bcs } from \"../bcs/index.js\";\nimport { normalizeSuiAddress, normalizeSuiObjectId, SUI_TYPE_ARG } from \"../utils/index.js\";\nimport { ObjectRef } from \"./data/internal.js\";\nimport { Inputs } from \"./Inputs.js\";\nimport { getPureBcsSchema, isTxContext, normalizedTypeToMoveTypeSignature } from \"./serializer.js\";\nconst MAX_OBJECTS_PER_FETCH = 50;\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 5e10;\nasync function resolveTransactionData(transactionData, options, next) {\n  await normalizeInputs(transactionData, options);\n  await resolveObjectReferences(transactionData, options);\n  if (!options.onlyTransactionKind) {\n    await setGasPrice(transactionData, options);\n    await setGasBudget(transactionData, options);\n    await setGasPayment(transactionData, options);\n  }\n  await validate(transactionData);\n  return await next();\n}\nasync function setGasPrice(transactionData, options) {\n  if (!transactionData.gasConfig.price) {\n    transactionData.gasConfig.price = String(await getClient(options).getReferenceGasPrice());\n  }\n}\nasync function setGasBudget(transactionData, options) {\n  if (transactionData.gasConfig.budget) {\n    return;\n  }\n  const dryRunResult = await getClient(options).dryRunTransactionBlock({\n    transactionBlock: transactionData.build({\n      overrides: {\n        gasData: {\n          budget: String(MAX_GAS),\n          payment: []\n        }\n      }\n    })\n  });\n  if (dryRunResult.effects.status.status !== \"success\") {\n    throw new Error(\n      `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n      { cause: dryRunResult }\n    );\n  }\n  const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n  const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n  const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);\n  transactionData.gasConfig.budget = String(\n    gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead\n  );\n}\nasync function setGasPayment(transactionData, options) {\n  if (!transactionData.gasConfig.payment) {\n    const coins = await getClient(options).getCoins({\n      owner: transactionData.gasConfig.owner || transactionData.sender,\n      coinType: SUI_TYPE_ARG\n    });\n    const paymentCoins = coins.data.filter((coin) => {\n      const matchingInput = transactionData.inputs.find((input) => {\n        if (input.Object?.ImmOrOwnedObject) {\n          return coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n        }\n        return false;\n      });\n      return !matchingInput;\n    }).map((coin) => ({\n      objectId: coin.coinObjectId,\n      digest: coin.digest,\n      version: coin.version\n    }));\n    if (!paymentCoins.length) {\n      throw new Error(\"No valid gas coins found for the transaction.\");\n    }\n    transactionData.gasConfig.payment = paymentCoins.map((payment) => parse(ObjectRef, payment));\n  }\n}\nasync function resolveObjectReferences(transactionData, options) {\n  const objectsToResolve = transactionData.inputs.filter((input) => {\n    return input.UnresolvedObject && !(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion);\n  });\n  const dedupedIds = [\n    ...new Set(\n      objectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId))\n    )\n  ];\n  const objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n  const resolved = (await Promise.all(\n    objectChunks.map(\n      (chunk2) => getClient(options).multiGetObjects({\n        ids: chunk2,\n        options: { showOwner: true }\n      })\n    )\n  )).flat();\n  const responsesById = new Map(\n    dedupedIds.map((id, index) => {\n      return [id, resolved[index]];\n    })\n  );\n  const invalidObjects = Array.from(responsesById).filter(([_, obj]) => obj.error).map(([_, obj]) => JSON.stringify(obj.error));\n  if (invalidObjects.length) {\n    throw new Error(`The following input objects are invalid: ${invalidObjects.join(\", \")}`);\n  }\n  const objects = resolved.map((object) => {\n    if (object.error || !object.data) {\n      throw new Error(`Failed to fetch object: ${object.error}`);\n    }\n    const owner = object.data.owner;\n    const initialSharedVersion = owner && typeof owner === \"object\" && \"Shared\" in owner ? owner.Shared.initial_shared_version : null;\n    return {\n      objectId: object.data.objectId,\n      digest: object.data.digest,\n      version: object.data.version,\n      initialSharedVersion\n    };\n  });\n  const objectsById = new Map(\n    dedupedIds.map((id, index) => {\n      return [id, objects[index]];\n    })\n  );\n  for (const [index, input] of transactionData.inputs.entries()) {\n    if (!input.UnresolvedObject) {\n      continue;\n    }\n    let updated;\n    const id = normalizeSuiAddress(input.UnresolvedObject.objectId);\n    const object = objectsById.get(id);\n    if (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n      updated = Inputs.SharedObjectRef({\n        objectId: id,\n        initialSharedVersion: input.UnresolvedObject.initialSharedVersion || object?.initialSharedVersion,\n        mutable: isUsedAsMutable(transactionData, index)\n      });\n    } else if (isUsedAsReceiving(transactionData, index)) {\n      updated = Inputs.ReceivingRef(\n        {\n          objectId: id,\n          digest: input.UnresolvedObject.digest ?? object?.digest,\n          version: input.UnresolvedObject.version ?? object?.version\n        }\n      );\n    }\n    transactionData.inputs[transactionData.inputs.indexOf(input)] = updated ?? Inputs.ObjectRef({\n      objectId: id,\n      digest: input.UnresolvedObject.digest ?? object?.digest,\n      version: input.UnresolvedObject.version ?? object?.version\n    });\n  }\n}\nasync function normalizeInputs(transactionData, options) {\n  const { inputs, commands } = transactionData;\n  const moveCallsToResolve = [];\n  const moveFunctionsToResolve = /* @__PURE__ */ new Set();\n  commands.forEach((command) => {\n    if (command.MoveCall) {\n      if (command.MoveCall._argumentTypes) {\n        return;\n      }\n      const inputs2 = command.MoveCall.arguments.map((arg) => {\n        if (arg.$kind === \"Input\") {\n          return transactionData.inputs[arg.Input];\n        }\n        return null;\n      });\n      const needsResolution = inputs2.some(\n        (input) => input?.UnresolvedPure || input?.UnresolvedObject\n      );\n      if (needsResolution) {\n        const functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n        moveFunctionsToResolve.add(functionName);\n        moveCallsToResolve.push(command.MoveCall);\n      }\n    }\n    switch (command.$kind) {\n      case \"SplitCoins\":\n        command.SplitCoins.amounts.forEach((amount) => {\n          normalizeRawArgument(amount, bcs.U64, transactionData);\n        });\n        break;\n      case \"TransferObjects\":\n        normalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n        break;\n    }\n  });\n  const moveFunctionParameters = /* @__PURE__ */ new Map();\n  if (moveFunctionsToResolve.size > 0) {\n    const client = getClient(options);\n    await Promise.all(\n      [...moveFunctionsToResolve].map(async (functionName) => {\n        const [packageId, moduleId, functionId] = functionName.split(\"::\");\n        const def = await client.getNormalizedMoveFunction({\n          package: packageId,\n          module: moduleId,\n          function: functionId\n        });\n        moveFunctionParameters.set(\n          functionName,\n          def.parameters.map((param) => normalizedTypeToMoveTypeSignature(param))\n        );\n      })\n    );\n  }\n  if (moveCallsToResolve.length) {\n    await Promise.all(\n      moveCallsToResolve.map(async (moveCall) => {\n        const parameters = moveFunctionParameters.get(\n          `${moveCall.package}::${moveCall.module}::${moveCall.function}`\n        );\n        if (!parameters) {\n          return;\n        }\n        const hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1));\n        const params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;\n        moveCall._argumentTypes = params;\n      })\n    );\n  }\n  commands.forEach((command) => {\n    if (!command.MoveCall) {\n      return;\n    }\n    const moveCall = command.MoveCall;\n    const fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n    const params = moveCall._argumentTypes;\n    if (!params) {\n      return;\n    }\n    if (params.length !== command.MoveCall.arguments.length) {\n      throw new Error(`Incorrect number of arguments for ${fnName}`);\n    }\n    params.forEach((param, i) => {\n      const arg = moveCall.arguments[i];\n      if (arg.$kind !== \"Input\") return;\n      const input = inputs[arg.Input];\n      if (!input.UnresolvedPure && !input.UnresolvedObject) {\n        return;\n      }\n      const inputValue = input.UnresolvedPure?.value ?? input.UnresolvedObject?.objectId;\n      const schema = getPureBcsSchema(param.body);\n      if (schema) {\n        arg.type = \"pure\";\n        inputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));\n        return;\n      }\n      if (typeof inputValue !== \"string\") {\n        throw new Error(\n          `Expect the argument to be an object id string, got ${JSON.stringify(\n            inputValue,\n            null,\n            2\n          )}`\n        );\n      }\n      arg.type = \"object\";\n      const unresolvedObject = input.UnresolvedPure ? {\n        $kind: \"UnresolvedObject\",\n        UnresolvedObject: {\n          objectId: inputValue\n        }\n      } : input;\n      inputs[arg.Input] = unresolvedObject;\n    });\n  });\n}\nfunction validate(transactionData) {\n  transactionData.inputs.forEach((input, index) => {\n    if (input.$kind !== \"Object\" && input.$kind !== \"Pure\") {\n      throw new Error(\n        `Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(\n          input\n        )}`\n      );\n    }\n  });\n}\nfunction normalizeRawArgument(arg, schema, transactionData) {\n  if (arg.$kind !== \"Input\") {\n    return;\n  }\n  const input = transactionData.inputs[arg.Input];\n  if (input.$kind !== \"UnresolvedPure\") {\n    return;\n  }\n  transactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\nfunction isUsedAsMutable(transactionData, index) {\n  let usedAsMutable = false;\n  transactionData.getInputUses(index, (arg, tx) => {\n    if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n      const argIndex = tx.MoveCall.arguments.indexOf(arg);\n      usedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== \"&\" || usedAsMutable;\n    }\n    if (tx.$kind === \"MakeMoveVec\" || tx.$kind === \"MergeCoins\" || tx.$kind === \"SplitCoins\") {\n      usedAsMutable = true;\n    }\n  });\n  return usedAsMutable;\n}\nfunction isUsedAsReceiving(transactionData, index) {\n  let usedAsReceiving = false;\n  transactionData.getInputUses(index, (arg, tx) => {\n    if (tx.MoveCall && tx.MoveCall._argumentTypes) {\n      const argIndex = tx.MoveCall.arguments.indexOf(arg);\n      usedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n    }\n  });\n  return usedAsReceiving;\n}\nfunction isReceivingType(type) {\n  if (typeof type.body !== \"object\" || !(\"datatype\" in type.body)) {\n    return false;\n  }\n  return type.body.datatype.package === \"0x2\" && type.body.datatype.module === \"transfer\" && type.body.datatype.type === \"Receiving\";\n}\nfunction getClient(options) {\n  if (!options.client) {\n    throw new Error(\n      `No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`\n    );\n  }\n  return options.client;\n}\nfunction chunk(arr, size) {\n  return Array.from(\n    { length: Math.ceil(arr.length / size) },\n    (_, i) => arr.slice(i * size, i * size + size)\n  );\n}\nexport {\n  getClient,\n  resolveTransactionData\n};\n//# sourceMappingURL=json-rpc-resolver.js.map\n","import { isSerializedBcs } from \"@mysten/bcs\";\nimport { bcs } from \"../bcs/index.js\";\nimport { pureBcsSchemaFromTypeName } from \"../bcs/pure.js\";\nfunction createPure(makePure) {\n  function pure(typeOrSerializedValue, value) {\n    if (typeof typeOrSerializedValue === \"string\") {\n      return makePure(pureBcsSchemaFromTypeName(typeOrSerializedValue).serialize(value));\n    }\n    if (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {\n      return makePure(typeOrSerializedValue);\n    }\n    throw new Error(\"tx.pure must be called either a bcs type name, or a serialized bcs value\");\n  }\n  pure.u8 = (value) => makePure(bcs.U8.serialize(value));\n  pure.u16 = (value) => makePure(bcs.U16.serialize(value));\n  pure.u32 = (value) => makePure(bcs.U32.serialize(value));\n  pure.u64 = (value) => makePure(bcs.U64.serialize(value));\n  pure.u128 = (value) => makePure(bcs.U128.serialize(value));\n  pure.u256 = (value) => makePure(bcs.U256.serialize(value));\n  pure.bool = (value) => makePure(bcs.Bool.serialize(value));\n  pure.string = (value) => makePure(bcs.String.serialize(value));\n  pure.address = (value) => makePure(bcs.Address.serialize(value));\n  pure.id = pure.address;\n  pure.vector = (type, value) => {\n    return makePure(\n      bcs.vector(pureBcsSchemaFromTypeName(type)).serialize(value)\n    );\n  };\n  pure.option = (type, value) => {\n    return makePure(bcs.option(pureBcsSchemaFromTypeName(type)).serialize(value));\n  };\n  return pure;\n}\nexport {\n  createPure\n};\n//# sourceMappingURL=pure.js.map\n","import { toBase58 } from \"@mysten/bcs\";\nimport { parse } from \"valibot\";\nimport { bcs } from \"../bcs/index.js\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { TransactionData } from \"./data/internal.js\";\nimport { transactionDataFromV1 } from \"./data/v1.js\";\nimport { hashTypedData } from \"./hash.js\";\nfunction prepareSuiAddress(address) {\n  return normalizeSuiAddress(address).replace(\"0x\", \"\");\n}\nclass TransactionDataBuilder {\n  constructor(clone) {\n    this.version = 2;\n    this.sender = clone?.sender ?? null;\n    this.expiration = clone?.expiration ?? null;\n    this.inputs = clone?.inputs ?? [];\n    this.commands = clone?.commands ?? [];\n    this.gasData = clone?.gasData ?? {\n      budget: null,\n      price: null,\n      owner: null,\n      payment: null\n    };\n  }\n  static fromKindBytes(bytes) {\n    const kind = bcs.TransactionKind.parse(bytes);\n    const programmableTx = kind.ProgrammableTransaction;\n    if (!programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    return TransactionDataBuilder.restore({\n      version: 2,\n      sender: null,\n      expiration: null,\n      gasData: {\n        budget: null,\n        owner: null,\n        payment: null,\n        price: null\n      },\n      inputs: programmableTx.inputs,\n      commands: programmableTx.commands\n    });\n  }\n  static fromBytes(bytes) {\n    const rawData = bcs.TransactionData.parse(bytes);\n    const data = rawData?.V1;\n    const programmableTx = data.kind.ProgrammableTransaction;\n    if (!data || !programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    return TransactionDataBuilder.restore({\n      version: 2,\n      sender: data.sender,\n      expiration: data.expiration,\n      gasData: data.gasData,\n      inputs: programmableTx.inputs,\n      commands: programmableTx.commands\n    });\n  }\n  static restore(data) {\n    if (data.version === 2) {\n      return new TransactionDataBuilder(parse(TransactionData, data));\n    } else {\n      return new TransactionDataBuilder(parse(TransactionData, transactionDataFromV1(data)));\n    }\n  }\n  /**\n   * Generate transaction digest.\n   *\n   * @param bytes BCS serialized transaction data\n   * @returns transaction digest.\n   */\n  static getDigestFromBytes(bytes) {\n    const hash = hashTypedData(\"TransactionData\", bytes);\n    return toBase58(hash);\n  }\n  // @deprecated use gasData instead\n  get gasConfig() {\n    return this.gasData;\n  }\n  // @deprecated use gasData instead\n  set gasConfig(value) {\n    this.gasData = value;\n  }\n  build({\n    maxSizeBytes = Infinity,\n    overrides,\n    onlyTransactionKind\n  } = {}) {\n    const inputs = this.inputs;\n    const commands = this.commands;\n    const kind = {\n      ProgrammableTransaction: {\n        inputs,\n        commands\n      }\n    };\n    if (onlyTransactionKind) {\n      return bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n    }\n    const expiration = overrides?.expiration ?? this.expiration;\n    const sender = overrides?.sender ?? this.sender;\n    const gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };\n    if (!sender) {\n      throw new Error(\"Missing transaction sender\");\n    }\n    if (!gasData.budget) {\n      throw new Error(\"Missing gas budget\");\n    }\n    if (!gasData.payment) {\n      throw new Error(\"Missing gas payment\");\n    }\n    if (!gasData.price) {\n      throw new Error(\"Missing gas price\");\n    }\n    const transactionData = {\n      sender: prepareSuiAddress(sender),\n      expiration: expiration ? expiration : { None: true },\n      gasData: {\n        payment: gasData.payment,\n        owner: prepareSuiAddress(this.gasData.owner ?? sender),\n        price: BigInt(gasData.price),\n        budget: BigInt(gasData.budget)\n      },\n      kind: {\n        ProgrammableTransaction: {\n          inputs,\n          commands\n        }\n      }\n    };\n    return bcs.TransactionData.serialize(\n      { V1: transactionData },\n      { maxSize: maxSizeBytes }\n    ).toBytes();\n  }\n  addInput(type, arg) {\n    const index = this.inputs.length;\n    this.inputs.push(arg);\n    return { Input: index, type, $kind: \"Input\" };\n  }\n  getInputUses(index, fn) {\n    this.mapArguments((arg, command) => {\n      if (arg.$kind === \"Input\" && arg.Input === index) {\n        fn(arg, command);\n      }\n      return arg;\n    });\n  }\n  mapArguments(fn) {\n    for (const command of this.commands) {\n      switch (command.$kind) {\n        case \"MoveCall\":\n          command.MoveCall.arguments = command.MoveCall.arguments.map((arg) => fn(arg, command));\n          break;\n        case \"TransferObjects\":\n          command.TransferObjects.objects = command.TransferObjects.objects.map(\n            (arg) => fn(arg, command)\n          );\n          command.TransferObjects.address = fn(command.TransferObjects.address, command);\n          break;\n        case \"SplitCoins\":\n          command.SplitCoins.coin = fn(command.SplitCoins.coin, command);\n          command.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) => fn(arg, command));\n          break;\n        case \"MergeCoins\":\n          command.MergeCoins.destination = fn(command.MergeCoins.destination, command);\n          command.MergeCoins.sources = command.MergeCoins.sources.map((arg) => fn(arg, command));\n          break;\n        case \"MakeMoveVec\":\n          command.MakeMoveVec.elements = command.MakeMoveVec.elements.map(\n            (arg) => fn(arg, command)\n          );\n          break;\n        case \"Upgrade\":\n          command.Upgrade.ticket = fn(command.Upgrade.ticket, command);\n          break;\n        case \"$Intent\":\n          const inputs = command.$Intent.inputs;\n          command.$Intent.inputs = {};\n          for (const [key, value] of Object.entries(inputs)) {\n            command.$Intent.inputs[key] = Array.isArray(value) ? value.map((arg) => fn(arg, command)) : fn(value, command);\n          }\n          break;\n        case \"Publish\":\n          break;\n        default:\n          throw new Error(`Unexpected transaction kind: ${command.$kind}`);\n      }\n    }\n  }\n  replaceCommand(index, replacement) {\n    if (!Array.isArray(replacement)) {\n      this.commands[index] = replacement;\n      return;\n    }\n    const sizeDiff = replacement.length - 1;\n    this.commands.splice(index, 1, ...replacement);\n    if (sizeDiff !== 0) {\n      this.mapArguments((arg) => {\n        switch (arg.$kind) {\n          case \"Result\":\n            if (arg.Result > index) {\n              arg.Result += sizeDiff;\n            }\n            break;\n          case \"NestedResult\":\n            if (arg.NestedResult[0] > index) {\n              arg.NestedResult[0] += sizeDiff;\n            }\n            break;\n        }\n        return arg;\n      });\n    }\n  }\n  getDigest() {\n    const bytes = this.build({ onlyTransactionKind: false });\n    return TransactionDataBuilder.getDigestFromBytes(bytes);\n  }\n  snapshot() {\n    return parse(TransactionData, this);\n  }\n}\nexport {\n  TransactionDataBuilder\n};\n//# sourceMappingURL=TransactionData.js.map\n","import { blake2b } from \"@noble/hashes/blake2b\";\nfunction hashTypedData(typeTag, data) {\n  const typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));\n  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);\n  dataWithTag.set(typeTagBytes);\n  dataWithTag.set(data, typeTagBytes.length);\n  return blake2b(dataWithTag, { dkLen: 32 });\n}\nexport {\n  hashTypedData\n};\n//# sourceMappingURL=hash.js.map\n","import { is } from \"valibot\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { Argument } from \"./data/internal.js\";\nfunction extractMutableReference(normalizedType) {\n  return typeof normalizedType === \"object\" && \"MutableReference\" in normalizedType ? normalizedType.MutableReference : void 0;\n}\nfunction extractReference(normalizedType) {\n  return typeof normalizedType === \"object\" && \"Reference\" in normalizedType ? normalizedType.Reference : void 0;\n}\nfunction extractStructTag(normalizedType) {\n  if (typeof normalizedType === \"object\" && \"Struct\" in normalizedType) {\n    return normalizedType;\n  }\n  const ref = extractReference(normalizedType);\n  const mutRef = extractMutableReference(normalizedType);\n  if (typeof ref === \"object\" && \"Struct\" in ref) {\n    return ref;\n  }\n  if (typeof mutRef === \"object\" && \"Struct\" in mutRef) {\n    return mutRef;\n  }\n  return void 0;\n}\nfunction getIdFromCallArg(arg) {\n  if (typeof arg === \"string\") {\n    return normalizeSuiAddress(arg);\n  }\n  if (arg.Object) {\n    if (arg.Object.ImmOrOwnedObject) {\n      return normalizeSuiAddress(arg.Object.ImmOrOwnedObject.objectId);\n    }\n    if (arg.Object.Receiving) {\n      return normalizeSuiAddress(arg.Object.Receiving.objectId);\n    }\n    return normalizeSuiAddress(arg.Object.SharedObject.objectId);\n  }\n  if (arg.UnresolvedObject) {\n    return normalizeSuiAddress(arg.UnresolvedObject.objectId);\n  }\n  return void 0;\n}\nfunction isArgument(value) {\n  return is(Argument, value);\n}\nexport {\n  extractMutableReference,\n  extractReference,\n  extractStructTag,\n  getIdFromCallArg,\n  isArgument\n};\n//# sourceMappingURL=utils.js.map\n","var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _serializationPlugins, _buildPlugins, _intentResolvers, _data, _Transaction_instances, normalizeTransactionArgument_fn, resolveArgument_fn, prepareBuild_fn, runPlugins_fn;\nimport { fromBase64, isSerializedBcs } from \"@mysten/bcs\";\nimport { is, parse } from \"valibot\";\nimport { normalizeSuiAddress } from \"../utils/sui-types.js\";\nimport { Commands } from \"./Commands.js\";\nimport { Argument, NormalizedCallArg, ObjectRef, TransactionExpiration } from \"./data/internal.js\";\nimport { serializeV1TransactionData } from \"./data/v1.js\";\nimport { SerializedTransactionDataV2 } from \"./data/v2.js\";\nimport { Inputs } from \"./Inputs.js\";\nimport { resolveTransactionData } from \"./json-rpc-resolver.js\";\nimport { createObjectMethods } from \"./object.js\";\nimport { createPure } from \"./pure.js\";\nimport { TransactionDataBuilder } from \"./TransactionData.js\";\nimport { getIdFromCallArg } from \"./utils.js\";\nfunction createTransactionResult(index, length = Infinity) {\n  const baseResult = { $kind: \"Result\", Result: index };\n  const nestedResults = [];\n  const nestedResultFor = (resultIndex) => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {\n    $kind: \"NestedResult\",\n    NestedResult: [index, resultIndex]\n  });\n  return new Proxy(baseResult, {\n    set() {\n      throw new Error(\n        \"The transaction result is a proxy, and does not support setting properties directly\"\n      );\n    },\n    // TODO: Instead of making this return a concrete argument, we should ideally\n    // make it reference-based (so that this gets resolved at build-time), which\n    // allows re-ordering transactions.\n    get(target, property) {\n      if (property in target) {\n        return Reflect.get(target, property);\n      }\n      if (property === Symbol.iterator) {\n        return function* () {\n          let i = 0;\n          while (i < length) {\n            yield nestedResultFor(i);\n            i++;\n          }\n        };\n      }\n      if (typeof property === \"symbol\") return;\n      const resultIndex = parseInt(property, 10);\n      if (Number.isNaN(resultIndex) || resultIndex < 0) return;\n      return nestedResultFor(resultIndex);\n    }\n  });\n}\nconst TRANSACTION_BRAND = Symbol.for(\"@mysten/transaction\");\nfunction isTransaction(obj) {\n  return !!obj && typeof obj === \"object\" && obj[TRANSACTION_BRAND] === true;\n}\nconst modulePluginRegistry = {\n  buildPlugins: /* @__PURE__ */ new Map(),\n  serializationPlugins: /* @__PURE__ */ new Map()\n};\nconst TRANSACTION_REGISTRY_KEY = Symbol.for(\"@mysten/transaction/registry\");\nfunction getGlobalPluginRegistry() {\n  try {\n    const target = globalThis;\n    if (!target[TRANSACTION_REGISTRY_KEY]) {\n      target[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n    }\n    return target[TRANSACTION_REGISTRY_KEY];\n  } catch (e) {\n    return modulePluginRegistry;\n  }\n}\nconst _Transaction = class _Transaction {\n  constructor() {\n    __privateAdd(this, _Transaction_instances);\n    __privateAdd(this, _serializationPlugins);\n    __privateAdd(this, _buildPlugins);\n    __privateAdd(this, _intentResolvers, /* @__PURE__ */ new Map());\n    __privateAdd(this, _data);\n    /**\n     * Add a new object input to the transaction.\n     */\n    this.object = createObjectMethods(\n      (value) => {\n        if (typeof value === \"function\") {\n          return this.object(value(this));\n        }\n        if (typeof value === \"object\" && is(Argument, value)) {\n          return value;\n        }\n        const id = getIdFromCallArg(value);\n        const inserted = __privateGet(this, _data).inputs.find((i) => id === getIdFromCallArg(i));\n        if (inserted?.Object?.SharedObject && typeof value === \"object\" && value.Object?.SharedObject) {\n          inserted.Object.SharedObject.mutable = inserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n        }\n        return inserted ? { $kind: \"Input\", Input: __privateGet(this, _data).inputs.indexOf(inserted), type: \"object\" } : __privateGet(this, _data).addInput(\n          \"object\",\n          typeof value === \"string\" ? {\n            $kind: \"UnresolvedObject\",\n            UnresolvedObject: { objectId: normalizeSuiAddress(value) }\n          } : value\n        );\n      }\n    );\n    const globalPlugins = getGlobalPluginRegistry();\n    __privateSet(this, _data, new TransactionDataBuilder());\n    __privateSet(this, _buildPlugins, [...globalPlugins.buildPlugins.values()]);\n    __privateSet(this, _serializationPlugins, [...globalPlugins.serializationPlugins.values()]);\n  }\n  /**\n   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n   * Supports either a byte array, or base64-encoded bytes.\n   */\n  static fromKind(serialized) {\n    const tx = new _Transaction();\n    __privateSet(tx, _data, TransactionDataBuilder.fromKindBytes(\n      typeof serialized === \"string\" ? fromBase64(serialized) : serialized\n    ));\n    return tx;\n  }\n  /**\n   * Converts from a serialized transaction format to a `Transaction` class.\n   * There are two supported serialized formats:\n   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n   * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n   */\n  static from(transaction) {\n    const newTransaction = new _Transaction();\n    if (isTransaction(transaction)) {\n      __privateSet(newTransaction, _data, new TransactionDataBuilder(transaction.getData()));\n    } else if (typeof transaction !== \"string\" || !transaction.startsWith(\"{\")) {\n      __privateSet(newTransaction, _data, TransactionDataBuilder.fromBytes(\n        typeof transaction === \"string\" ? fromBase64(transaction) : transaction\n      ));\n    } else {\n      __privateSet(newTransaction, _data, TransactionDataBuilder.restore(JSON.parse(transaction)));\n    }\n    return newTransaction;\n  }\n  static registerGlobalSerializationPlugin(stepOrStep, step) {\n    getGlobalPluginRegistry().serializationPlugins.set(\n      stepOrStep,\n      step ?? stepOrStep\n    );\n  }\n  static unregisterGlobalSerializationPlugin(name) {\n    getGlobalPluginRegistry().serializationPlugins.delete(name);\n  }\n  static registerGlobalBuildPlugin(stepOrStep, step) {\n    getGlobalPluginRegistry().buildPlugins.set(\n      stepOrStep,\n      step ?? stepOrStep\n    );\n  }\n  static unregisterGlobalBuildPlugin(name) {\n    getGlobalPluginRegistry().buildPlugins.delete(name);\n  }\n  addSerializationPlugin(step) {\n    __privateGet(this, _serializationPlugins).push(step);\n  }\n  addBuildPlugin(step) {\n    __privateGet(this, _buildPlugins).push(step);\n  }\n  addIntentResolver(intent, resolver) {\n    if (__privateGet(this, _intentResolvers).has(intent) && __privateGet(this, _intentResolvers).get(intent) !== resolver) {\n      throw new Error(`Intent resolver for ${intent} already exists`);\n    }\n    __privateGet(this, _intentResolvers).set(intent, resolver);\n  }\n  setSender(sender) {\n    __privateGet(this, _data).sender = sender;\n  }\n  /**\n   * Sets the sender only if it has not already been set.\n   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n   */\n  setSenderIfNotSet(sender) {\n    if (!__privateGet(this, _data).sender) {\n      __privateGet(this, _data).sender = sender;\n    }\n  }\n  setExpiration(expiration) {\n    __privateGet(this, _data).expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n  }\n  setGasPrice(price) {\n    __privateGet(this, _data).gasConfig.price = String(price);\n  }\n  setGasBudget(budget) {\n    __privateGet(this, _data).gasConfig.budget = String(budget);\n  }\n  setGasBudgetIfNotSet(budget) {\n    if (__privateGet(this, _data).gasData.budget == null) {\n      __privateGet(this, _data).gasConfig.budget = String(budget);\n    }\n  }\n  setGasOwner(owner) {\n    __privateGet(this, _data).gasConfig.owner = owner;\n  }\n  setGasPayment(payments) {\n    __privateGet(this, _data).gasConfig.payment = payments.map((payment) => parse(ObjectRef, payment));\n  }\n  /** @deprecated Use `getData()` instead. */\n  get blockData() {\n    return serializeV1TransactionData(__privateGet(this, _data).snapshot());\n  }\n  /** Get a snapshot of the transaction data, in JSON form: */\n  getData() {\n    return __privateGet(this, _data).snapshot();\n  }\n  // Used to brand transaction classes so that they can be identified, even between multiple copies\n  // of the builder.\n  get [TRANSACTION_BRAND]() {\n    return true;\n  }\n  // Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n  get pure() {\n    Object.defineProperty(this, \"pure\", {\n      enumerable: false,\n      value: createPure((value) => {\n        if (isSerializedBcs(value)) {\n          return __privateGet(this, _data).addInput(\"pure\", {\n            $kind: \"Pure\",\n            Pure: {\n              bytes: value.toBase64()\n            }\n          });\n        }\n        return __privateGet(this, _data).addInput(\n          \"pure\",\n          is(NormalizedCallArg, value) ? parse(NormalizedCallArg, value) : value instanceof Uint8Array ? Inputs.Pure(value) : { $kind: \"UnresolvedPure\", UnresolvedPure: { value } }\n        );\n      })\n    });\n    return this.pure;\n  }\n  /** Returns an argument for the gas coin, to be used in a transaction. */\n  get gas() {\n    return { $kind: \"GasCoin\", GasCoin: true };\n  }\n  /**\n   * Add a new object input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  objectRef(...args) {\n    return this.object(Inputs.ObjectRef(...args));\n  }\n  /**\n   * Add a new receiving input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  receivingRef(...args) {\n    return this.object(Inputs.ReceivingRef(...args));\n  }\n  /**\n   * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  sharedObjectRef(...args) {\n    return this.object(Inputs.SharedObjectRef(...args));\n  }\n  /** Add a transaction to the transaction */\n  add(command) {\n    if (typeof command === \"function\") {\n      return command(this);\n    }\n    const index = __privateGet(this, _data).commands.push(command);\n    return createTransactionResult(index - 1);\n  }\n  // Method shorthands:\n  splitCoins(coin, amounts) {\n    const command = Commands.SplitCoins(\n      typeof coin === \"string\" ? this.object(coin) : __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, coin),\n      amounts.map(\n        (amount) => typeof amount === \"number\" || typeof amount === \"bigint\" || typeof amount === \"string\" ? this.pure.u64(amount) : __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, amount)\n      )\n    );\n    const index = __privateGet(this, _data).commands.push(command);\n    return createTransactionResult(index - 1, amounts.length);\n  }\n  mergeCoins(destination, sources) {\n    return this.add(\n      Commands.MergeCoins(\n        this.object(destination),\n        sources.map((src) => this.object(src))\n      )\n    );\n  }\n  publish({ modules, dependencies }) {\n    return this.add(\n      Commands.Publish({\n        modules,\n        dependencies\n      })\n    );\n  }\n  upgrade({\n    modules,\n    dependencies,\n    package: packageId,\n    ticket\n  }) {\n    return this.add(\n      Commands.Upgrade({\n        modules,\n        dependencies,\n        package: packageId,\n        ticket: this.object(ticket)\n      })\n    );\n  }\n  moveCall({\n    arguments: args,\n    ...input\n  }) {\n    return this.add(\n      Commands.MoveCall({\n        ...input,\n        arguments: args?.map((arg) => __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, arg))\n      })\n    );\n  }\n  transferObjects(objects, address) {\n    return this.add(\n      Commands.TransferObjects(\n        objects.map((obj) => this.object(obj)),\n        typeof address === \"string\" ? this.pure.address(address) : __privateMethod(this, _Transaction_instances, normalizeTransactionArgument_fn).call(this, address)\n      )\n    );\n  }\n  makeMoveVec({\n    type,\n    elements\n  }) {\n    return this.add(\n      Commands.MakeMoveVec({\n        type,\n        elements: elements.map((obj) => this.object(obj))\n      })\n    );\n  }\n  /**\n   * @deprecated Use toJSON instead.\n   * For synchronous serialization, you can use `getData()`\n   * */\n  serialize() {\n    return JSON.stringify(serializeV1TransactionData(__privateGet(this, _data).snapshot()));\n  }\n  async toJSON(options = {}) {\n    await this.prepareForSerialization(options);\n    return JSON.stringify(\n      parse(SerializedTransactionDataV2, __privateGet(this, _data).snapshot()),\n      (_key, value) => typeof value === \"bigint\" ? value.toString() : value,\n      2\n    );\n  }\n  /** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n  async sign(options) {\n    const { signer, ...buildOptions } = options;\n    const bytes = await this.build(buildOptions);\n    return signer.signTransaction(bytes);\n  }\n  /** Build the transaction to BCS bytes. */\n  async build(options = {}) {\n    await this.prepareForSerialization(options);\n    await __privateMethod(this, _Transaction_instances, prepareBuild_fn).call(this, options);\n    return __privateGet(this, _data).build({\n      onlyTransactionKind: options.onlyTransactionKind\n    });\n  }\n  /** Derive transaction digest */\n  async getDigest(options = {}) {\n    await __privateMethod(this, _Transaction_instances, prepareBuild_fn).call(this, options);\n    return __privateGet(this, _data).getDigest();\n  }\n  async prepareForSerialization(options) {\n    const intents = /* @__PURE__ */ new Set();\n    for (const command of __privateGet(this, _data).commands) {\n      if (command.$Intent) {\n        intents.add(command.$Intent.name);\n      }\n    }\n    const steps = [...__privateGet(this, _serializationPlugins)];\n    for (const intent of intents) {\n      if (options.supportedIntents?.includes(intent)) {\n        continue;\n      }\n      if (!__privateGet(this, _intentResolvers).has(intent)) {\n        throw new Error(`Missing intent resolver for ${intent}`);\n      }\n      steps.push(__privateGet(this, _intentResolvers).get(intent));\n    }\n    await __privateMethod(this, _Transaction_instances, runPlugins_fn).call(this, steps, options);\n  }\n};\n_serializationPlugins = new WeakMap();\n_buildPlugins = new WeakMap();\n_intentResolvers = new WeakMap();\n_data = new WeakMap();\n_Transaction_instances = new WeakSet();\nnormalizeTransactionArgument_fn = function(arg) {\n  if (isSerializedBcs(arg)) {\n    return this.pure(arg);\n  }\n  return __privateMethod(this, _Transaction_instances, resolveArgument_fn).call(this, arg);\n};\nresolveArgument_fn = function(arg) {\n  if (typeof arg === \"function\") {\n    return parse(Argument, arg(this));\n  }\n  return parse(Argument, arg);\n};\nprepareBuild_fn = async function(options) {\n  if (!options.onlyTransactionKind && !__privateGet(this, _data).sender) {\n    throw new Error(\"Missing transaction sender\");\n  }\n  await __privateMethod(this, _Transaction_instances, runPlugins_fn).call(this, [...__privateGet(this, _buildPlugins), resolveTransactionData], options);\n};\nrunPlugins_fn = async function(plugins, options) {\n  const createNext = (i) => {\n    if (i >= plugins.length) {\n      return () => {\n      };\n    }\n    const plugin = plugins[i];\n    return async () => {\n      const next = createNext(i + 1);\n      let calledNext = false;\n      let nextResolved = false;\n      await plugin(__privateGet(this, _data), options, async () => {\n        if (calledNext) {\n          throw new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n        }\n        calledNext = true;\n        await next();\n        nextResolved = true;\n      });\n      if (!calledNext) {\n        throw new Error(`next() was not called in TransactionPlugin ${i}`);\n      }\n      if (!nextResolved) {\n        throw new Error(`next() was not awaited in TransactionPlugin ${i}`);\n      }\n    };\n  };\n  await createNext(0)();\n};\nlet Transaction = _Transaction;\nexport {\n  Transaction,\n  isTransaction\n};\n//# sourceMappingURL=Transaction.js.map\n","function createObjectMethods(makeObject) {\n  function object(value) {\n    return makeObject(value);\n  }\n  object.system = () => object(\"0x5\");\n  object.clock = () => object(\"0x6\");\n  object.random = () => object(\"0x8\");\n  object.denyList = () => object(\"0x403\");\n  object.option = ({ type, value }) => (tx) => tx.moveCall({\n    typeArguments: [type],\n    target: `0x1::option::${value === null ? \"none\" : \"some\"}`,\n    arguments: value === null ? [] : [tx.object(value)]\n  });\n  return object;\n}\nexport {\n  createObjectMethods\n};\n//# sourceMappingURL=object.js.map\n","import { Experimental_SuiClient } from \"./client.js\";\nclass Experimental_CoreClient extends Experimental_SuiClient {\n  constructor() {\n    super(...arguments);\n    this.core = this;\n  }\n}\nexport {\n  Experimental_CoreClient\n};\n//# sourceMappingURL=core.js.map\n","class SuiClientError extends Error {\n}\nclass ObjectError extends SuiClientError {\n  constructor(code, message) {\n    super(message);\n    this.code = code;\n  }\n  static fromResponse(response, objectId) {\n    switch (response.code) {\n      case \"notExists\":\n        return new ObjectError(response.code, `Object ${response.object_id} does not exist`);\n      case \"dynamicFieldNotFound\":\n        return new ObjectError(\n          response.code,\n          `Dynamic field not found for object ${response.parent_object_id}`\n        );\n      case \"deleted\":\n        return new ObjectError(response.code, `Object ${response.object_id} has been deleted`);\n      case \"displayError\":\n        return new ObjectError(response.code, `Display error: ${response.error}`);\n      case \"unknown\":\n      default:\n        return new ObjectError(\n          response.code,\n          `Unknown error while loading object${objectId ? ` ${objectId}` : \"\"}`\n        );\n    }\n  }\n}\nexport {\n  ObjectError,\n  SuiClientError\n};\n//# sourceMappingURL=errors.js.map\n","var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar _jsonRpcClient;\nimport { fromBase64 } from \"@mysten/bcs\";\nimport { bcs } from \"../../bcs/index.js\";\nimport { batch } from \"../../transactions/plugins/utils.js\";\nimport { Transaction } from \"../../transactions/Transaction.js\";\nimport { Experimental_CoreClient } from \"../core.js\";\nimport { ObjectError } from \"../errors.js\";\nclass JSONRpcTransport extends Experimental_CoreClient {\n  constructor(jsonRpcClient) {\n    super({ network: jsonRpcClient.network });\n    __privateAdd(this, _jsonRpcClient);\n    __privateSet(this, _jsonRpcClient, jsonRpcClient);\n  }\n  async getObjects(options) {\n    const batches = batch(options.objectIds, 50);\n    const results = [];\n    for (const batch2 of batches) {\n      const objects = await __privateGet(this, _jsonRpcClient).multiGetObjects({\n        ids: batch2,\n        options: {\n          showOwner: true,\n          showType: true\n        }\n      });\n      for (const [idx, object] of objects.entries()) {\n        if (object.error) {\n          results.push(ObjectError.fromResponse(object.error, batch2[idx]));\n        } else {\n          results.push(parseObject(object.data));\n        }\n      }\n    }\n    return {\n      objects: results\n    };\n  }\n  async getOwnedObjects(options) {\n    const objects = await __privateGet(this, _jsonRpcClient).getOwnedObjects({\n      owner: options.address,\n      limit: options.limit,\n      cursor: options.cursor\n    });\n    return {\n      objects: objects.data.map((result) => {\n        if (result.error) {\n          throw ObjectError.fromResponse(result.error);\n        }\n        return parseObject(result.data);\n      }),\n      hasNextPage: objects.hasNextPage,\n      cursor: objects.nextCursor ?? null\n    };\n  }\n  async getCoins(options) {\n    const coins = await __privateGet(this, _jsonRpcClient).getCoins({\n      owner: options.address,\n      coinType: options.coinType\n    });\n    return {\n      objects: coins.data.map((coin) => {\n        return {\n          id: coin.coinObjectId,\n          version: coin.version,\n          digest: coin.digest,\n          balance: BigInt(coin.balance),\n          type: `0x2::coin::Coin<${coin.coinType}>`,\n          content: Coin.serialize({\n            id: coin.coinObjectId,\n            balance: {\n              value: coin.balance\n            }\n          }).toBytes(),\n          owner: {\n            $kind: \"ObjectOwner\",\n            ObjectOwner: options.address\n          }\n        };\n      }),\n      hasNextPage: coins.hasNextPage,\n      cursor: coins.nextCursor ?? null\n    };\n  }\n  async getBalance(options) {\n    const balance = await __privateGet(this, _jsonRpcClient).getBalance({\n      owner: options.address,\n      coinType: options.coinType\n    });\n    return {\n      balance: {\n        coinType: balance.coinType,\n        balance: BigInt(balance.totalBalance)\n      }\n    };\n  }\n  async getAllBalances(options) {\n    const balances = await __privateGet(this, _jsonRpcClient).getAllBalances({\n      owner: options.address\n    });\n    return {\n      balances: balances.map((balance) => ({\n        coinType: balance.coinType,\n        balance: BigInt(balance.totalBalance)\n      })),\n      hasNextPage: false,\n      cursor: null\n    };\n  }\n  async getTransaction(options) {\n    const transaction = await __privateGet(this, _jsonRpcClient).getTransactionBlock({\n      digest: options.digest,\n      options: {\n        showRawInput: true,\n        showObjectChanges: true,\n        showRawEffects: true,\n        showEvents: true\n      }\n    });\n    return {\n      transaction: parseTransaction(transaction)\n    };\n  }\n  async executeTransaction(options) {\n    const transaction = await __privateGet(this, _jsonRpcClient).executeTransactionBlock({\n      transactionBlock: options.transaction,\n      signature: options.signatures,\n      options: {\n        showEffects: true,\n        showEvents: true\n      }\n    });\n    return {\n      transaction: parseTransaction(transaction)\n    };\n  }\n  async dryRunTransaction(options) {\n    const tx = Transaction.from(options.transaction);\n    const result = await __privateGet(this, _jsonRpcClient).dryRunTransactionBlock({\n      transactionBlock: options.transaction\n    });\n    return {\n      transaction: {\n        digest: await tx.getDigest(),\n        // TODO: Effects aren't returned as bcs from dryRun, once we define structured effects we can return those instead\n        effects: result.effects,\n        signatures: [],\n        bcs: options.transaction\n      }\n    };\n  }\n  async getReferenceGasPrice() {\n    const referenceGasPrice = await __privateGet(this, _jsonRpcClient).getReferenceGasPrice();\n    return {\n      referenceGasPrice\n    };\n  }\n}\n_jsonRpcClient = new WeakMap();\nfunction parseObject(object) {\n  return {\n    id: object.objectId,\n    version: object.version,\n    digest: object.digest,\n    type: object.type,\n    content: object.bcs?.dataType === \"moveObject\" ? fromBase64(object.bcs.bcsBytes) : new Uint8Array(),\n    owner: parseOwner(object.owner)\n  };\n}\nfunction parseOwner(owner) {\n  if (owner === \"Immutable\") {\n    return {\n      $kind: \"Immutable\",\n      Immutable: true\n    };\n  }\n  if (\"ConsensusV2\" in owner) {\n    return {\n      $kind: \"ConsensusV2\",\n      ConsensusV2Owner: {\n        authenticator: {\n          $kind: \"SingleOwner\",\n          SingleOwner: owner.ConsensusV2.authenticator.SingleOwner\n        },\n        startVersion: owner.ConsensusV2.start_version\n      }\n    };\n  }\n  if (\"AddressOwner\" in owner) {\n    return {\n      $kind: \"AddressOwner\",\n      AddressOwner: owner.AddressOwner\n    };\n  }\n  if (\"ObjectOwner\" in owner) {\n    return {\n      $kind: \"ObjectOwner\",\n      ObjectOwner: owner.ObjectOwner\n    };\n  }\n  if (\"Shared\" in owner) {\n    return {\n      $kind: \"Shared\",\n      Shared: {\n        initialSharedVersion: owner.Shared.initial_shared_version\n      }\n    };\n  }\n  throw new Error(`Unknown owner type: ${JSON.stringify(owner)}`);\n}\nfunction parseTransaction(transaction) {\n  const parsedTx = bcs.SenderSignedData.parse(fromBase64(transaction.rawTransaction))[0];\n  return {\n    digest: transaction.digest,\n    effects: new Uint8Array(transaction.rawEffects),\n    bcs: bcs.TransactionData.serialize(parsedTx.intentMessage.value).toBytes(),\n    signatures: parsedTx.txSignatures\n  };\n}\nconst Balance = bcs.struct(\"Balance\", {\n  value: bcs.u64()\n});\nconst Coin = bcs.struct(\"Coin\", {\n  id: bcs.Address,\n  balance: Balance\n});\nexport {\n  JSONRpcTransport\n};\n//# sourceMappingURL=jsonRPC.js.map\n","import { isValidNamedPackage, isValidNamedType } from \"../../utils/move-registry.js\";\nimport { normalizeStructTag, parseStructTag } from \"../../utils/sui-types.js\";\nconst NAME_SEPARATOR = \"/\";\nfunction findNamesInTransaction(builder) {\n  const packages = /* @__PURE__ */ new Set();\n  const types = /* @__PURE__ */ new Set();\n  for (const command of builder.commands) {\n    if (command.MakeMoveVec?.type) {\n      getNamesFromTypeList([command.MakeMoveVec.type]).forEach((type) => {\n        types.add(type);\n      });\n      continue;\n    }\n    if (!(\"MoveCall\" in command)) continue;\n    const tx = command.MoveCall;\n    if (!tx) continue;\n    const pkg = tx.package.split(\"::\")[0];\n    if (hasMvrName(pkg)) {\n      if (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);\n      packages.add(pkg);\n    }\n    getNamesFromTypeList(tx.typeArguments ?? []).forEach((type) => {\n      types.add(type);\n    });\n  }\n  return {\n    packages: [...packages],\n    types: [...types]\n  };\n}\nfunction getFirstLevelNamedTypes(types) {\n  const results = /* @__PURE__ */ new Set();\n  for (const type of types) {\n    findMvrNames(type).forEach((name) => results.add(name));\n  }\n  return results;\n}\nfunction findMvrNames(type) {\n  const types = /* @__PURE__ */ new Set();\n  if (typeof type === \"string\" && !hasMvrName(type)) return types;\n  let tag = isStructTag(type) ? type : parseStructTag(type);\n  if (hasMvrName(tag.address)) types.add(`${tag.address}::${tag.module}::${tag.name}`);\n  for (const param of tag.typeParams) {\n    findMvrNames(param).forEach((name) => types.add(name));\n  }\n  return types;\n}\nfunction populateNamedTypesFromCache(types, typeCache) {\n  const composedTypes = {};\n  types.forEach((type) => {\n    const normalized = normalizeStructTag(findAndReplaceCachedTypes(type, typeCache));\n    composedTypes[type] = normalized;\n  });\n  return composedTypes;\n}\nfunction findAndReplaceCachedTypes(tag, typeCache) {\n  const type = isStructTag(tag) ? tag : parseStructTag(tag);\n  let typeTag = `${type.address}::${type.module}::${type.name}`;\n  const cacheHit = typeCache[typeTag];\n  return {\n    ...type,\n    address: cacheHit ? cacheHit.split(\"::\")[0] : type.address,\n    typeParams: type.typeParams.map((param) => findAndReplaceCachedTypes(param, typeCache))\n  };\n}\nfunction replaceNames(builder, cache) {\n  for (const command of builder.commands) {\n    if (command.MakeMoveVec?.type) {\n      if (!hasMvrName(command.MakeMoveVec.type)) continue;\n      if (!cache.types[command.MakeMoveVec.type])\n        throw new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);\n      command.MakeMoveVec.type = cache.types[command.MakeMoveVec.type];\n    }\n    const tx = command.MoveCall;\n    if (!tx) continue;\n    const nameParts = tx.package.split(\"::\");\n    const name = nameParts[0];\n    if (hasMvrName(name) && !cache.packages[name])\n      throw new Error(`No address found for package: ${name}`);\n    if (hasMvrName(name)) {\n      nameParts[0] = cache.packages[name];\n      tx.package = nameParts.join(\"::\");\n    }\n    const types = tx.typeArguments;\n    if (!types) continue;\n    for (let i = 0; i < types.length; i++) {\n      if (!hasMvrName(types[i])) continue;\n      if (!cache.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);\n      types[i] = cache.types[types[i]];\n    }\n    tx.typeArguments = types;\n  }\n}\nfunction batch(arr, size) {\n  const batches = [];\n  for (let i = 0; i < arr.length; i += size) {\n    batches.push(arr.slice(i, i + size));\n  }\n  return batches;\n}\nfunction getNamesFromTypeList(types) {\n  const names = /* @__PURE__ */ new Set();\n  for (const type of types) {\n    if (hasMvrName(type)) {\n      if (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);\n      names.add(type);\n    }\n  }\n  return names;\n}\nfunction hasMvrName(nameOrType) {\n  return nameOrType.includes(NAME_SEPARATOR) || nameOrType.includes(\"@\") || nameOrType.includes(\".sui\");\n}\nfunction isStructTag(type) {\n  return typeof type === \"object\" && \"address\" in type && \"module\" in type && \"name\" in type && \"typeParams\" in type;\n}\nexport {\n  batch,\n  findNamesInTransaction,\n  getFirstLevelNamedTypes,\n  populateNamedTypesFromCache,\n  replaceNames\n};\n//# sourceMappingURL=utils.js.map\n","import { bigint, object, parse, string } from \"valibot\";\nimport { bcs } from \"../../bcs/index.js\";\nimport { normalizeStructTag } from \"../../utils/sui-types.js\";\nimport { Commands } from \"../Commands.js\";\nimport { Inputs } from \"../Inputs.js\";\nimport { getClient } from \"../json-rpc-resolver.js\";\nconst COIN_WITH_BALANCE = \"CoinWithBalance\";\nconst SUI_TYPE = normalizeStructTag(\"0x2::sui::SUI\");\nfunction coinWithBalance({\n  type = SUI_TYPE,\n  balance,\n  useGasCoin = true\n}) {\n  return (tx) => {\n    tx.addIntentResolver(COIN_WITH_BALANCE, resolveCoinBalance);\n    const coinType = type === \"gas\" ? type : normalizeStructTag(type);\n    return tx.add(\n      Commands.Intent({\n        name: COIN_WITH_BALANCE,\n        inputs: {},\n        data: {\n          type: coinType === SUI_TYPE && useGasCoin ? \"gas\" : coinType,\n          balance: BigInt(balance)\n        }\n      })\n    );\n  };\n}\nconst CoinWithBalanceData = object({\n  type: string(),\n  balance: bigint()\n});\nasync function resolveCoinBalance(transactionData, buildOptions, next) {\n  const coinTypes = /* @__PURE__ */ new Set();\n  const totalByType = /* @__PURE__ */ new Map();\n  if (!transactionData.sender) {\n    throw new Error(\"Sender must be set to resolve CoinWithBalance\");\n  }\n  for (const command of transactionData.commands) {\n    if (command.$kind === \"$Intent\" && command.$Intent.name === COIN_WITH_BALANCE) {\n      const { type, balance } = parse(CoinWithBalanceData, command.$Intent.data);\n      if (type !== \"gas\" && balance > 0n) {\n        coinTypes.add(type);\n      }\n      totalByType.set(type, (totalByType.get(type) ?? 0n) + balance);\n    }\n  }\n  const usedIds = /* @__PURE__ */ new Set();\n  for (const input of transactionData.inputs) {\n    if (input.Object?.ImmOrOwnedObject) {\n      usedIds.add(input.Object.ImmOrOwnedObject.objectId);\n    }\n    if (input.UnresolvedObject?.objectId) {\n      usedIds.add(input.UnresolvedObject.objectId);\n    }\n  }\n  const coinsByType = /* @__PURE__ */ new Map();\n  const client = getClient(buildOptions);\n  await Promise.all(\n    [...coinTypes].map(async (coinType) => {\n      coinsByType.set(\n        coinType,\n        await getCoinsOfType({\n          coinType,\n          balance: totalByType.get(coinType),\n          client,\n          owner: transactionData.sender,\n          usedIds\n        })\n      );\n    })\n  );\n  const mergedCoins = /* @__PURE__ */ new Map();\n  mergedCoins.set(\"gas\", { $kind: \"GasCoin\", GasCoin: true });\n  for (const [index, transaction] of transactionData.commands.entries()) {\n    if (transaction.$kind !== \"$Intent\" || transaction.$Intent.name !== COIN_WITH_BALANCE) {\n      continue;\n    }\n    const { type, balance } = transaction.$Intent.data;\n    if (balance === 0n) {\n      transactionData.replaceCommand(\n        index,\n        Commands.MoveCall({ target: \"0x2::coin::zero\", typeArguments: [type] })\n      );\n      continue;\n    }\n    const commands = [];\n    if (!mergedCoins.has(type)) {\n      const [first, ...rest] = coinsByType.get(type).map(\n        (coin) => transactionData.addInput(\n          \"object\",\n          Inputs.ObjectRef({\n            objectId: coin.coinObjectId,\n            digest: coin.digest,\n            version: coin.version\n          })\n        )\n      );\n      if (rest.length > 0) {\n        commands.push(Commands.MergeCoins(first, rest));\n      }\n      mergedCoins.set(type, first);\n    }\n    commands.push(\n      Commands.SplitCoins(mergedCoins.get(type), [\n        transactionData.addInput(\"pure\", Inputs.Pure(bcs.u64().serialize(balance)))\n      ])\n    );\n    transactionData.replaceCommand(index, commands);\n    transactionData.mapArguments((arg) => {\n      if (arg.$kind === \"Result\" && arg.Result === index) {\n        return {\n          $kind: \"NestedResult\",\n          NestedResult: [index + commands.length - 1, 0]\n        };\n      }\n      return arg;\n    });\n  }\n  return next();\n}\nasync function getCoinsOfType({\n  coinType,\n  balance,\n  client,\n  owner,\n  usedIds\n}) {\n  let remainingBalance = balance;\n  const coins = [];\n  return loadMoreCoins();\n  async function loadMoreCoins(cursor = null) {\n    const { data, hasNextPage, nextCursor } = await client.getCoins({ owner, coinType, cursor });\n    const sortedCoins = data.sort((a, b) => Number(BigInt(b.balance) - BigInt(a.balance)));\n    for (const coin of sortedCoins) {\n      if (usedIds.has(coin.coinObjectId)) {\n        continue;\n      }\n      const coinBalance = BigInt(coin.balance);\n      coins.push(coin);\n      remainingBalance -= coinBalance;\n      if (remainingBalance <= 0) {\n        return coins;\n      }\n    }\n    if (hasNextPage) {\n      return loadMoreCoins(nextCursor);\n    }\n    throw new Error(`Not enough coins of type ${coinType} to satisfy requested balance`);\n  }\n}\nexport {\n  coinWithBalance\n};\n//# sourceMappingURL=CoinWithBalance.js.map\n","import { fromBase58, toBase64, toHex } from \"@mysten/bcs\";\nimport { Experimental_SuiClient } from \"../experimental/client.js\";\nimport { JSONRpcTransport } from \"../experimental/transports/jsonRPC.js\";\nimport { isTransaction } from \"../transactions/index.js\";\nimport {\n  isValidSuiAddress,\n  isValidSuiObjectId,\n  isValidTransactionDigest,\n  normalizeSuiAddress,\n  normalizeSuiObjectId\n} from \"../utils/sui-types.js\";\nimport { normalizeSuiNSName } from \"../utils/suins.js\";\nimport { SuiHTTPTransport } from \"./http-transport.js\";\nconst SUI_CLIENT_BRAND = Symbol.for(\"@mysten/SuiClient\");\nfunction isSuiClient(client) {\n  return typeof client === \"object\" && client !== null && client[SUI_CLIENT_BRAND] === true;\n}\nclass SuiClient extends Experimental_SuiClient {\n  /**\n   * Establish a connection to a Sui RPC endpoint\n   *\n   * @param options configuration options for the API Client\n   */\n  constructor(options) {\n    super({ network: options.network ?? \"unknown\" });\n    this.core = new JSONRpcTransport(this);\n    this.transport = options.transport ?? new SuiHTTPTransport({ url: options.url });\n  }\n  get [SUI_CLIENT_BRAND]() {\n    return true;\n  }\n  async getRpcApiVersion() {\n    const resp = await this.transport.request({\n      method: \"rpc.discover\",\n      params: []\n    });\n    return resp.info.version;\n  }\n  /**\n   * Get all Coin<`coin_type`> objects owned by an address.\n   */\n  async getCoins(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.transport.request({\n      method: \"suix_getCoins\",\n      params: [input.owner, input.coinType, input.cursor, input.limit]\n    });\n  }\n  /**\n   * Get all Coin objects owned by an address.\n   */\n  async getAllCoins(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.transport.request({\n      method: \"suix_getAllCoins\",\n      params: [input.owner, input.cursor, input.limit]\n    });\n  }\n  /**\n   * Get the total coin balance for one coin type, owned by the address owner.\n   */\n  async getBalance(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.transport.request({\n      method: \"suix_getBalance\",\n      params: [input.owner, input.coinType]\n    });\n  }\n  /**\n   * Get the total coin balance for all coin types, owned by the address owner.\n   */\n  async getAllBalances(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.transport.request({ method: \"suix_getAllBalances\", params: [input.owner] });\n  }\n  /**\n   * Fetch CoinMetadata for a given coin type\n   */\n  async getCoinMetadata(input) {\n    return await this.transport.request({\n      method: \"suix_getCoinMetadata\",\n      params: [input.coinType]\n    });\n  }\n  /**\n   *  Fetch total supply for a coin\n   */\n  async getTotalSupply(input) {\n    return await this.transport.request({\n      method: \"suix_getTotalSupply\",\n      params: [input.coinType]\n    });\n  }\n  /**\n   * Invoke any RPC method\n   * @param method the method to be invoked\n   * @param args the arguments to be passed to the RPC request\n   */\n  async call(method, params) {\n    return await this.transport.request({ method, params });\n  }\n  /**\n   * Get Move function argument types like read, write and full access\n   */\n  async getMoveFunctionArgTypes(input) {\n    return await this.transport.request({\n      method: \"sui_getMoveFunctionArgTypes\",\n      params: [input.package, input.module, input.function]\n    });\n  }\n  /**\n   * Get a map from module name to\n   * structured representations of Move modules\n   */\n  async getNormalizedMoveModulesByPackage(input) {\n    return await this.transport.request({\n      method: \"sui_getNormalizedMoveModulesByPackage\",\n      params: [input.package]\n    });\n  }\n  /**\n   * Get a structured representation of Move module\n   */\n  async getNormalizedMoveModule(input) {\n    return await this.transport.request({\n      method: \"sui_getNormalizedMoveModule\",\n      params: [input.package, input.module]\n    });\n  }\n  /**\n   * Get a structured representation of Move function\n   */\n  async getNormalizedMoveFunction(input) {\n    return await this.transport.request({\n      method: \"sui_getNormalizedMoveFunction\",\n      params: [input.package, input.module, input.function]\n    });\n  }\n  /**\n   * Get a structured representation of Move struct\n   */\n  async getNormalizedMoveStruct(input) {\n    return await this.transport.request({\n      method: \"sui_getNormalizedMoveStruct\",\n      params: [input.package, input.module, input.struct]\n    });\n  }\n  /**\n   * Get all objects owned by an address\n   */\n  async getOwnedObjects(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.transport.request({\n      method: \"suix_getOwnedObjects\",\n      params: [\n        input.owner,\n        {\n          filter: input.filter,\n          options: input.options\n        },\n        input.cursor,\n        input.limit\n      ]\n    });\n  }\n  /**\n   * Get details about an object\n   */\n  async getObject(input) {\n    if (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {\n      throw new Error(\"Invalid Sui Object id\");\n    }\n    return await this.transport.request({\n      method: \"sui_getObject\",\n      params: [input.id, input.options]\n    });\n  }\n  async tryGetPastObject(input) {\n    return await this.transport.request({\n      method: \"sui_tryGetPastObject\",\n      params: [input.id, input.version, input.options]\n    });\n  }\n  /**\n   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail\n   */\n  async multiGetObjects(input) {\n    input.ids.forEach((id) => {\n      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n        throw new Error(`Invalid Sui Object id ${id}`);\n      }\n    });\n    const hasDuplicates = input.ids.length !== new Set(input.ids).size;\n    if (hasDuplicates) {\n      throw new Error(`Duplicate object ids in batch call ${input.ids}`);\n    }\n    return await this.transport.request({\n      method: \"sui_multiGetObjects\",\n      params: [input.ids, input.options]\n    });\n  }\n  /**\n   * Get transaction blocks for a given query criteria\n   */\n  async queryTransactionBlocks(input) {\n    return await this.transport.request({\n      method: \"suix_queryTransactionBlocks\",\n      params: [\n        {\n          filter: input.filter,\n          options: input.options\n        },\n        input.cursor,\n        input.limit,\n        (input.order || \"descending\") === \"descending\"\n      ]\n    });\n  }\n  async getTransactionBlock(input) {\n    if (!isValidTransactionDigest(input.digest)) {\n      throw new Error(\"Invalid Transaction digest\");\n    }\n    return await this.transport.request({\n      method: \"sui_getTransactionBlock\",\n      params: [input.digest, input.options]\n    });\n  }\n  async multiGetTransactionBlocks(input) {\n    input.digests.forEach((d) => {\n      if (!isValidTransactionDigest(d)) {\n        throw new Error(`Invalid Transaction digest ${d}`);\n      }\n    });\n    const hasDuplicates = input.digests.length !== new Set(input.digests).size;\n    if (hasDuplicates) {\n      throw new Error(`Duplicate digests in batch call ${input.digests}`);\n    }\n    return await this.transport.request({\n      method: \"sui_multiGetTransactionBlocks\",\n      params: [input.digests, input.options]\n    });\n  }\n  async executeTransactionBlock({\n    transactionBlock,\n    signature,\n    options,\n    requestType\n  }) {\n    const result = await this.transport.request({\n      method: \"sui_executeTransactionBlock\",\n      params: [\n        typeof transactionBlock === \"string\" ? transactionBlock : toBase64(transactionBlock),\n        Array.isArray(signature) ? signature : [signature],\n        options\n      ]\n    });\n    if (requestType === \"WaitForLocalExecution\") {\n      try {\n        await this.waitForTransaction({\n          digest: result.digest\n        });\n      } catch (_) {\n      }\n    }\n    return result;\n  }\n  async signAndExecuteTransaction({\n    transaction,\n    signer,\n    ...input\n  }) {\n    let transactionBytes;\n    if (transaction instanceof Uint8Array) {\n      transactionBytes = transaction;\n    } else {\n      transaction.setSenderIfNotSet(signer.toSuiAddress());\n      transactionBytes = await transaction.build({ client: this });\n    }\n    const { signature, bytes } = await signer.signTransaction(transactionBytes);\n    return this.executeTransactionBlock({\n      transactionBlock: bytes,\n      signature,\n      ...input\n    });\n  }\n  /**\n   * Get total number of transactions\n   */\n  async getTotalTransactionBlocks() {\n    const resp = await this.transport.request({\n      method: \"sui_getTotalTransactionBlocks\",\n      params: []\n    });\n    return BigInt(resp);\n  }\n  /**\n   * Getting the reference gas price for the network\n   */\n  async getReferenceGasPrice() {\n    const resp = await this.transport.request({\n      method: \"suix_getReferenceGasPrice\",\n      params: []\n    });\n    return BigInt(resp);\n  }\n  /**\n   * Return the delegated stakes for an address\n   */\n  async getStakes(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.transport.request({ method: \"suix_getStakes\", params: [input.owner] });\n  }\n  /**\n   * Return the delegated stakes queried by id.\n   */\n  async getStakesByIds(input) {\n    input.stakedSuiIds.forEach((id) => {\n      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n        throw new Error(`Invalid Sui Stake id ${id}`);\n      }\n    });\n    return await this.transport.request({\n      method: \"suix_getStakesByIds\",\n      params: [input.stakedSuiIds]\n    });\n  }\n  /**\n   * Return the latest system state content.\n   */\n  async getLatestSuiSystemState() {\n    return await this.transport.request({ method: \"suix_getLatestSuiSystemState\", params: [] });\n  }\n  /**\n   * Get events for a given query criteria\n   */\n  async queryEvents(input) {\n    return await this.transport.request({\n      method: \"suix_queryEvents\",\n      params: [\n        input.query,\n        input.cursor,\n        input.limit,\n        (input.order || \"descending\") === \"descending\"\n      ]\n    });\n  }\n  /**\n   * Subscribe to get notifications whenever an event matching the filter occurs\n   *\n   * @deprecated\n   */\n  async subscribeEvent(input) {\n    return this.transport.subscribe({\n      method: \"suix_subscribeEvent\",\n      unsubscribe: \"suix_unsubscribeEvent\",\n      params: [input.filter],\n      onMessage: input.onMessage\n    });\n  }\n  /**\n   * @deprecated\n   */\n  async subscribeTransaction(input) {\n    return this.transport.subscribe({\n      method: \"suix_subscribeTransaction\",\n      unsubscribe: \"suix_unsubscribeTransaction\",\n      params: [input.filter],\n      onMessage: input.onMessage\n    });\n  }\n  /**\n   * Runs the transaction block in dev-inspect mode. Which allows for nearly any\n   * transaction (or Move call) with any arguments. Detailed results are\n   * provided, including both the transaction effects and any return values.\n   */\n  async devInspectTransactionBlock(input) {\n    let devInspectTxBytes;\n    if (isTransaction(input.transactionBlock)) {\n      input.transactionBlock.setSenderIfNotSet(input.sender);\n      devInspectTxBytes = toBase64(\n        await input.transactionBlock.build({\n          client: this,\n          onlyTransactionKind: true\n        })\n      );\n    } else if (typeof input.transactionBlock === \"string\") {\n      devInspectTxBytes = input.transactionBlock;\n    } else if (input.transactionBlock instanceof Uint8Array) {\n      devInspectTxBytes = toBase64(input.transactionBlock);\n    } else {\n      throw new Error(\"Unknown transaction block format.\");\n    }\n    return await this.transport.request({\n      method: \"sui_devInspectTransactionBlock\",\n      params: [input.sender, devInspectTxBytes, input.gasPrice?.toString(), input.epoch]\n    });\n  }\n  /**\n   * Dry run a transaction block and return the result.\n   */\n  async dryRunTransactionBlock(input) {\n    return await this.transport.request({\n      method: \"sui_dryRunTransactionBlock\",\n      params: [\n        typeof input.transactionBlock === \"string\" ? input.transactionBlock : toBase64(input.transactionBlock)\n      ]\n    });\n  }\n  /**\n   * Return the list of dynamic field objects owned by an object\n   */\n  async getDynamicFields(input) {\n    if (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) {\n      throw new Error(\"Invalid Sui Object id\");\n    }\n    return await this.transport.request({\n      method: \"suix_getDynamicFields\",\n      params: [input.parentId, input.cursor, input.limit]\n    });\n  }\n  /**\n   * Return the dynamic field object information for a specified object\n   */\n  async getDynamicFieldObject(input) {\n    return await this.transport.request({\n      method: \"suix_getDynamicFieldObject\",\n      params: [input.parentId, input.name]\n    });\n  }\n  /**\n   * Get the sequence number of the latest checkpoint that has been executed\n   */\n  async getLatestCheckpointSequenceNumber() {\n    const resp = await this.transport.request({\n      method: \"sui_getLatestCheckpointSequenceNumber\",\n      params: []\n    });\n    return String(resp);\n  }\n  /**\n   * Returns information about a given checkpoint\n   */\n  async getCheckpoint(input) {\n    return await this.transport.request({ method: \"sui_getCheckpoint\", params: [input.id] });\n  }\n  /**\n   * Returns historical checkpoints paginated\n   */\n  async getCheckpoints(input) {\n    return await this.transport.request({\n      method: \"sui_getCheckpoints\",\n      params: [input.cursor, input?.limit, input.descendingOrder]\n    });\n  }\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getCommitteeInfo(input) {\n    return await this.transport.request({\n      method: \"suix_getCommitteeInfo\",\n      params: [input?.epoch]\n    });\n  }\n  async getNetworkMetrics() {\n    return await this.transport.request({ method: \"suix_getNetworkMetrics\", params: [] });\n  }\n  async getAddressMetrics() {\n    return await this.transport.request({ method: \"suix_getLatestAddressMetrics\", params: [] });\n  }\n  async getEpochMetrics(input) {\n    return await this.transport.request({\n      method: \"suix_getEpochMetrics\",\n      params: [input?.cursor, input?.limit, input?.descendingOrder]\n    });\n  }\n  async getAllEpochAddressMetrics(input) {\n    return await this.transport.request({\n      method: \"suix_getAllEpochAddressMetrics\",\n      params: [input?.descendingOrder]\n    });\n  }\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getEpochs(input) {\n    return await this.transport.request({\n      method: \"suix_getEpochs\",\n      params: [input?.cursor, input?.limit, input?.descendingOrder]\n    });\n  }\n  /**\n   * Returns list of top move calls by usage\n   */\n  async getMoveCallMetrics() {\n    return await this.transport.request({ method: \"suix_getMoveCallMetrics\", params: [] });\n  }\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getCurrentEpoch() {\n    return await this.transport.request({ method: \"suix_getCurrentEpoch\", params: [] });\n  }\n  /**\n   * Return the Validators APYs\n   */\n  async getValidatorsApy() {\n    return await this.transport.request({ method: \"suix_getValidatorsApy\", params: [] });\n  }\n  // TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.\n  async getChainIdentifier() {\n    const checkpoint = await this.getCheckpoint({ id: \"0\" });\n    const bytes = fromBase58(checkpoint.digest);\n    return toHex(bytes.slice(0, 4));\n  }\n  async resolveNameServiceAddress(input) {\n    return await this.transport.request({\n      method: \"suix_resolveNameServiceAddress\",\n      params: [input.name]\n    });\n  }\n  async resolveNameServiceNames({\n    format = \"dot\",\n    ...input\n  }) {\n    const { nextCursor, hasNextPage, data } = await this.transport.request({\n      method: \"suix_resolveNameServiceNames\",\n      params: [input.address, input.cursor, input.limit]\n    });\n    return {\n      hasNextPage,\n      nextCursor,\n      data: data.map((name) => normalizeSuiNSName(name, format))\n    };\n  }\n  async getProtocolConfig(input) {\n    return await this.transport.request({\n      method: \"sui_getProtocolConfig\",\n      params: [input?.version]\n    });\n  }\n  /**\n   * Wait for a transaction block result to be available over the API.\n   * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to\n   * be available via the API.\n   * This currently polls the `getTransactionBlock` API to check for the transaction.\n   */\n  async waitForTransaction({\n    signal,\n    timeout = 60 * 1e3,\n    pollInterval = 2 * 1e3,\n    ...input\n  }) {\n    const timeoutSignal = AbortSignal.timeout(timeout);\n    const timeoutPromise = new Promise((_, reject) => {\n      timeoutSignal.addEventListener(\"abort\", () => reject(timeoutSignal.reason));\n    });\n    timeoutPromise.catch(() => {\n    });\n    while (!timeoutSignal.aborted) {\n      signal?.throwIfAborted();\n      try {\n        return await this.getTransactionBlock(input);\n      } catch (e) {\n        await Promise.race([\n          new Promise((resolve) => setTimeout(resolve, pollInterval)),\n          timeoutPromise\n        ]);\n      }\n    }\n    timeoutSignal.throwIfAborted();\n    throw new Error(\"Unexpected error while waiting for transaction block.\");\n  }\n  experimental_asClientExtension() {\n    return {\n      name: \"jsonRPC\",\n      register: () => {\n        return this;\n      }\n    };\n  }\n}\nexport {\n  SuiClient,\n  isSuiClient\n};\n//# sourceMappingURL=client.js.map\n","/*\r\n *      bignumber.js v9.2.1\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\nvar\r\n  isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n  mathceil = Math.ceil,\r\n  mathfloor = Math.floor,\r\n\r\n  bignumberError = '[BigNumber Error] ',\r\n  tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n  BASE = 1e14,\r\n  LOG_BASE = 14,\r\n  MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n  // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n  POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n  SQRT_BASE = 1e7,\r\n\r\n  // EDITABLE\r\n  // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n  // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n  MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n/*\r\n * Create and return a BigNumber constructor.\r\n */\r\nfunction clone(configObject) {\r\n  var div, convertBase, parseNumeric,\r\n    P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n    ONE = new BigNumber(1),\r\n\r\n\r\n    //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n    // The default values below must be integers within the inclusive ranges stated.\r\n    // The values can also be changed at run-time using BigNumber.set.\r\n\r\n    // The maximum number of decimal places for operations involving division.\r\n    DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n    // The rounding mode used when rounding to the above decimal places, and when using\r\n    // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n    // UP         0 Away from zero.\r\n    // DOWN       1 Towards zero.\r\n    // CEIL       2 Towards +Infinity.\r\n    // FLOOR      3 Towards -Infinity.\r\n    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n    ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n    // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n    // The exponent value at and beneath which toString returns exponential notation.\r\n    // Number type: -7\r\n    TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n    // The exponent value at and above which toString returns exponential notation.\r\n    // Number type: 21\r\n    TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n    // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n    // The minimum exponent value, beneath which underflow to zero occurs.\r\n    // Number type: -324  (5e-324)\r\n    MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n    // The maximum exponent value, above which overflow to Infinity occurs.\r\n    // Number type:  308  (1.7976931348623157e+308)\r\n    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n    MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n    // Whether to use cryptographically-secure random number generation, if available.\r\n    CRYPTO = false,                          // true or false\r\n\r\n    // The modulo mode used when calculating the modulus: a mod n.\r\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n    // The remainder (r) is calculated as: r = a - n * q.\r\n    //\r\n    // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n    // DOWN      1 The remainder has the same sign as the dividend.\r\n    //             This modulo mode is commonly known as 'truncated division' and is\r\n    //             equivalent to (a % n) in JavaScript.\r\n    // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n    //             The remainder is always positive.\r\n    //\r\n    // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n    // modes are commonly used for the modulus operation.\r\n    // Although the other rounding modes can also be used, they may not give useful results.\r\n    MODULO_MODE = 1,                         // 0 to 9\r\n\r\n    // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n    // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n    POW_PRECISION = 0,                       // 0 to MAX\r\n\r\n    // The format specification used by the BigNumber.prototype.toFormat method.\r\n    FORMAT = {\r\n      prefix: '',\r\n      groupSize: 3,\r\n      secondaryGroupSize: 0,\r\n      groupSeparator: ',',\r\n      decimalSeparator: '.',\r\n      fractionGroupSize: 0,\r\n      fractionGroupSeparator: '\\xA0',        // non-breaking space\r\n      suffix: ''\r\n    },\r\n\r\n    // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n    // '-', '.', whitespace, or repeated character.\r\n    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n    ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',\r\n    alphabetHasNormalDecimalDigits = true;\r\n\r\n\r\n  //------------------------------------------------------------------------------------------\r\n\r\n\r\n  // CONSTRUCTOR\r\n\r\n\r\n  /*\r\n   * The BigNumber constructor and exported function.\r\n   * Create and return a new instance of a BigNumber object.\r\n   *\r\n   * v {number|string|BigNumber} A numeric value.\r\n   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n   */\r\n  function BigNumber(v, b) {\r\n    var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n      x = this;\r\n\r\n    // Enable constructor call without `new`.\r\n    if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n    if (b == null) {\r\n\r\n      if (v && v._isBigNumber === true) {\r\n        x.s = v.s;\r\n\r\n        if (!v.c || v.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n        } else if (v.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = v.e;\r\n          x.c = v.c.slice();\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n        // Use `1 / n` to handle minus zero also.\r\n        x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n        // Fast path for integers, where n < 2147483648 (2**31).\r\n        if (v === ~~v) {\r\n          for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n          if (e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else {\r\n            x.e = e;\r\n            x.c = [v];\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        str = String(v);\r\n      } else {\r\n\r\n        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n      }\r\n\r\n      // Decimal point?\r\n      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n      // Exponential form?\r\n      if ((i = str.search(/e/i)) > 0) {\r\n\r\n        // Determine exponent.\r\n        if (e < 0) e = i;\r\n        e += +str.slice(i + 1);\r\n        str = str.substring(0, i);\r\n      } else if (e < 0) {\r\n\r\n        // Integer.\r\n        e = str.length;\r\n      }\r\n\r\n    } else {\r\n\r\n      // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n      intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n      // Allow exponential notation to be used with base 10 argument, while\r\n      // also rounding to DECIMAL_PLACES as with other bases.\r\n      if (b == 10 && alphabetHasNormalDecimalDigits) {\r\n        x = new BigNumber(v);\r\n        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n      }\r\n\r\n      str = String(v);\r\n\r\n      if (isNum = typeof v == 'number') {\r\n\r\n        // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n          throw Error\r\n           (tooManyDigits + v);\r\n        }\r\n      } else {\r\n        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n      }\r\n\r\n      alphabet = ALPHABET.slice(0, b);\r\n      e = i = 0;\r\n\r\n      // Check that str is a valid base b number.\r\n      // Don't use RegExp, so alphabet can contain special characters.\r\n      for (len = str.length; i < len; i++) {\r\n        if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n          if (c == '.') {\r\n\r\n            // If '.' is not the first character and it has not be found before.\r\n            if (i > e) {\r\n              e = len;\r\n              continue;\r\n            }\r\n          } else if (!caseChanged) {\r\n\r\n            // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n            if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n              caseChanged = true;\r\n              i = -1;\r\n              e = 0;\r\n              continue;\r\n            }\r\n          }\r\n\r\n          return parseNumeric(x, String(v), isNum, b);\r\n        }\r\n      }\r\n\r\n      // Prevent later check for length on converted number.\r\n      isNum = false;\r\n      str = convertBase(str, b, 10, x.s);\r\n\r\n      // Decimal point?\r\n      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n      else e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n    if (str = str.slice(i, ++len)) {\r\n      len -= i;\r\n\r\n      // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n      if (isNum && BigNumber.DEBUG &&\r\n        len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n          throw Error\r\n           (tooManyDigits + (x.s * v));\r\n      }\r\n\r\n       // Overflow?\r\n      if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        x.c = x.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      } else {\r\n        x.e = e;\r\n        x.c = [];\r\n\r\n        // Transform base\r\n\r\n        // e is the base 10 exponent.\r\n        // i is where to slice str to get the first element of the coefficient array.\r\n        i = (e + 1) % LOG_BASE;\r\n        if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n        if (i < len) {\r\n          if (i) x.c.push(+str.slice(0, i));\r\n\r\n          for (len -= LOG_BASE; i < len;) {\r\n            x.c.push(+str.slice(i, i += LOG_BASE));\r\n          }\r\n\r\n          i = LOG_BASE - (str = str.slice(i)).length;\r\n        } else {\r\n          i -= len;\r\n        }\r\n\r\n        for (; i--; str += '0');\r\n        x.c.push(+str);\r\n      }\r\n    } else {\r\n\r\n      // Zero.\r\n      x.c = [x.e = 0];\r\n    }\r\n  }\r\n\r\n\r\n  // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n  BigNumber.clone = clone;\r\n\r\n  BigNumber.ROUND_UP = 0;\r\n  BigNumber.ROUND_DOWN = 1;\r\n  BigNumber.ROUND_CEIL = 2;\r\n  BigNumber.ROUND_FLOOR = 3;\r\n  BigNumber.ROUND_HALF_UP = 4;\r\n  BigNumber.ROUND_HALF_DOWN = 5;\r\n  BigNumber.ROUND_HALF_EVEN = 6;\r\n  BigNumber.ROUND_HALF_CEIL = 7;\r\n  BigNumber.ROUND_HALF_FLOOR = 8;\r\n  BigNumber.EUCLID = 9;\r\n\r\n\r\n  /*\r\n   * Configure infrequently-changing library-wide settings.\r\n   *\r\n   * Accept an object with the following optional properties (if the value of a property is\r\n   * a number, it must be an integer within the inclusive range stated):\r\n   *\r\n   *   DECIMAL_PLACES   {number}           0 to MAX\r\n   *   ROUNDING_MODE    {number}           0 to 8\r\n   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n   *   CRYPTO           {boolean}          true or false\r\n   *   MODULO_MODE      {number}           0 to 9\r\n   *   POW_PRECISION       {number}           0 to MAX\r\n   *   ALPHABET         {string}           A string of two or more unique characters which does\r\n   *                                       not contain '.'.\r\n   *   FORMAT           {object}           An object with some of the following properties:\r\n   *     prefix                 {string}\r\n   *     groupSize              {number}\r\n   *     secondaryGroupSize     {number}\r\n   *     groupSeparator         {string}\r\n   *     decimalSeparator       {string}\r\n   *     fractionGroupSize      {number}\r\n   *     fractionGroupSeparator {string}\r\n   *     suffix                 {string}\r\n   *\r\n   * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n   *\r\n   * E.g.\r\n   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n   *\r\n   * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n   *\r\n   * Return an object with the properties current values.\r\n   */\r\n  BigNumber.config = BigNumber.set = function (obj) {\r\n    var p, v;\r\n\r\n    if (obj != null) {\r\n\r\n      if (typeof obj == 'object') {\r\n\r\n        // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n        // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, MAX, p);\r\n          DECIMAL_PLACES = v;\r\n        }\r\n\r\n        // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n        // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, 8, p);\r\n          ROUNDING_MODE = v;\r\n        }\r\n\r\n        // EXPONENTIAL_AT {number|number[]}\r\n        // Integer, -MAX to MAX inclusive or\r\n        // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n        // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n          v = obj[p];\r\n          if (v && v.pop) {\r\n            intCheck(v[0], -MAX, 0, p);\r\n            intCheck(v[1], 0, MAX, p);\r\n            TO_EXP_NEG = v[0];\r\n            TO_EXP_POS = v[1];\r\n          } else {\r\n            intCheck(v, -MAX, MAX, p);\r\n            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n          }\r\n        }\r\n\r\n        // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n        // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n        // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n        if (obj.hasOwnProperty(p = 'RANGE')) {\r\n          v = obj[p];\r\n          if (v && v.pop) {\r\n            intCheck(v[0], -MAX, -1, p);\r\n            intCheck(v[1], 1, MAX, p);\r\n            MIN_EXP = v[0];\r\n            MAX_EXP = v[1];\r\n          } else {\r\n            intCheck(v, -MAX, MAX, p);\r\n            if (v) {\r\n              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' cannot be zero: ' + v);\r\n            }\r\n          }\r\n        }\r\n\r\n        // CRYPTO {boolean} true or false.\r\n        // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n        // '[BigNumber Error] crypto unavailable'\r\n        if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n          v = obj[p];\r\n          if (v === !!v) {\r\n            if (v) {\r\n              if (typeof crypto != 'undefined' && crypto &&\r\n               (crypto.getRandomValues || crypto.randomBytes)) {\r\n                CRYPTO = v;\r\n              } else {\r\n                CRYPTO = !v;\r\n                throw Error\r\n                 (bignumberError + 'crypto unavailable');\r\n              }\r\n            } else {\r\n              CRYPTO = v;\r\n            }\r\n          } else {\r\n            throw Error\r\n             (bignumberError + p + ' not true or false: ' + v);\r\n          }\r\n        }\r\n\r\n        // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n        // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, 9, p);\r\n          MODULO_MODE = v;\r\n        }\r\n\r\n        // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n        // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, MAX, p);\r\n          POW_PRECISION = v;\r\n        }\r\n\r\n        // FORMAT {object}\r\n        // '[BigNumber Error] FORMAT not an object: {v}'\r\n        if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n          v = obj[p];\r\n          if (typeof v == 'object') FORMAT = v;\r\n          else throw Error\r\n           (bignumberError + p + ' not an object: ' + v);\r\n        }\r\n\r\n        // ALPHABET {string}\r\n        // '[BigNumber Error] ALPHABET invalid: {v}'\r\n        if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n          v = obj[p];\r\n\r\n          // Disallow if less than two characters,\r\n          // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n          if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n            alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';\r\n            ALPHABET = v;\r\n          } else {\r\n            throw Error\r\n             (bignumberError + p + ' invalid: ' + v);\r\n          }\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Object expected: {v}'\r\n        throw Error\r\n         (bignumberError + 'Object expected: ' + obj);\r\n      }\r\n    }\r\n\r\n    return {\r\n      DECIMAL_PLACES: DECIMAL_PLACES,\r\n      ROUNDING_MODE: ROUNDING_MODE,\r\n      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n      RANGE: [MIN_EXP, MAX_EXP],\r\n      CRYPTO: CRYPTO,\r\n      MODULO_MODE: MODULO_MODE,\r\n      POW_PRECISION: POW_PRECISION,\r\n      FORMAT: FORMAT,\r\n      ALPHABET: ALPHABET\r\n    };\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if v is a BigNumber instance, otherwise return false.\r\n   *\r\n   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n   *\r\n   * v {any}\r\n   *\r\n   * '[BigNumber Error] Invalid BigNumber: {v}'\r\n   */\r\n  BigNumber.isBigNumber = function (v) {\r\n    if (!v || v._isBigNumber !== true) return false;\r\n    if (!BigNumber.DEBUG) return true;\r\n\r\n    var i, n,\r\n      c = v.c,\r\n      e = v.e,\r\n      s = v.s;\r\n\r\n    out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n        // If the first element is zero, the BigNumber value must be zero.\r\n        if (c[0] === 0) {\r\n          if (e === 0 && c.length === 1) return true;\r\n          break out;\r\n        }\r\n\r\n        // Calculate number of digits that c[0] should have, based on the exponent.\r\n        i = (e + 1) % LOG_BASE;\r\n        if (i < 1) i += LOG_BASE;\r\n\r\n        // Calculate number of digits of c[0].\r\n        //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n        if (String(c[0]).length == i) {\r\n\r\n          for (i = 0; i < c.length; i++) {\r\n            n = c[i];\r\n            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n          }\r\n\r\n          // Last element cannot be zero, unless it is the only element.\r\n          if (n !== 0) return true;\r\n        }\r\n      }\r\n\r\n    // Infinity/NaN\r\n    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n      return true;\r\n    }\r\n\r\n    throw Error\r\n      (bignumberError + 'Invalid BigNumber: ' + v);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.maximum = BigNumber.max = function () {\r\n    return maxOrMin(arguments, -1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.minimum = BigNumber.min = function () {\r\n    return maxOrMin(arguments, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n   * zeros are produced).\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n   * '[BigNumber Error] crypto unavailable'\r\n   */\r\n  BigNumber.random = (function () {\r\n    var pow2_53 = 0x20000000000000;\r\n\r\n    // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n    // Check if Math.random() produces more than 32 bits of randomness.\r\n    // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n    // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n    var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n     ? function () { return mathfloor(Math.random() * pow2_53); }\r\n     : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n       (Math.random() * 0x800000 | 0); };\r\n\r\n    return function (dp) {\r\n      var a, b, e, k, v,\r\n        i = 0,\r\n        c = [],\r\n        rand = new BigNumber(ONE);\r\n\r\n      if (dp == null) dp = DECIMAL_PLACES;\r\n      else intCheck(dp, 0, MAX);\r\n\r\n      k = mathceil(dp / LOG_BASE);\r\n\r\n      if (CRYPTO) {\r\n\r\n        // Browsers supporting crypto.getRandomValues.\r\n        if (crypto.getRandomValues) {\r\n\r\n          a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n          for (; i < k;) {\r\n\r\n            // 53 bits:\r\n            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n            // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n            //                                     11111 11111111 11111111\r\n            // 0x20000 is 2^21.\r\n            v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n            // Rejection sampling:\r\n            // 0 <= v < 9007199254740992\r\n            // Probability that v >= 9e15, is\r\n            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n            if (v >= 9e15) {\r\n              b = crypto.getRandomValues(new Uint32Array(2));\r\n              a[i] = b[0];\r\n              a[i + 1] = b[1];\r\n            } else {\r\n\r\n              // 0 <= v <= 8999999999999999\r\n              // 0 <= (v % 1e14) <= 99999999999999\r\n              c.push(v % 1e14);\r\n              i += 2;\r\n            }\r\n          }\r\n          i = k / 2;\r\n\r\n        // Node.js supporting crypto.randomBytes.\r\n        } else if (crypto.randomBytes) {\r\n\r\n          // buffer\r\n          a = crypto.randomBytes(k *= 7);\r\n\r\n          for (; i < k;) {\r\n\r\n            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n            // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n            // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n            // 0 <= v < 9007199254740992\r\n            v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n               (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n               (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n            if (v >= 9e15) {\r\n              crypto.randomBytes(7).copy(a, i);\r\n            } else {\r\n\r\n              // 0 <= (v % 1e14) <= 99999999999999\r\n              c.push(v % 1e14);\r\n              i += 7;\r\n            }\r\n          }\r\n          i = k / 7;\r\n        } else {\r\n          CRYPTO = false;\r\n          throw Error\r\n           (bignumberError + 'crypto unavailable');\r\n        }\r\n      }\r\n\r\n      // Use Math.random.\r\n      if (!CRYPTO) {\r\n\r\n        for (; i < k;) {\r\n          v = random53bitInt();\r\n          if (v < 9e15) c[i++] = v % 1e14;\r\n        }\r\n      }\r\n\r\n      k = c[--i];\r\n      dp %= LOG_BASE;\r\n\r\n      // Convert trailing digits to zeros according to dp.\r\n      if (k && dp) {\r\n        v = POWS_TEN[LOG_BASE - dp];\r\n        c[i] = mathfloor(k / v) * v;\r\n      }\r\n\r\n      // Remove trailing elements which are zero.\r\n      for (; c[i] === 0; c.pop(), i--);\r\n\r\n      // Zero?\r\n      if (i < 0) {\r\n        c = [e = 0];\r\n      } else {\r\n\r\n        // Remove leading elements which are zero and adjust exponent accordingly.\r\n        for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n        // Count the digits of the first element of c to determine leading zeros, and...\r\n        for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n        // adjust the exponent accordingly.\r\n        if (i < LOG_BASE) e -= LOG_BASE - i;\r\n      }\r\n\r\n      rand.e = e;\r\n      rand.c = c;\r\n      return rand;\r\n    };\r\n  })();\r\n\r\n\r\n   /*\r\n   * Return a BigNumber whose value is the sum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.sum = function () {\r\n    var i = 1,\r\n      args = arguments,\r\n      sum = new BigNumber(args[0]);\r\n    for (; i < args.length;) sum = sum.plus(args[i++]);\r\n    return sum;\r\n  };\r\n\r\n\r\n  // PRIVATE FUNCTIONS\r\n\r\n\r\n  // Called by BigNumber and BigNumber.prototype.toString.\r\n  convertBase = (function () {\r\n    var decimal = '0123456789';\r\n\r\n    /*\r\n     * Convert string of baseIn to an array of numbers of baseOut.\r\n     * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n     */\r\n    function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n      var j,\r\n        arr = [0],\r\n        arrL,\r\n        i = 0,\r\n        len = str.length;\r\n\r\n      for (; i < len;) {\r\n        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n        arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n        for (j = 0; j < arr.length; j++) {\r\n\r\n          if (arr[j] > baseOut - 1) {\r\n            if (arr[j + 1] == null) arr[j + 1] = 0;\r\n            arr[j + 1] += arr[j] / baseOut | 0;\r\n            arr[j] %= baseOut;\r\n          }\r\n        }\r\n      }\r\n\r\n      return arr.reverse();\r\n    }\r\n\r\n    // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n    // If the caller is toString, we are converting from base 10 to baseOut.\r\n    // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n    return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n      var alphabet, d, e, k, r, x, xc, y,\r\n        i = str.indexOf('.'),\r\n        dp = DECIMAL_PLACES,\r\n        rm = ROUNDING_MODE;\r\n\r\n      // Non-integer.\r\n      if (i >= 0) {\r\n        k = POW_PRECISION;\r\n\r\n        // Unlimited precision.\r\n        POW_PRECISION = 0;\r\n        str = str.replace('.', '');\r\n        y = new BigNumber(baseIn);\r\n        x = y.pow(str.length - i);\r\n        POW_PRECISION = k;\r\n\r\n        // Convert str as if an integer, then restore the fraction part by dividing the\r\n        // result by its base raised to a power.\r\n\r\n        y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n         10, baseOut, decimal);\r\n        y.e = y.c.length;\r\n      }\r\n\r\n      // Convert the number as integer.\r\n\r\n      xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n       ? (alphabet = ALPHABET, decimal)\r\n       : (alphabet = decimal, ALPHABET));\r\n\r\n      // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n      e = k = xc.length;\r\n\r\n      // Remove trailing zeros.\r\n      for (; xc[--k] == 0; xc.pop());\r\n\r\n      // Zero?\r\n      if (!xc[0]) return alphabet.charAt(0);\r\n\r\n      // Does str represent an integer? If so, no need for the division.\r\n      if (i < 0) {\r\n        --e;\r\n      } else {\r\n        x.c = xc;\r\n        x.e = e;\r\n\r\n        // The sign is needed for correct rounding.\r\n        x.s = sign;\r\n        x = div(x, y, dp, rm, baseOut);\r\n        xc = x.c;\r\n        r = x.r;\r\n        e = x.e;\r\n      }\r\n\r\n      // xc now represents str converted to baseOut.\r\n\r\n      // The index of the rounding digit.\r\n      d = e + dp + 1;\r\n\r\n      // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n      i = xc[d];\r\n\r\n      // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n      k = baseOut / 2;\r\n      r = r || d < 0 || xc[d + 1] != null;\r\n\r\n      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n            : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n      // If the index of the rounding digit is not greater than zero, or xc represents\r\n      // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n      // such as 0.00001.\r\n      if (d < 1 || !xc[0]) {\r\n\r\n        // 1^-dp or 0\r\n        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n      } else {\r\n\r\n        // Truncate xc to the required number of decimal places.\r\n        xc.length = d;\r\n\r\n        // Round up?\r\n        if (r) {\r\n\r\n          // Rounding up may mean the previous digit has to be rounded up and so on.\r\n          for (--baseOut; ++xc[--d] > baseOut;) {\r\n            xc[d] = 0;\r\n\r\n            if (!d) {\r\n              ++e;\r\n              xc = [1].concat(xc);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Determine trailing zeros.\r\n        for (k = xc.length; !xc[--k];);\r\n\r\n        // E.g. [4, 11, 15] becomes 4bf.\r\n        for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n        // Add leading zeros, decimal point and trailing zeros as required.\r\n        str = toFixedPoint(str, e, alphabet.charAt(0));\r\n      }\r\n\r\n      // The caller will add the sign.\r\n      return str;\r\n    };\r\n  })();\r\n\r\n\r\n  // Perform division in the specified base. Called by div and convertBase.\r\n  div = (function () {\r\n\r\n    // Assume non-zero x and k.\r\n    function multiply(x, k, base) {\r\n      var m, temp, xlo, xhi,\r\n        carry = 0,\r\n        i = x.length,\r\n        klo = k % SQRT_BASE,\r\n        khi = k / SQRT_BASE | 0;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        xlo = x[i] % SQRT_BASE;\r\n        xhi = x[i] / SQRT_BASE | 0;\r\n        m = khi * xlo + xhi * klo;\r\n        temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n        x[i] = temp % base;\r\n      }\r\n\r\n      if (carry) x = [carry].concat(x);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, cmp;\r\n\r\n      if (aL != bL) {\r\n        cmp = aL > bL ? 1 : -1;\r\n      } else {\r\n\r\n        for (i = cmp = 0; i < aL; i++) {\r\n\r\n          if (a[i] != b[i]) {\r\n            cmp = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return cmp;\r\n    }\r\n\r\n    function subtract(a, b, aL, base) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * base + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n    }\r\n\r\n    // x: dividend, y: divisor.\r\n    return function (x, y, dp, rm, base) {\r\n      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n        yL, yz,\r\n        s = x.s == y.s ? 1 : -1,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n        return new BigNumber(\r\n\r\n         // Return NaN if either NaN, or both Infinity or 0.\r\n         !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\r\n          xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n       );\r\n      }\r\n\r\n      q = new BigNumber(s);\r\n      qc = q.c = [];\r\n      e = x.e - y.e;\r\n      s = dp + e + 1;\r\n\r\n      if (!base) {\r\n        base = BASE;\r\n        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n        s = s / LOG_BASE | 0;\r\n      }\r\n\r\n      // Result exponent may be one less then the current value of e.\r\n      // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n      for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n      if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n      if (s < 0) {\r\n        qc.push(1);\r\n        more = true;\r\n      } else {\r\n        xL = xc.length;\r\n        yL = yc.length;\r\n        i = 0;\r\n        s += 2;\r\n\r\n        // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n        n = mathfloor(base / (yc[0] + 1));\r\n\r\n        // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n        // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n        if (n > 1) {\r\n          yc = multiply(yc, n, base);\r\n          xc = multiply(xc, n, base);\r\n          yL = yc.length;\r\n          xL = xc.length;\r\n        }\r\n\r\n        xi = yL;\r\n        rem = xc.slice(0, yL);\r\n        remL = rem.length;\r\n\r\n        // Add zeros to make remainder as long as divisor.\r\n        for (; remL < yL; rem[remL++] = 0);\r\n        yz = yc.slice();\r\n        yz = [0].concat(yz);\r\n        yc0 = yc[0];\r\n        if (yc[1] >= base / 2) yc0++;\r\n        // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n        // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n        do {\r\n          n = 0;\r\n\r\n          // Compare divisor and remainder.\r\n          cmp = compare(yc, rem, yL, remL);\r\n\r\n          // If divisor < remainder.\r\n          if (cmp < 0) {\r\n\r\n            // Calculate trial digit, n.\r\n\r\n            rem0 = rem[0];\r\n            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n            // n is how many times the divisor goes into the current remainder.\r\n            n = mathfloor(rem0 / yc0);\r\n\r\n            //  Algorithm:\r\n            //  product = divisor multiplied by trial digit (n).\r\n            //  Compare product and remainder.\r\n            //  If product is greater than remainder:\r\n            //    Subtract divisor from product, decrement trial digit.\r\n            //  Subtract product from remainder.\r\n            //  If product was less than remainder at the last compare:\r\n            //    Compare new remainder and divisor.\r\n            //    If remainder is greater than divisor:\r\n            //      Subtract divisor from remainder, increment trial digit.\r\n\r\n            if (n > 1) {\r\n\r\n              // n may be > base only when base is 3.\r\n              if (n >= base) n = base - 1;\r\n\r\n              // product = divisor * trial digit.\r\n              prod = multiply(yc, n, base);\r\n              prodL = prod.length;\r\n              remL = rem.length;\r\n\r\n              // Compare product and remainder.\r\n              // If product > remainder then trial digit n too high.\r\n              // n is 1 too high about 5% of the time, and is not known to have\r\n              // ever been more than 1 too high.\r\n              while (compare(prod, rem, prodL, remL) == 1) {\r\n                n--;\r\n\r\n                // Subtract divisor from product.\r\n                subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                prodL = prod.length;\r\n                cmp = 1;\r\n              }\r\n            } else {\r\n\r\n              // n is 0 or 1, cmp is -1.\r\n              // If n is 0, there is no need to compare yc and rem again below,\r\n              // so change cmp to 1 to avoid it.\r\n              // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n              if (n == 0) {\r\n\r\n                // divisor < remainder, so n must be at least 1.\r\n                cmp = n = 1;\r\n              }\r\n\r\n              // product = divisor\r\n              prod = yc.slice();\r\n              prodL = prod.length;\r\n            }\r\n\r\n            if (prodL < remL) prod = [0].concat(prod);\r\n\r\n            // Subtract product from remainder.\r\n            subtract(rem, prod, remL, base);\r\n            remL = rem.length;\r\n\r\n             // If product was < remainder.\r\n            if (cmp == -1) {\r\n\r\n              // Compare divisor and new remainder.\r\n              // If divisor < new remainder, subtract divisor from remainder.\r\n              // Trial digit n too low.\r\n              // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n              while (compare(yc, rem, yL, remL) < 1) {\r\n                n++;\r\n\r\n                // Subtract divisor from remainder.\r\n                subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                remL = rem.length;\r\n              }\r\n            }\r\n          } else if (cmp === 0) {\r\n            n++;\r\n            rem = [0];\r\n          } // else cmp === 1 and n will be 0\r\n\r\n          // Add the next digit, n, to the result array.\r\n          qc[i++] = n;\r\n\r\n          // Update the remainder.\r\n          if (rem[0]) {\r\n            rem[remL++] = xc[xi] || 0;\r\n          } else {\r\n            rem = [xc[xi]];\r\n            remL = 1;\r\n          }\r\n        } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n        more = rem[0] != null;\r\n\r\n        // Leading zero?\r\n        if (!qc[0]) qc.splice(0, 1);\r\n      }\r\n\r\n      if (base == BASE) {\r\n\r\n        // To calculate q.e, first get the number of digits of qc[0].\r\n        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n      // Caller is convertBase.\r\n      } else {\r\n        q.e = e;\r\n        q.r = +more;\r\n      }\r\n\r\n      return q;\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n   * notation rounded to the specified decimal places or significant digits.\r\n   *\r\n   * n: a BigNumber.\r\n   * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n   * rm: the rounding mode.\r\n   * id: 1 (toExponential) or 2 (toPrecision).\r\n   */\r\n  function format(n, i, rm, id) {\r\n    var c0, e, ne, len, str;\r\n\r\n    if (rm == null) rm = ROUNDING_MODE;\r\n    else intCheck(rm, 0, 8);\r\n\r\n    if (!n.c) return n.toString();\r\n\r\n    c0 = n.c[0];\r\n    ne = n.e;\r\n\r\n    if (i == null) {\r\n      str = coeffToString(n.c);\r\n      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n       ? toExponential(str, ne)\r\n       : toFixedPoint(str, ne, '0');\r\n    } else {\r\n      n = round(new BigNumber(n), i, rm);\r\n\r\n      // n.e may have changed if the value was rounded up.\r\n      e = n.e;\r\n\r\n      str = coeffToString(n.c);\r\n      len = str.length;\r\n\r\n      // toPrecision returns exponential notation if the number of significant digits\r\n      // specified is less than the number of digits necessary to represent the integer\r\n      // part of the value in fixed-point notation.\r\n\r\n      // Exponential notation.\r\n      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n        // Append zeros?\r\n        for (; len < i; str += '0', len++);\r\n        str = toExponential(str, e);\r\n\r\n      // Fixed-point notation.\r\n      } else {\r\n        i -= ne;\r\n        str = toFixedPoint(str, e, '0');\r\n\r\n        // Append zeros?\r\n        if (e + 1 > len) {\r\n          if (--i > 0) for (str += '.'; i--; str += '0');\r\n        } else {\r\n          i += e - len;\r\n          if (i > 0) {\r\n            if (e + 1 == len) str += '.';\r\n            for (; i--; str += '0');\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return n.s < 0 && c0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Handle BigNumber.max and BigNumber.min.\r\n  // If any number is NaN, return NaN.\r\n  function maxOrMin(args, n) {\r\n    var k, y,\r\n      i = 1,\r\n      x = new BigNumber(args[0]);\r\n\r\n    for (; i < args.length; i++) {\r\n      y = new BigNumber(args[i]);\r\n      if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {\r\n        x = y;\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n   * Called by minus, plus and times.\r\n   */\r\n  function normalise(n, c, e) {\r\n    var i = 1,\r\n      j = c.length;\r\n\r\n     // Remove trailing zeros.\r\n    for (; !c[--j]; c.pop());\r\n\r\n    // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n    for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n    // Overflow?\r\n    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n      // Infinity.\r\n      n.c = n.e = null;\r\n\r\n    // Underflow?\r\n    } else if (e < MIN_EXP) {\r\n\r\n      // Zero.\r\n      n.c = [n.e = 0];\r\n    } else {\r\n      n.e = e;\r\n      n.c = c;\r\n    }\r\n\r\n    return n;\r\n  }\r\n\r\n\r\n  // Handle values that fail the validity test in BigNumber.\r\n  parseNumeric = (function () {\r\n    var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n      dotAfter = /^([^.]+)\\.$/,\r\n      dotBefore = /^\\.([^.]+)$/,\r\n      isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n      whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n    return function (x, str, isNum, b) {\r\n      var base,\r\n        s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n      // No exception on Infinity or NaN.\r\n      if (isInfinityOrNaN.test(s)) {\r\n        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n      } else {\r\n        if (!isNum) {\r\n\r\n          // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n          s = s.replace(basePrefix, function (m, p1, p2) {\r\n            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n            return !b || b == base ? p1 : m;\r\n          });\r\n\r\n          if (b) {\r\n            base = b;\r\n\r\n            // E.g. '1.' to '1', '.1' to '0.1'\r\n            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n          }\r\n\r\n          if (str != s) return new BigNumber(s, base);\r\n        }\r\n\r\n        // '[BigNumber Error] Not a number: {n}'\r\n        // '[BigNumber Error] Not a base {b} number: {n}'\r\n        if (BigNumber.DEBUG) {\r\n          throw Error\r\n            (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n        }\r\n\r\n        // NaN\r\n        x.s = null;\r\n      }\r\n\r\n      x.c = x.e = null;\r\n    }\r\n  })();\r\n\r\n\r\n  /*\r\n   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n   * If r is truthy, it is known that there are more digits after the rounding digit.\r\n   */\r\n  function round(x, sd, rm, r) {\r\n    var d, i, j, k, n, ni, rd,\r\n      xc = x.c,\r\n      pows10 = POWS_TEN;\r\n\r\n    // if x is not Infinity or NaN...\r\n    if (xc) {\r\n\r\n      // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n      // ni is the index of n within x.c.\r\n      // d is the number of digits of n.\r\n      // i is the index of rd within n including leading zeros.\r\n      // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n      out: {\r\n\r\n        // Get the number of digits of the first element of xc.\r\n        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n        i = sd - d;\r\n\r\n        // If the rounding digit is in the first element of xc...\r\n        if (i < 0) {\r\n          i += LOG_BASE;\r\n          j = sd;\r\n          n = xc[ni = 0];\r\n\r\n          // Get the rounding digit at index j of n.\r\n          rd = mathfloor(n / pows10[d - j - 1] % 10);\r\n        } else {\r\n          ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n          if (ni >= xc.length) {\r\n\r\n            if (r) {\r\n\r\n              // Needed by sqrt.\r\n              for (; xc.length <= ni; xc.push(0));\r\n              n = rd = 0;\r\n              d = 1;\r\n              i %= LOG_BASE;\r\n              j = i - LOG_BASE + 1;\r\n            } else {\r\n              break out;\r\n            }\r\n          } else {\r\n            n = k = xc[ni];\r\n\r\n            // Get the number of digits of n.\r\n            for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n            // Get the index of rd within n.\r\n            i %= LOG_BASE;\r\n\r\n            // Get the index of rd within n, adjusted for leading zeros.\r\n            // The number of leading zeros of n is given by LOG_BASE - d.\r\n            j = i - LOG_BASE + d;\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);\r\n          }\r\n        }\r\n\r\n        r = r || sd < 0 ||\r\n\r\n        // Are there any non-zero digits after the rounding digit?\r\n        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n         xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n        r = rm < 4\r\n         ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n         : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n           rm == (x.s < 0 ? 8 : 7));\r\n\r\n        if (sd < 1 || !xc[0]) {\r\n          xc.length = 0;\r\n\r\n          if (r) {\r\n\r\n            // Convert sd to decimal places.\r\n            sd -= x.e + 1;\r\n\r\n            // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n            x.e = -sd || 0;\r\n          } else {\r\n\r\n            // Zero.\r\n            xc[0] = x.e = 0;\r\n          }\r\n\r\n          return x;\r\n        }\r\n\r\n        // Remove excess digits.\r\n        if (i == 0) {\r\n          xc.length = ni;\r\n          k = 1;\r\n          ni--;\r\n        } else {\r\n          xc.length = ni + 1;\r\n          k = pows10[LOG_BASE - i];\r\n\r\n          // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n          // j > 0 means i > number of leading zeros of n.\r\n          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n        }\r\n\r\n        // Round up?\r\n        if (r) {\r\n\r\n          for (; ;) {\r\n\r\n            // If the digit to be rounded up is in the first element of xc...\r\n            if (ni == 0) {\r\n\r\n              // i will be the length of xc[0] before k is added.\r\n              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n              j = xc[0] += k;\r\n              for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n              // if i != k the length has increased.\r\n              if (i != k) {\r\n                x.e++;\r\n                if (xc[0] == BASE) xc[0] = 1;\r\n              }\r\n\r\n              break;\r\n            } else {\r\n              xc[ni] += k;\r\n              if (xc[ni] != BASE) break;\r\n              xc[ni--] = 0;\r\n              k = 1;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Remove trailing zeros.\r\n        for (i = xc.length; xc[--i] === 0; xc.pop());\r\n      }\r\n\r\n      // Overflow? Infinity.\r\n      if (x.e > MAX_EXP) {\r\n        x.c = x.e = null;\r\n\r\n      // Underflow? Zero.\r\n      } else if (x.e < MIN_EXP) {\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function valueOf(n) {\r\n    var str,\r\n      e = n.e;\r\n\r\n    if (e === null) return n.toString();\r\n\r\n    str = coeffToString(n.c);\r\n\r\n    str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n      ? toExponential(str, e)\r\n      : toFixedPoint(str, e, '0');\r\n\r\n    return n.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new BigNumber(this);\r\n    if (x.s < 0) x.s = 1;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   *   0 if they have the same value,\r\n   *   or null if the value of either is NaN.\r\n   */\r\n  P.comparedTo = function (y, b) {\r\n    return compare(this, new BigNumber(y, b));\r\n  };\r\n\r\n\r\n  /*\r\n   * If dp is undefined or null or true or false, return the number of decimal places of the\r\n   * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n   *\r\n   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.decimalPlaces = P.dp = function (dp, rm) {\r\n    var c, n, v,\r\n      x = this;\r\n\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      return round(new BigNumber(x), dp + x.e + 1, rm);\r\n    }\r\n\r\n    if (!(c = x.c)) return null;\r\n    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n    // Subtract the number of trailing zeros of the last number.\r\n    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n    if (n < 0) n = 0;\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */\r\n  P.dividedBy = P.div = function (y, b) {\r\n    return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n   * BigNumber by the value of BigNumber(y, b).\r\n   */\r\n  P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n    return div(this, new BigNumber(y, b), 0, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n   *\r\n   * If m is present, return the result modulo m.\r\n   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n   *\r\n   * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n   *\r\n   * n {number|string|BigNumber} The exponent. An integer.\r\n   * [m] {number|string|BigNumber} The modulus.\r\n   *\r\n   * '[BigNumber Error] Exponent not an integer: {n}'\r\n   */\r\n  P.exponentiatedBy = P.pow = function (n, m) {\r\n    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n      x = this;\r\n\r\n    n = new BigNumber(n);\r\n\r\n    // Allow NaN and Infinity, but not other non-integers.\r\n    if (n.c && !n.isInteger()) {\r\n      throw Error\r\n        (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n    }\r\n\r\n    if (m != null) m = new BigNumber(m);\r\n\r\n    // Exponent of MAX_SAFE_INTEGER is 15.\r\n    nIsBig = n.e > 14;\r\n\r\n    // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.\r\n    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n      // The sign of the result of pow when x is negative depends on the evenness of n.\r\n      // If +n overflows to Infinity, the evenness of n would be not be known.\r\n      y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));\r\n      return m ? y.mod(m) : y;\r\n    }\r\n\r\n    nIsNeg = n.s < 0;\r\n\r\n    if (m) {\r\n\r\n      // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n      if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n      isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n      if (isModExp) x = x.mod(m);\r\n\r\n    // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n    // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.\r\n    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n      // [1, 240000000]\r\n      ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n      // [80000000000000]  [99999750000000]\r\n      : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n      // If x is negative and n is odd, k = -0, else k = 0.\r\n      k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n      // If x >= 1, k = Infinity.\r\n      if (x.e > -1) k = 1 / k;\r\n\r\n      // If n is negative return 0, else return Infinity.\r\n      return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n    } else if (POW_PRECISION) {\r\n\r\n      // Truncating each coefficient array to a length of k after each multiplication\r\n      // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n      // i.e. there will be a minimum of 28 guard digits retained.\r\n      k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n    }\r\n\r\n    if (nIsBig) {\r\n      half = new BigNumber(0.5);\r\n      if (nIsNeg) n.s = 1;\r\n      nIsOdd = isOdd(n);\r\n    } else {\r\n      i = Math.abs(+valueOf(n));\r\n      nIsOdd = i % 2;\r\n    }\r\n\r\n    y = new BigNumber(ONE);\r\n\r\n    // Performs 54 loop iterations for n of 9007199254740991.\r\n    for (; ;) {\r\n\r\n      if (nIsOdd) {\r\n        y = y.times(x);\r\n        if (!y.c) break;\r\n\r\n        if (k) {\r\n          if (y.c.length > k) y.c.length = k;\r\n        } else if (isModExp) {\r\n          y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (i) {\r\n        i = mathfloor(i / 2);\r\n        if (i === 0) break;\r\n        nIsOdd = i % 2;\r\n      } else {\r\n        n = n.times(half);\r\n        round(n, n.e + 1, 1);\r\n\r\n        if (n.e > 14) {\r\n          nIsOdd = isOdd(n);\r\n        } else {\r\n          i = +valueOf(n);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        }\r\n      }\r\n\r\n      x = x.times(x);\r\n\r\n      if (k) {\r\n        if (x.c && x.c.length > k) x.c.length = k;\r\n      } else if (isModExp) {\r\n        x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n      }\r\n    }\r\n\r\n    if (isModExp) return y;\r\n    if (nIsNeg) y = ONE.div(y);\r\n\r\n    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n   */\r\n  P.integerValue = function (rm) {\r\n    var n = new BigNumber(this);\r\n    if (rm == null) rm = ROUNDING_MODE;\r\n    else intCheck(rm, 0, 8);\r\n    return round(n, n.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isEqualTo = P.eq = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n   */\r\n  P.isFinite = function () {\r\n    return !!this.c;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isGreaterThan = P.gt = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is greater than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */\r\n  P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n    return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n   */\r\n  P.isInteger = function () {\r\n    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isLessThan = P.lt = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is less than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */\r\n  P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n    return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n   */\r\n  P.isNaN = function () {\r\n    return !this.s;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is negative, otherwise return false.\r\n   */\r\n  P.isNegative = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is positive, otherwise return false.\r\n   */\r\n  P.isPositive = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n   */\r\n  P.isZero = function () {\r\n    return !!this.c && this.c[0] == 0;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n   * BigNumber(y, b).\r\n   */\r\n  P.minus = function (y, b) {\r\n    var i, j, t, xLTy,\r\n      x = this,\r\n      a = x.s;\r\n\r\n    y = new BigNumber(y, b);\r\n    b = y.s;\r\n\r\n    // Either NaN?\r\n    if (!a || !b) return new BigNumber(NaN);\r\n\r\n    // Signs differ?\r\n    if (a != b) {\r\n      y.s = -b;\r\n      return x.plus(y);\r\n    }\r\n\r\n    var xe = x.e / LOG_BASE,\r\n      ye = y.e / LOG_BASE,\r\n      xc = x.c,\r\n      yc = y.c;\r\n\r\n    if (!xe || !ye) {\r\n\r\n      // Either Infinity?\r\n      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n      // Either zero?\r\n      if (!xc[0] || !yc[0]) {\r\n\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n         // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n         ROUNDING_MODE == 3 ? -0 : 0);\r\n      }\r\n    }\r\n\r\n    xe = bitFloor(xe);\r\n    ye = bitFloor(ye);\r\n    xc = xc.slice();\r\n\r\n    // Determine which is the bigger number.\r\n    if (a = xe - ye) {\r\n\r\n      if (xLTy = a < 0) {\r\n        a = -a;\r\n        t = xc;\r\n      } else {\r\n        ye = xe;\r\n        t = yc;\r\n      }\r\n\r\n      t.reverse();\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      for (b = a; b--; t.push(0));\r\n      t.reverse();\r\n    } else {\r\n\r\n      // Exponents equal. Check digit by digit.\r\n      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n      for (a = b = 0; b < j; b++) {\r\n\r\n        if (xc[b] != yc[b]) {\r\n          xLTy = xc[b] < yc[b];\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // x < y? Point xc to the array of the bigger number.\r\n    if (xLTy) {\r\n      t = xc;\r\n      xc = yc;\r\n      yc = t;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    b = (j = yc.length) - (i = xc.length);\r\n\r\n    // Append zeros to xc if shorter.\r\n    // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n    if (b > 0) for (; b--; xc[i++] = 0);\r\n    b = BASE - 1;\r\n\r\n    // Subtract yc from xc.\r\n    for (; j > a;) {\r\n\r\n      if (xc[--j] < yc[j]) {\r\n        for (i = j; i && !xc[--i]; xc[i] = b);\r\n        --xc[i];\r\n        xc[j] += BASE;\r\n      }\r\n\r\n      xc[j] -= yc[j];\r\n    }\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n    // Zero?\r\n    if (!xc[0]) {\r\n\r\n      // Following IEEE 754 (2008) 6.3,\r\n      // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n      y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n      y.c = [y.e = 0];\r\n      return y;\r\n    }\r\n\r\n    // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n    // for finite x and y.\r\n    return normalise(y, xc, ye);\r\n  };\r\n\r\n\r\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n   * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n   */\r\n  P.modulo = P.mod = function (y, b) {\r\n    var q, s,\r\n      x = this;\r\n\r\n    y = new BigNumber(y, b);\r\n\r\n    // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n    if (!x.c || !y.s || y.c && !y.c[0]) {\r\n      return new BigNumber(NaN);\r\n\r\n    // Return x if y is Infinity or x is zero.\r\n    } else if (!y.c || x.c && !x.c[0]) {\r\n      return new BigNumber(x);\r\n    }\r\n\r\n    if (MODULO_MODE == 9) {\r\n\r\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n      // r = x - qy    where  0 <= r < abs(y)\r\n      s = y.s;\r\n      y.s = 1;\r\n      q = div(x, y, 0, 3);\r\n      y.s = s;\r\n      q.s *= s;\r\n    } else {\r\n      q = div(x, y, 0, MODULO_MODE);\r\n    }\r\n\r\n    y = x.minus(q.times(y));\r\n\r\n    // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n   * of BigNumber(y, b).\r\n   */\r\n  P.multipliedBy = P.times = function (y, b) {\r\n    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n      base, sqrtBase,\r\n      x = this,\r\n      xc = x.c,\r\n      yc = (y = new BigNumber(y, b)).c;\r\n\r\n    // Either NaN, Infinity or 0?\r\n    if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n      // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n        y.c = y.e = y.s = null;\r\n      } else {\r\n        y.s *= x.s;\r\n\r\n        // Return Infinity if either is Infinity.\r\n        if (!xc || !yc) {\r\n          y.c = y.e = null;\r\n\r\n        // Return 0 if either is 0.\r\n        } else {\r\n          y.c = [0];\r\n          y.e = 0;\r\n        }\r\n      }\r\n\r\n      return y;\r\n    }\r\n\r\n    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n    y.s *= x.s;\r\n    xcL = xc.length;\r\n    ycL = yc.length;\r\n\r\n    // Ensure xc points to longer array and xcL to its length.\r\n    if (xcL < ycL) {\r\n      zc = xc;\r\n      xc = yc;\r\n      yc = zc;\r\n      i = xcL;\r\n      xcL = ycL;\r\n      ycL = i;\r\n    }\r\n\r\n    // Initialise the result array with zeros.\r\n    for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n    base = BASE;\r\n    sqrtBase = SQRT_BASE;\r\n\r\n    for (i = ycL; --i >= 0;) {\r\n      c = 0;\r\n      ylo = yc[i] % sqrtBase;\r\n      yhi = yc[i] / sqrtBase | 0;\r\n\r\n      for (k = xcL, j = i + k; j > i;) {\r\n        xlo = xc[--k] % sqrtBase;\r\n        xhi = xc[k] / sqrtBase | 0;\r\n        m = yhi * xlo + xhi * ylo;\r\n        xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n        zc[j--] = xlo % base;\r\n      }\r\n\r\n      zc[j] = c;\r\n    }\r\n\r\n    if (c) {\r\n      ++e;\r\n    } else {\r\n      zc.splice(0, 1);\r\n    }\r\n\r\n    return normalise(y, zc, e);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n   * i.e. multiplied by -1.\r\n   */\r\n  P.negated = function () {\r\n    var x = new BigNumber(this);\r\n    x.s = -x.s || null;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n   * BigNumber(y, b).\r\n   */\r\n  P.plus = function (y, b) {\r\n    var t,\r\n      x = this,\r\n      a = x.s;\r\n\r\n    y = new BigNumber(y, b);\r\n    b = y.s;\r\n\r\n    // Either NaN?\r\n    if (!a || !b) return new BigNumber(NaN);\r\n\r\n    // Signs differ?\r\n     if (a != b) {\r\n      y.s = -b;\r\n      return x.minus(y);\r\n    }\r\n\r\n    var xe = x.e / LOG_BASE,\r\n      ye = y.e / LOG_BASE,\r\n      xc = x.c,\r\n      yc = y.c;\r\n\r\n    if (!xe || !ye) {\r\n\r\n      // Return Infinity if either Infinity.\r\n      if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n      // Either zero?\r\n      // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n    }\r\n\r\n    xe = bitFloor(xe);\r\n    ye = bitFloor(ye);\r\n    xc = xc.slice();\r\n\r\n    // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n    if (a = xe - ye) {\r\n      if (a > 0) {\r\n        ye = xe;\r\n        t = yc;\r\n      } else {\r\n        a = -a;\r\n        t = xc;\r\n      }\r\n\r\n      t.reverse();\r\n      for (; a--; t.push(0));\r\n      t.reverse();\r\n    }\r\n\r\n    a = xc.length;\r\n    b = yc.length;\r\n\r\n    // Point xc to the longer array, and b to the shorter length.\r\n    if (a - b < 0) {\r\n      t = yc;\r\n      yc = xc;\r\n      xc = t;\r\n      b = a;\r\n    }\r\n\r\n    // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n    for (a = 0; b;) {\r\n      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n    }\r\n\r\n    if (a) {\r\n      xc = [a].concat(xc);\r\n      ++ye;\r\n    }\r\n\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    // ye = MAX_EXP + 1 possible\r\n    return normalise(y, xc, ye);\r\n  };\r\n\r\n\r\n  /*\r\n   * If sd is undefined or null or true or false, return the number of significant digits of\r\n   * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n   * If sd is true include integer-part trailing zeros in the count.\r\n   *\r\n   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n   *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */\r\n  P.precision = P.sd = function (sd, rm) {\r\n    var c, n, v,\r\n      x = this;\r\n\r\n    if (sd != null && sd !== !!sd) {\r\n      intCheck(sd, 1, MAX);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      return round(new BigNumber(x), sd, rm);\r\n    }\r\n\r\n    if (!(c = x.c)) return null;\r\n    v = c.length - 1;\r\n    n = v * LOG_BASE + 1;\r\n\r\n    if (v = c[v]) {\r\n\r\n      // Subtract the number of trailing zeros of the last element.\r\n      for (; v % 10 == 0; v /= 10, n--);\r\n\r\n      // Add the number of digits of the first element.\r\n      for (v = c[0]; v >= 10; v /= 10, n++);\r\n    }\r\n\r\n    if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n   *\r\n   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n   */\r\n  P.shiftedBy = function (k) {\r\n    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n    return this.times('1e' + k);\r\n  };\r\n\r\n\r\n  /*\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N) =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I) =  I\r\n   *  sqrt(0) =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var m, n, r, rep, t,\r\n      x = this,\r\n      c = x.c,\r\n      s = x.s,\r\n      e = x.e,\r\n      dp = DECIMAL_PLACES + 4,\r\n      half = new BigNumber('0.5');\r\n\r\n    // Negative/NaN/Infinity/zero?\r\n    if (s !== 1 || !c || !c[0]) {\r\n      return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n    }\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+valueOf(x));\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = coeffToString(c);\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(+n);\r\n      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new BigNumber(n);\r\n    } else {\r\n      r = new BigNumber(s + '');\r\n    }\r\n\r\n    // Check for zero.\r\n    // r could be zero if MIN_EXP is changed after the this value was created.\r\n    // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n    // coeffToString to throw.\r\n    if (r.c[0]) {\r\n      e = r.e;\r\n      s = e + dp;\r\n      if (s < 3) s = 0;\r\n\r\n      // Newton-Raphson iteration.\r\n      for (; ;) {\r\n        t = r;\r\n        r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n          // The exponent of r may here be one less than the final result exponent,\r\n          // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n          // are indexed correctly.\r\n          if (r.e < e) --s;\r\n          n = n.slice(s - 3, s + 1);\r\n\r\n          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n          // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n          // iteration.\r\n          if (n == '9999' || !rep && n == '4999') {\r\n\r\n            // On the first iteration only, check to see if rounding up gives the\r\n            // exact result as the nines may infinitely repeat.\r\n            if (!rep) {\r\n              round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n              if (t.times(t).eq(x)) {\r\n                r = t;\r\n                break;\r\n              }\r\n            }\r\n\r\n            dp += 4;\r\n            s += 4;\r\n            rep = 1;\r\n          } else {\r\n\r\n            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n            // result. If not, then there are further digits and m will be truthy.\r\n            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n              // Truncate to the first rounding digit.\r\n              round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n              m = !r.times(r).eq(x);\r\n            }\r\n\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in exponential notation and\r\n   * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      dp++;\r\n    }\r\n    return format(this, dp, rm, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n   * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      dp = dp + this.e + 1;\r\n    }\r\n    return format(this, dp, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n   * of the format or FORMAT object (see BigNumber.set).\r\n   *\r\n   * The formatting object may contain some or all of the properties shown below.\r\n   *\r\n   * FORMAT = {\r\n   *   prefix: '',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 0,\r\n   *   groupSeparator: ',',\r\n   *   decimalSeparator: '.',\r\n   *   fractionGroupSize: 0,\r\n   *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n   *   suffix: ''\r\n   * };\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   * [format] {object} Formatting options. See FORMAT pbject above.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   * '[BigNumber Error] Argument not an object: {format}'\r\n   */\r\n  P.toFormat = function (dp, rm, format) {\r\n    var str,\r\n      x = this;\r\n\r\n    if (format == null) {\r\n      if (dp != null && rm && typeof rm == 'object') {\r\n        format = rm;\r\n        rm = null;\r\n      } else if (dp && typeof dp == 'object') {\r\n        format = dp;\r\n        dp = rm = null;\r\n      } else {\r\n        format = FORMAT;\r\n      }\r\n    } else if (typeof format != 'object') {\r\n      throw Error\r\n        (bignumberError + 'Argument not an object: ' + format);\r\n    }\r\n\r\n    str = x.toFixed(dp, rm);\r\n\r\n    if (x.c) {\r\n      var i,\r\n        arr = str.split('.'),\r\n        g1 = +format.groupSize,\r\n        g2 = +format.secondaryGroupSize,\r\n        groupSeparator = format.groupSeparator || '',\r\n        intPart = arr[0],\r\n        fractionPart = arr[1],\r\n        isNeg = x.s < 0,\r\n        intDigits = isNeg ? intPart.slice(1) : intPart,\r\n        len = intDigits.length;\r\n\r\n      if (g2) {\r\n        i = g1;\r\n        g1 = g2;\r\n        g2 = i;\r\n        len -= i;\r\n      }\r\n\r\n      if (g1 > 0 && len > 0) {\r\n        i = len % g1 || g1;\r\n        intPart = intDigits.substr(0, i);\r\n        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n        if (isNeg) intPart = '-' + intPart;\r\n      }\r\n\r\n      str = fractionPart\r\n       ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n        ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n         '$&' + (format.fractionGroupSeparator || ''))\r\n        : fractionPart)\r\n       : intPart;\r\n    }\r\n\r\n    return (format.prefix || '') + str + (format.suffix || '');\r\n  };\r\n\r\n\r\n  /*\r\n   * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n   * fraction with an integer numerator and an integer denominator.\r\n   * The denominator will be a positive non-zero value less than or equal to the specified\r\n   * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n   * the lowest value necessary to represent the number exactly.\r\n   *\r\n   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n   *\r\n   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n   */\r\n  P.toFraction = function (md) {\r\n    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n      x = this,\r\n      xc = x.c;\r\n\r\n    if (md != null) {\r\n      n = new BigNumber(md);\r\n\r\n      // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n        throw Error\r\n          (bignumberError + 'Argument ' +\r\n            (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n      }\r\n    }\r\n\r\n    if (!xc) return new BigNumber(x);\r\n\r\n    d = new BigNumber(ONE);\r\n    n1 = d0 = new BigNumber(ONE);\r\n    d1 = n0 = new BigNumber(ONE);\r\n    s = coeffToString(xc);\r\n\r\n    // Determine initial denominator.\r\n    // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n    e = d.e = s.length - x.e - 1;\r\n    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n    md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n    exp = MAX_EXP;\r\n    MAX_EXP = 1 / 0;\r\n    n = new BigNumber(s);\r\n\r\n    // n0 = d1 = 0\r\n    n0.c[0] = 0;\r\n\r\n    for (; ;)  {\r\n      q = div(n, d, 0, 1);\r\n      d2 = d0.plus(q.times(d1));\r\n      if (d2.comparedTo(md) == 1) break;\r\n      d0 = d1;\r\n      d1 = d2;\r\n      n1 = n0.plus(q.times(d2 = n1));\r\n      n0 = d2;\r\n      d = n.minus(q.times(d2 = d));\r\n      n = d2;\r\n    }\r\n\r\n    d2 = div(md.minus(d0), d1, 0, 1);\r\n    n0 = n0.plus(d2.times(n1));\r\n    d0 = d0.plus(d2.times(d1));\r\n    n0.s = n1.s = x.s;\r\n    e = e * 2;\r\n\r\n    // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n    MAX_EXP = exp;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this BigNumber converted to a number primitive.\r\n   */\r\n  P.toNumber = function () {\r\n    return +valueOf(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n   * necessary to represent the integer part of the value in fixed-point notation, then use\r\n   * exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    if (sd != null) intCheck(sd, 1, MAX);\r\n    return format(this, sd, rm, 2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n   * TO_EXP_NEG, return exponential notation.\r\n   *\r\n   * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n   *\r\n   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n   */\r\n  P.toString = function (b) {\r\n    var str,\r\n      n = this,\r\n      s = n.s,\r\n      e = n.e;\r\n\r\n    // Infinity or NaN?\r\n    if (e === null) {\r\n      if (s) {\r\n        str = 'Infinity';\r\n        if (s < 0) str = '-' + str;\r\n      } else {\r\n        str = 'NaN';\r\n      }\r\n    } else {\r\n      if (b == null) {\r\n        str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n         ? toExponential(coeffToString(n.c), e)\r\n         : toFixedPoint(coeffToString(n.c), e, '0');\r\n      } else if (b === 10 && alphabetHasNormalDecimalDigits) {\r\n        n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n        str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n      } else {\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n        str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n      }\r\n\r\n      if (s < 0 && n.c[0]) str = '-' + str;\r\n    }\r\n\r\n    return str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return as toString, but do not accept a base argument, and include the minus sign for\r\n   * negative zero.\r\n   */\r\n  P.valueOf = P.toJSON = function () {\r\n    return valueOf(this);\r\n  };\r\n\r\n\r\n  P._isBigNumber = true;\r\n\r\n  P[Symbol.toStringTag] = 'BigNumber';\r\n\r\n  // Node.js v10.12.0+\r\n  P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;\r\n\r\n  if (configObject != null) BigNumber.set(configObject);\r\n\r\n  return BigNumber;\r\n}\r\n\r\n\r\n// PRIVATE HELPER FUNCTIONS\r\n\r\n// These functions don't need access to variables,\r\n// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\nfunction bitFloor(n) {\r\n  var i = n | 0;\r\n  return n > 0 || n === i ? i : i - 1;\r\n}\r\n\r\n\r\n// Return a coefficient array as a string of base 10 digits.\r\nfunction coeffToString(a) {\r\n  var s, z,\r\n    i = 1,\r\n    j = a.length,\r\n    r = a[0] + '';\r\n\r\n  for (; i < j;) {\r\n    s = a[i++] + '';\r\n    z = LOG_BASE - s.length;\r\n    for (; z--; s = '0' + s);\r\n    r += s;\r\n  }\r\n\r\n  // Determine trailing zeros.\r\n  for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n  return r.slice(0, j + 1 || 1);\r\n}\r\n\r\n\r\n// Compare the value of BigNumbers x and y.\r\nfunction compare(x, y) {\r\n  var a, b,\r\n    xc = x.c,\r\n    yc = y.c,\r\n    i = x.s,\r\n    j = y.s,\r\n    k = x.e,\r\n    l = y.e;\r\n\r\n  // Either NaN?\r\n  if (!i || !j) return null;\r\n\r\n  a = xc && !xc[0];\r\n  b = yc && !yc[0];\r\n\r\n  // Either zero?\r\n  if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n  // Signs differ?\r\n  if (i != j) return i;\r\n\r\n  a = i < 0;\r\n  b = k == l;\r\n\r\n  // Either Infinity?\r\n  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n  // Compare exponents.\r\n  if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n  j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n  // Compare digit by digit.\r\n  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n  // Compare lengths.\r\n  return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n}\r\n\r\n\r\n/*\r\n * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n */\r\nfunction intCheck(n, min, max, name) {\r\n  if (n < min || n > max || n !== mathfloor(n)) {\r\n    throw Error\r\n     (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n       ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n       : ' not a primitive number: ') + String(n));\r\n  }\r\n}\r\n\r\n\r\n// Assumes finite n.\r\nfunction isOdd(n) {\r\n  var k = n.c.length - 1;\r\n  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n}\r\n\r\n\r\nfunction toExponential(str, e) {\r\n  return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n   (e < 0 ? 'e' : 'e+') + e;\r\n}\r\n\r\n\r\nfunction toFixedPoint(str, e, z) {\r\n  var len, zs;\r\n\r\n  // Negative exponent?\r\n  if (e < 0) {\r\n\r\n    // Prepend zeros.\r\n    for (zs = z + '.'; ++e; zs += z);\r\n    str = zs + str;\r\n\r\n  // Positive exponent\r\n  } else {\r\n    len = str.length;\r\n\r\n    // Append zeros.\r\n    if (++e > len) {\r\n      for (zs = z, e -= len; --e; zs += z);\r\n      str += zs;\r\n    } else if (e < len) {\r\n      str = str.slice(0, e) + '.' + str.slice(e);\r\n    }\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\n\r\n// EXPORT\r\n\r\n\r\nexport var BigNumber = clone();\r\n\r\nexport default BigNumber;\r\n","const basex = require('base-x')\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Find code of next character\n      var charCode = source.charCodeAt(psz)\n            // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n            // Decode character\n      var carry = BASE_MAP[charCode]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","(function (root, factory) {\n    // Hack to make all exports of this module sha256 function object properties.\n    var exports = {};\n    factory(exports);\n    var sha256 = exports[\"default\"];\n    for (var k in exports) {\n        sha256[k] = exports[k];\n    }\n        \n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        module.exports = sha256;\n    } else if (typeof define === 'function' && define.amd) {\n        define(function() { return sha256; }); \n    } else {\n        root.sha256 = sha256;\n    }\n})(this, function(exports) {\n\"use strict\";\nexports.__esModule = true;\n// SHA-256 (+ HMAC and PBKDF2) for JavaScript.\n//\n// Written in 2014-2016 by Dmitry Chestnykh.\n// Public domain, no warranty.\n//\n// Functions (accept and return Uint8Arrays):\n//\n//   sha256(message) -> hash\n//   sha256.hmac(key, message) -> mac\n//   sha256.pbkdf2(password, salt, rounds, dkLen) -> dk\n//\n//  Classes:\n//\n//   new sha256.Hash()\n//   new sha256.HMAC(key)\n//\nexports.digestLength = 32;\nexports.blockSize = 64;\n// SHA-256 constants\nvar K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,\n    0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,\n    0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,\n    0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,\n    0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,\n    0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,\n    0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,\n    0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,\n    0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\nfunction hashBlocks(w, v, p, pos, len) {\n    var a, b, c, d, e, f, g, h, u, i, j, t1, t2;\n    while (len >= 64) {\n        a = v[0];\n        b = v[1];\n        c = v[2];\n        d = v[3];\n        e = v[4];\n        f = v[5];\n        g = v[6];\n        h = v[7];\n        for (i = 0; i < 16; i++) {\n            j = pos + i * 4;\n            w[i] = (((p[j] & 0xff) << 24) | ((p[j + 1] & 0xff) << 16) |\n                ((p[j + 2] & 0xff) << 8) | (p[j + 3] & 0xff));\n        }\n        for (i = 16; i < 64; i++) {\n            u = w[i - 2];\n            t1 = (u >>> 17 | u << (32 - 17)) ^ (u >>> 19 | u << (32 - 19)) ^ (u >>> 10);\n            u = w[i - 15];\n            t2 = (u >>> 7 | u << (32 - 7)) ^ (u >>> 18 | u << (32 - 18)) ^ (u >>> 3);\n            w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);\n        }\n        for (i = 0; i < 64; i++) {\n            t1 = (((((e >>> 6 | e << (32 - 6)) ^ (e >>> 11 | e << (32 - 11)) ^\n                (e >>> 25 | e << (32 - 25))) + ((e & f) ^ (~e & g))) | 0) +\n                ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;\n            t2 = (((a >>> 2 | a << (32 - 2)) ^ (a >>> 13 | a << (32 - 13)) ^\n                (a >>> 22 | a << (32 - 22))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;\n            h = g;\n            g = f;\n            f = e;\n            e = (d + t1) | 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (t1 + t2) | 0;\n        }\n        v[0] += a;\n        v[1] += b;\n        v[2] += c;\n        v[3] += d;\n        v[4] += e;\n        v[5] += f;\n        v[6] += g;\n        v[7] += h;\n        pos += 64;\n        len -= 64;\n    }\n    return pos;\n}\n// Hash implements SHA256 hash algorithm.\nvar Hash = /** @class */ (function () {\n    function Hash() {\n        this.digestLength = exports.digestLength;\n        this.blockSize = exports.blockSize;\n        // Note: Int32Array is used instead of Uint32Array for performance reasons.\n        this.state = new Int32Array(8); // hash state\n        this.temp = new Int32Array(64); // temporary state\n        this.buffer = new Uint8Array(128); // buffer for data to hash\n        this.bufferLength = 0; // number of bytes in buffer\n        this.bytesHashed = 0; // number of total bytes hashed\n        this.finished = false; // indicates whether the hash was finalized\n        this.reset();\n    }\n    // Resets hash state making it possible\n    // to re-use this instance to hash other data.\n    Hash.prototype.reset = function () {\n        this.state[0] = 0x6a09e667;\n        this.state[1] = 0xbb67ae85;\n        this.state[2] = 0x3c6ef372;\n        this.state[3] = 0xa54ff53a;\n        this.state[4] = 0x510e527f;\n        this.state[5] = 0x9b05688c;\n        this.state[6] = 0x1f83d9ab;\n        this.state[7] = 0x5be0cd19;\n        this.bufferLength = 0;\n        this.bytesHashed = 0;\n        this.finished = false;\n        return this;\n    };\n    // Cleans internal buffers and re-initializes hash state.\n    Hash.prototype.clean = function () {\n        for (var i = 0; i < this.buffer.length; i++) {\n            this.buffer[i] = 0;\n        }\n        for (var i = 0; i < this.temp.length; i++) {\n            this.temp[i] = 0;\n        }\n        this.reset();\n    };\n    // Updates hash state with the given data.\n    //\n    // Optionally, length of the data can be specified to hash\n    // fewer bytes than data.length.\n    //\n    // Throws error when trying to update already finalized hash:\n    // instance must be reset to use it again.\n    Hash.prototype.update = function (data, dataLength) {\n        if (dataLength === void 0) { dataLength = data.length; }\n        if (this.finished) {\n            throw new Error(\"SHA256: can't update because hash was finished.\");\n        }\n        var dataPos = 0;\n        this.bytesHashed += dataLength;\n        if (this.bufferLength > 0) {\n            while (this.bufferLength < 64 && dataLength > 0) {\n                this.buffer[this.bufferLength++] = data[dataPos++];\n                dataLength--;\n            }\n            if (this.bufferLength === 64) {\n                hashBlocks(this.temp, this.state, this.buffer, 0, 64);\n                this.bufferLength = 0;\n            }\n        }\n        if (dataLength >= 64) {\n            dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);\n            dataLength %= 64;\n        }\n        while (dataLength > 0) {\n            this.buffer[this.bufferLength++] = data[dataPos++];\n            dataLength--;\n        }\n        return this;\n    };\n    // Finalizes hash state and puts hash into out.\n    //\n    // If hash was already finalized, puts the same value.\n    Hash.prototype.finish = function (out) {\n        if (!this.finished) {\n            var bytesHashed = this.bytesHashed;\n            var left = this.bufferLength;\n            var bitLenHi = (bytesHashed / 0x20000000) | 0;\n            var bitLenLo = bytesHashed << 3;\n            var padLength = (bytesHashed % 64 < 56) ? 64 : 128;\n            this.buffer[left] = 0x80;\n            for (var i = left + 1; i < padLength - 8; i++) {\n                this.buffer[i] = 0;\n            }\n            this.buffer[padLength - 8] = (bitLenHi >>> 24) & 0xff;\n            this.buffer[padLength - 7] = (bitLenHi >>> 16) & 0xff;\n            this.buffer[padLength - 6] = (bitLenHi >>> 8) & 0xff;\n            this.buffer[padLength - 5] = (bitLenHi >>> 0) & 0xff;\n            this.buffer[padLength - 4] = (bitLenLo >>> 24) & 0xff;\n            this.buffer[padLength - 3] = (bitLenLo >>> 16) & 0xff;\n            this.buffer[padLength - 2] = (bitLenLo >>> 8) & 0xff;\n            this.buffer[padLength - 1] = (bitLenLo >>> 0) & 0xff;\n            hashBlocks(this.temp, this.state, this.buffer, 0, padLength);\n            this.finished = true;\n        }\n        for (var i = 0; i < 8; i++) {\n            out[i * 4 + 0] = (this.state[i] >>> 24) & 0xff;\n            out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;\n            out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;\n            out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;\n        }\n        return this;\n    };\n    // Returns the final hash digest.\n    Hash.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    // Internal function for use in HMAC for optimization.\n    Hash.prototype._saveState = function (out) {\n        for (var i = 0; i < this.state.length; i++) {\n            out[i] = this.state[i];\n        }\n    };\n    // Internal function for use in HMAC for optimization.\n    Hash.prototype._restoreState = function (from, bytesHashed) {\n        for (var i = 0; i < this.state.length; i++) {\n            this.state[i] = from[i];\n        }\n        this.bytesHashed = bytesHashed;\n        this.finished = false;\n        this.bufferLength = 0;\n    };\n    return Hash;\n}());\nexports.Hash = Hash;\n// HMAC implements HMAC-SHA256 message authentication algorithm.\nvar HMAC = /** @class */ (function () {\n    function HMAC(key) {\n        this.inner = new Hash();\n        this.outer = new Hash();\n        this.blockSize = this.inner.blockSize;\n        this.digestLength = this.inner.digestLength;\n        var pad = new Uint8Array(this.blockSize);\n        if (key.length > this.blockSize) {\n            (new Hash()).update(key).finish(pad).clean();\n        }\n        else {\n            for (var i = 0; i < key.length; i++) {\n                pad[i] = key[i];\n            }\n        }\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36;\n        }\n        this.inner.update(pad);\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] ^= 0x36 ^ 0x5c;\n        }\n        this.outer.update(pad);\n        this.istate = new Uint32Array(8);\n        this.ostate = new Uint32Array(8);\n        this.inner._saveState(this.istate);\n        this.outer._saveState(this.ostate);\n        for (var i = 0; i < pad.length; i++) {\n            pad[i] = 0;\n        }\n    }\n    // Returns HMAC state to the state initialized with key\n    // to make it possible to run HMAC over the other data with the same\n    // key without creating a new instance.\n    HMAC.prototype.reset = function () {\n        this.inner._restoreState(this.istate, this.inner.blockSize);\n        this.outer._restoreState(this.ostate, this.outer.blockSize);\n        return this;\n    };\n    // Cleans HMAC state.\n    HMAC.prototype.clean = function () {\n        for (var i = 0; i < this.istate.length; i++) {\n            this.ostate[i] = this.istate[i] = 0;\n        }\n        this.inner.clean();\n        this.outer.clean();\n    };\n    // Updates state with provided data.\n    HMAC.prototype.update = function (data) {\n        this.inner.update(data);\n        return this;\n    };\n    // Finalizes HMAC and puts the result in out.\n    HMAC.prototype.finish = function (out) {\n        if (this.outer.finished) {\n            this.outer.finish(out);\n        }\n        else {\n            this.inner.finish(out);\n            this.outer.update(out, this.digestLength).finish(out);\n        }\n        return this;\n    };\n    // Returns message authentication code.\n    HMAC.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    return HMAC;\n}());\nexports.HMAC = HMAC;\n// Returns SHA256 hash of data.\nfunction hash(data) {\n    var h = (new Hash()).update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hash = hash;\n// Function hash is both available as module.hash and as default export.\nexports[\"default\"] = hash;\n// Returns HMAC-SHA256 of data under the key.\nfunction hmac(key, data) {\n    var h = (new HMAC(key)).update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hmac = hmac;\n// Fills hkdf buffer like this:\n// T(1) = HMAC-Hash(PRK, T(0) | info | 0x01)\nfunction fillBuffer(buffer, hmac, info, counter) {\n    // Counter is a byte value: check if it overflowed.\n    var num = counter[0];\n    if (num === 0) {\n        throw new Error(\"hkdf: cannot expand more\");\n    }\n    // Prepare HMAC instance for new data with old key.\n    hmac.reset();\n    // Hash in previous output if it was generated\n    // (i.e. counter is greater than 1).\n    if (num > 1) {\n        hmac.update(buffer);\n    }\n    // Hash in info if it exists.\n    if (info) {\n        hmac.update(info);\n    }\n    // Hash in the counter.\n    hmac.update(counter);\n    // Output result to buffer and clean HMAC instance.\n    hmac.finish(buffer);\n    // Increment counter inside typed array, this works properly.\n    counter[0]++;\n}\nvar hkdfSalt = new Uint8Array(exports.digestLength); // Filled with zeroes.\nfunction hkdf(key, salt, info, length) {\n    if (salt === void 0) { salt = hkdfSalt; }\n    if (length === void 0) { length = 32; }\n    var counter = new Uint8Array([1]);\n    // HKDF-Extract uses salt as HMAC key, and key as data.\n    var okm = hmac(salt, key);\n    // Initialize HMAC for expanding with extracted key.\n    // Ensure no collisions with `hmac` function.\n    var hmac_ = new HMAC(okm);\n    // Allocate buffer.\n    var buffer = new Uint8Array(hmac_.digestLength);\n    var bufpos = buffer.length;\n    var out = new Uint8Array(length);\n    for (var i = 0; i < length; i++) {\n        if (bufpos === buffer.length) {\n            fillBuffer(buffer, hmac_, info, counter);\n            bufpos = 0;\n        }\n        out[i] = buffer[bufpos++];\n    }\n    hmac_.clean();\n    buffer.fill(0);\n    counter.fill(0);\n    return out;\n}\nexports.hkdf = hkdf;\n// Derives a key from password and salt using PBKDF2-HMAC-SHA256\n// with the given number of iterations.\n//\n// The number of bytes returned is equal to dkLen.\n//\n// (For better security, avoid dkLen greater than hash length - 32 bytes).\nfunction pbkdf2(password, salt, iterations, dkLen) {\n    var prf = new HMAC(password);\n    var len = prf.digestLength;\n    var ctr = new Uint8Array(4);\n    var t = new Uint8Array(len);\n    var u = new Uint8Array(len);\n    var dk = new Uint8Array(dkLen);\n    for (var i = 0; i * len < dkLen; i++) {\n        var c = i + 1;\n        ctr[0] = (c >>> 24) & 0xff;\n        ctr[1] = (c >>> 16) & 0xff;\n        ctr[2] = (c >>> 8) & 0xff;\n        ctr[3] = (c >>> 0) & 0xff;\n        prf.reset();\n        prf.update(salt);\n        prf.update(ctr);\n        prf.finish(u);\n        for (var j = 0; j < len; j++) {\n            t[j] = u[j];\n        }\n        for (var j = 2; j <= iterations; j++) {\n            prf.reset();\n            prf.update(u).finish(u);\n            for (var k = 0; k < len; k++) {\n                t[k] ^= u[k];\n            }\n        }\n        for (var j = 0; j < len && i * len + j < dkLen; j++) {\n            dk[i * len + j] = t[j];\n        }\n    }\n    for (var i = 0; i < len; i++) {\n        t[i] = u[i] = 0;\n    }\n    for (var i = 0; i < 4; i++) {\n        ctr[i] = 0;\n    }\n    prf.clean();\n    return dk;\n}\nexports.pbkdf2 = pbkdf2;\n});\n","// src/b64.ts\nfunction b64ToUint6(nChr) {\n  return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;\n}\nfunction fromB64(sBase64, nBlocksSize) {\n  var sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, \"\"), nInLen = sB64Enc.length, nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2, taBytes = new Uint8Array(nOutLen);\n  for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n    nMod4 = nInIdx & 3;\n    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 6 * (3 - nMod4);\n    if (nMod4 === 3 || nInLen - nInIdx === 1) {\n      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n        taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;\n      }\n      nUint24 = 0;\n    }\n  }\n  return taBytes;\n}\nfunction uint6ToB64(nUint6) {\n  return nUint6 < 26 ? nUint6 + 65 : nUint6 < 52 ? nUint6 + 71 : nUint6 < 62 ? nUint6 - 4 : nUint6 === 62 ? 43 : nUint6 === 63 ? 47 : 65;\n}\nfunction toB64(aBytes) {\n  var nMod3 = 2, sB64Enc = \"\";\n  for (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {\n    nMod3 = nIdx % 3;\n    nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);\n    if (nMod3 === 2 || aBytes.length - nIdx === 1) {\n      sB64Enc += String.fromCodePoint(\n        uint6ToB64(nUint24 >>> 18 & 63),\n        uint6ToB64(nUint24 >>> 12 & 63),\n        uint6ToB64(nUint24 >>> 6 & 63),\n        uint6ToB64(nUint24 & 63)\n      );\n      nUint24 = 0;\n    }\n  }\n  return sB64Enc.slice(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? \"\" : nMod3 === 1 ? \"=\" : \"==\");\n}\n\n// src/hex.ts\nfunction fromHEX(hexStr) {\n  let intArr = (/^BFC/i.test(hexStr) ? hexStr.slice(3, -4) : hexStr.replace(\"0x\", \"\")).match(/.{1,2}/g).map((byte) => parseInt(byte, 16));\n  if (intArr === null) {\n    throw new Error(`Unable to parse HEX: ${hexStr}`);\n  }\n  return Uint8Array.from(intArr);\n}\nfunction toHEX(bytes) {\n  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\n\n// src/index.ts\nimport bs58 from \"bs58\";\nimport sha256 from \"fast-sha256\";\nvar SUI_ADDRESS_LENGTH = 32;\nfunction toLittleEndian(bigint, size) {\n  let result = new Uint8Array(size);\n  let i = 0;\n  while (bigint > 0) {\n    result[i] = Number(bigint % BigInt(256));\n    bigint = bigint / BigInt(256);\n    i += 1;\n  }\n  return result;\n}\nvar toB58 = (buffer) => bs58.encode(buffer);\nvar fromB58 = (str) => bs58.decode(str);\nvar BcsReader = class {\n  /**\n   * @param {Uint8Array} data Data to use as a buffer.\n   */\n  constructor(data) {\n    this.bytePosition = 0;\n    this.dataView = new DataView(data.buffer);\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Read U8 value from the buffer and shift cursor by 1.\n   * @returns\n   */\n  read8() {\n    let value = this.dataView.getUint8(this.bytePosition);\n    this.shift(1);\n    return value;\n  }\n  /**\n   * Read U16 value from the buffer and shift cursor by 2.\n   * @returns\n   */\n  read16() {\n    let value = this.dataView.getUint16(this.bytePosition, true);\n    this.shift(2);\n    return value;\n  }\n  /**\n   * Read U32 value from the buffer and shift cursor by 4.\n   * @returns\n   */\n  read32() {\n    let value = this.dataView.getUint32(this.bytePosition, true);\n    this.shift(4);\n    return value;\n  }\n  /**\n   * Read U64 value from the buffer and shift cursor by 8.\n   * @returns\n   */\n  read64() {\n    let value1 = this.read32();\n    let value2 = this.read32();\n    let result = value2.toString(16) + value1.toString(16).padStart(8, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 16.\n   */\n  read128() {\n    let value1 = BigInt(this.read64());\n    let value2 = BigInt(this.read64());\n    let result = value2.toString(16) + value1.toString(16).padStart(16, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 32.\n   * @returns\n   */\n  read256() {\n    let value1 = BigInt(this.read128());\n    let value2 = BigInt(this.read128());\n    let result = value2.toString(16) + value1.toString(16).padStart(32, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read `num` number of bytes from the buffer and shift cursor by `num`.\n   * @param num Number of bytes to read.\n   */\n  readBytes(num) {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let value = new Uint8Array(this.dataView.buffer, start, num);\n    this.shift(num);\n    return value;\n  }\n  /**\n   * Read ULEB value - an integer of varying size. Used for enum indexes and\n   * vector lengths.\n   * @returns {Number} The ULEB value.\n   */\n  readULEB() {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let buffer = new Uint8Array(this.dataView.buffer, start);\n    let { value, length } = ulebDecode(buffer);\n    this.shift(length);\n    return value;\n  }\n  /**\n   * Read a BCS vector: read a length and then apply function `cb` X times\n   * where X is the length of the vector, defined as ULEB in BCS bytes.\n   * @param cb Callback to process elements of vector.\n   * @returns {Array<Any>} Array of the resulting values, returned by callback.\n   */\n  readVec(cb) {\n    let length = this.readULEB();\n    let result = [];\n    for (let i = 0; i < length; i++) {\n      result.push(cb(this, i, length));\n    }\n    return result;\n  }\n};\nvar BcsWriter = class {\n  constructor({ size = 1024, maxSize, allocateSize = 1024 } = {}) {\n    this.bytePosition = 0;\n    this.size = size;\n    this.maxSize = maxSize || size;\n    this.allocateSize = allocateSize;\n    this.dataView = new DataView(new ArrayBuffer(size));\n  }\n  ensureSizeOrGrow(bytes) {\n    const requiredSize = this.bytePosition + bytes;\n    if (requiredSize > this.size) {\n      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n      if (requiredSize > nextSize) {\n        throw new Error(\n          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`\n        );\n      }\n      this.size = nextSize;\n      const nextBuffer = new ArrayBuffer(this.size);\n      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n      this.dataView = new DataView(nextBuffer);\n    }\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Write a U8 value into a buffer and shift cursor position by 1.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write8(value) {\n    this.ensureSizeOrGrow(1);\n    this.dataView.setUint8(this.bytePosition, Number(value));\n    return this.shift(1);\n  }\n  /**\n   * Write a U16 value into a buffer and shift cursor position by 2.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write16(value) {\n    this.ensureSizeOrGrow(2);\n    this.dataView.setUint16(this.bytePosition, Number(value), true);\n    return this.shift(2);\n  }\n  /**\n   * Write a U32 value into a buffer and shift cursor position by 4.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write32(value) {\n    this.ensureSizeOrGrow(4);\n    this.dataView.setUint32(this.bytePosition, Number(value), true);\n    return this.shift(4);\n  }\n  /**\n   * Write a U64 value into a buffer and shift cursor position by 8.\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write64(value) {\n    toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U128 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write128(value) {\n    toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U256 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write256(value) {\n    toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a ULEB value into a buffer and shift cursor position by number of bytes\n   * written.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  writeULEB(value) {\n    ulebEncode(value).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a vector into a buffer by first writing the vector length and then calling\n   * a callback on each passed value.\n   *\n   * @param {Array<Any>} vector Array of elements to write.\n   * @param {WriteVecCb} cb Callback to call on each element of the vector.\n   * @returns {this}\n   */\n  writeVec(vector, cb) {\n    this.writeULEB(vector.length);\n    Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n    return this;\n  }\n  /**\n   * Adds support for iterations over the object.\n   * @returns {Uint8Array}\n   */\n  *[Symbol.iterator]() {\n    for (let i = 0; i < this.bytePosition; i++) {\n      yield this.dataView.getUint8(i);\n    }\n    return this.toBytes();\n  }\n  /**\n   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n   * @returns {Uint8Array} Resulting bcs.\n   */\n  toBytes() {\n    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n  }\n  /**\n   * Represent data as 'hex' or 'base64'\n   * @param encoding Encoding to use: 'base64' or 'hex'\n   */\n  toString(encoding) {\n    return encodeStr(this.toBytes(), encoding);\n  }\n};\nfunction ulebEncode(num) {\n  let arr = [];\n  let len = 0;\n  if (num === 0) {\n    return [0];\n  }\n  while (num > 0) {\n    arr[len] = num & 127;\n    if (num >>= 7) {\n      arr[len] |= 128;\n    }\n    len += 1;\n  }\n  return arr;\n}\nfunction ulebDecode(arr) {\n  let total = 0;\n  let shift = 0;\n  let len = 0;\n  while (true) {\n    let byte = arr[len];\n    len += 1;\n    total |= (byte & 127) << shift;\n    if ((byte & 128) === 0) {\n      break;\n    }\n    shift += 7;\n  }\n  return {\n    value: total,\n    length: len\n  };\n}\nvar _BCS = class _BCS {\n  /**\n   * Construct a BCS instance with a prepared schema.\n   *\n   * @param schema A prepared schema with type definitions\n   * @param withPrimitives Whether to register primitive types by default\n   */\n  constructor(schema) {\n    /**\n     * Map of kind `TypeName => TypeInterface`. Holds all\n     * callbacks for (de)serialization of every registered type.\n     *\n     * If the value stored is a string, it is treated as an alias.\n     */\n    this.types = /* @__PURE__ */ new Map();\n    /**\n     * Count temp keys to generate a new one when requested.\n     */\n    this.counter = 0;\n    if (schema instanceof _BCS) {\n      this.schema = schema.schema;\n      this.types = new Map(schema.types);\n      return;\n    }\n    this.schema = schema;\n    this.registerAddressType(_BCS.ADDRESS, schema.addressLength, schema.addressEncoding);\n    this.registerVectorType(schema.vectorType);\n    if (schema.types && schema.types.structs) {\n      for (let name of Object.keys(schema.types.structs)) {\n        this.registerStructType(name, schema.types.structs[name]);\n      }\n    }\n    if (schema.types && schema.types.enums) {\n      for (let name of Object.keys(schema.types.enums)) {\n        this.registerEnumType(name, schema.types.enums[name]);\n      }\n    }\n    if (schema.types && schema.types.aliases) {\n      for (let name of Object.keys(schema.types.aliases)) {\n        this.registerAlias(name, schema.types.aliases[name]);\n      }\n    }\n    if (schema.withPrimitives !== false) {\n      registerPrimitives(this);\n    }\n  }\n  /**\n   * Name of the key to use for temporary struct definitions.\n   * Returns a temp key + index (for a case when multiple temp\n   * structs are processed).\n   */\n  tempKey() {\n    return `bcs-struct-${++this.counter}`;\n  }\n  /**\n   * Serialize data into bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<u8>', 'u8');\n   *\n   * let serialized = BCS\n   *   .set('vector<u8>', [1,2,3,4,5,6])\n   *   .toBytes();\n   *\n   * console.assert(toHex(serialized) === '06010203040506');\n   *\n   * @param type Name of the type to serialize (must be registered) or a struct type.\n   * @param data Data to serialize.\n   * @param size Serialization buffer size. Default 1024 = 1KB.\n   * @return A BCS reader instance. Usually you'd want to call `.toBytes()`\n   */\n  ser(type, data, options) {\n    if (typeof type === \"string\" || Array.isArray(type)) {\n      const { name, params } = this.parseTypeName(type);\n      return this.getTypeInterface(name).encode(this, data, options, params);\n    }\n    if (typeof type === \"object\") {\n      const key = this.tempKey();\n      const temp = new _BCS(this);\n      return temp.registerStructType(key, type).ser(key, data, options);\n    }\n    throw new Error(`Incorrect type passed into the '.ser()' function. \n${JSON.stringify(type)}`);\n  }\n  /**\n   * Deserialize BCS into a JS type.\n   *\n   * @example\n   * let num = bcs.ser('u64', '4294967295').toString('hex');\n   * let deNum = bcs.de('u64', num, 'hex');\n   * console.assert(deNum.toString(10) === '4294967295');\n   *\n   * @param type Name of the type to deserialize (must be registered) or a struct type definition.\n   * @param data Data to deserialize.\n   * @param encoding Optional - encoding to use if data is of type String\n   * @return Deserialized data.\n   */\n  de(type, data, encoding) {\n    if (typeof data === \"string\") {\n      if (encoding) {\n        data = decodeStr(data, encoding);\n      } else {\n        throw new Error(\"To pass a string to `bcs.de`, specify encoding\");\n      }\n    }\n    if (typeof type === \"string\" || Array.isArray(type)) {\n      const { name, params } = this.parseTypeName(type);\n      return this.getTypeInterface(name).decode(this, data, params);\n    }\n    if (typeof type === \"object\") {\n      const temp = new _BCS(this);\n      const key = this.tempKey();\n      return temp.registerStructType(key, type).de(key, data, encoding);\n    }\n    throw new Error(`Incorrect type passed into the '.de()' function. \n${JSON.stringify(type)}`);\n  }\n  /**\n   * Check whether a `TypeInterface` has been loaded for a `type`.\n   * @param type Name of the type to check.\n   * @returns\n   */\n  hasType(type) {\n    return this.types.has(type);\n  }\n  /**\n   * Create an alias for a type.\n   * WARNING: this can potentially lead to recursion\n   * @param name Alias to use\n   * @param forType Type to reference\n   * @returns\n   *\n   * @example\n   * ```\n   * let bcs = new BCS(getSuiMoveConfig());\n   * bcs.registerAlias('ObjectDigest', BCS.BASE58);\n   * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');\n   * ```\n   */\n  registerAlias(name, forType) {\n    this.types.set(name, forType);\n    return this;\n  }\n  /**\n   * Method to register new types for BCS internal representation.\n   * For each registered type 2 callbacks must be specified and one is optional:\n   *\n   * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;\n   * - decodeCb(reader) - write a way to deserialize data with BcsReader;\n   * - validateCb(data) - validate data - either return bool or throw an error\n   *\n   * @example\n   * // our type would be a string that consists only of numbers\n   * bcs.registerType('number_string',\n   *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),\n   *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8\n   *    (value) => /[0-9]+/.test(value) // test that it has at least one digit\n   * );\n   * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);\n   *\n   * @param name\n   * @param encodeCb Callback to encode a value.\n   * @param decodeCb Callback to decode a value.\n   * @param validateCb Optional validator Callback to check type before serialization.\n   */\n  registerType(typeName, encodeCb, decodeCb, validateCb = () => true) {\n    const { name, params: generics } = this.parseTypeName(typeName);\n    this.types.set(name, {\n      encode(self, data, options, typeParams) {\n        const typeMap = generics.reduce((acc, value, index) => {\n          return Object.assign(acc, { [value]: typeParams[index] });\n        }, {});\n        return this._encodeRaw.call(self, new BcsWriter(options), data, typeParams, typeMap);\n      },\n      decode(self, data, typeParams) {\n        const typeMap = generics.reduce((acc, value, index) => {\n          return Object.assign(acc, { [value]: typeParams[index] });\n        }, {});\n        return this._decodeRaw.call(self, new BcsReader(data), typeParams, typeMap);\n      },\n      // these methods should always be used with caution as they require pre-defined\n      // reader and writer and mainly exist to allow multi-field (de)serialization;\n      _encodeRaw(writer, data, typeParams, typeMap) {\n        if (validateCb(data)) {\n          return encodeCb.call(this, writer, data, typeParams, typeMap);\n        } else {\n          throw new Error(`Validation failed for type ${name}, data: ${data}`);\n        }\n      },\n      _decodeRaw(reader, typeParams, typeMap) {\n        return decodeCb.call(this, reader, typeParams, typeMap);\n      }\n    });\n    return this;\n  }\n  /**\n   * Register an address type which is a sequence of U8s of specified length.\n   * @example\n   * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);\n   * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');\n   *\n   * @param name Name of the address type.\n   * @param length Byte length of the address.\n   * @param encoding Encoding to use for the address type\n   * @returns\n   */\n  registerAddressType(name, length, encoding = \"hex\") {\n    switch (encoding) {\n      case \"base64\":\n        return this.registerType(\n          name,\n          function encodeAddress(writer, data) {\n            return fromB64(data).reduce((writer2, el) => writer2.write8(el), writer);\n          },\n          function decodeAddress(reader) {\n            return toB64(reader.readBytes(length));\n          }\n        );\n      case \"hex\":\n        return this.registerType(\n          name,\n          function encodeAddress(writer, data) {\n            return fromHEX(data).reduce((writer2, el) => writer2.write8(el), writer);\n          },\n          function decodeAddress(reader) {\n            const hex = toHEX(reader.readBytes(length)).padStart(2 * length, \"0\");\n            const hash = toHEX(sha256(new TextEncoder().encode(hex)));\n            return `BFC${hex}${hash.slice(0, 4)}`;\n          }\n        );\n      default:\n        throw new Error(\"Unsupported encoding! Use either hex or base64\");\n    }\n  }\n  /**\n   * Register custom vector type inside the bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<T>'); // generic registration\n   * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];\n   * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');\n   *\n   * @param name Name of the type to register\n   * @param elementType Optional name of the inner type of the vector\n   * @return Returns self for chaining.\n   */\n  registerVectorType(typeName) {\n    let { name, params } = this.parseTypeName(typeName);\n    if (params.length > 1) {\n      throw new Error(\"Vector can have only one type parameter; got \" + name);\n    }\n    return this.registerType(\n      typeName,\n      function encodeVector(writer, data, typeParams, typeMap) {\n        return writer.writeVec(data, (writer2, el) => {\n          let elementType = typeParams[0];\n          if (!elementType) {\n            throw new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);\n          }\n          let { name: name2, params: params2 } = this.parseTypeName(elementType);\n          if (this.hasType(name2)) {\n            return this.getTypeInterface(name2)._encodeRaw.call(this, writer2, el, params2, typeMap);\n          }\n          if (!(name2 in typeMap)) {\n            throw new Error(\n              `Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`\n            );\n          }\n          let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name2]);\n          return this.getTypeInterface(innerName)._encodeRaw.call(\n            this,\n            writer2,\n            el,\n            innerParams,\n            typeMap\n          );\n        });\n      },\n      function decodeVector(reader, typeParams, typeMap) {\n        return reader.readVec((reader2) => {\n          let elementType = typeParams[0];\n          if (!elementType) {\n            throw new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);\n          }\n          let { name: name2, params: params2 } = this.parseTypeName(elementType);\n          if (this.hasType(name2)) {\n            return this.getTypeInterface(name2)._decodeRaw.call(this, reader2, params2, typeMap);\n          }\n          if (!(name2 in typeMap)) {\n            throw new Error(\n              `Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`\n            );\n          }\n          let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name2]);\n          return this.getTypeInterface(innerName)._decodeRaw.call(\n            this,\n            reader2,\n            innerParams,\n            typeMap\n          );\n        });\n      }\n    );\n  }\n  /**\n   * Safe method to register a custom Move struct. The first argument is a name of the\n   * struct which is only used on the FrontEnd and has no affect on serialization results,\n   * and the second is a struct description passed as an Object.\n   *\n   * The description object MUST have the same order on all of the platforms (ie in Move\n   * or in Rust).\n   *\n   * @example\n   * // Move / Rust struct\n   * // struct Coin {\n   * //   value: u64,\n   * //   owner: vector<u8>, // name // Vec<u8> in Rust\n   * //   is_locked: bool,\n   * // }\n   *\n   * bcs.registerStructType('Coin', {\n   *   value: bcs.U64,\n   *   owner: bcs.STRING,\n   *   is_locked: bcs.BOOL\n   * });\n   *\n   * // Created in Rust with diem/bcs\n   * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';\n   * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array\n   *  128, 209, 177,   5,  96,  0,  0,\n   *    0,  14,  66, 105, 103, 32, 87,\n   *   97, 108, 108, 101, 116, 32, 71,\n   *  117, 121,   0\n   * ];\n   *\n   * // Let's encode the value as well\n   * let test_set = bcs.ser('Coin', {\n   *   owner: 'Big Wallet Guy',\n   *   value: '412412400000',\n   *   is_locked: false,\n   * });\n   *\n   * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');\n   *\n   * @param name Name of the type to register.\n   * @param fields Fields of the struct. Must be in the correct order.\n   * @return Returns BCS for chaining.\n   */\n  registerStructType(typeName, fields) {\n    for (let key in fields) {\n      let internalName = this.tempKey();\n      let value = fields[key];\n      if (!Array.isArray(value) && typeof value !== \"string\") {\n        fields[key] = internalName;\n        this.registerStructType(internalName, value);\n      }\n    }\n    let struct = Object.freeze(fields);\n    let canonicalOrder = Object.keys(struct);\n    let { name: structName, params: generics } = this.parseTypeName(typeName);\n    return this.registerType(\n      typeName,\n      function encodeStruct(writer, data, typeParams, typeMap) {\n        if (!data || data.constructor !== Object) {\n          throw new Error(`Expected ${structName} to be an Object, got: ${data}`);\n        }\n        if (typeParams.length !== generics.length) {\n          throw new Error(\n            `Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`\n          );\n        }\n        for (let key of canonicalOrder) {\n          if (!(key in data)) {\n            throw new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);\n          }\n          const { name: fieldType, params: fieldParams } = this.parseTypeName(\n            struct[key]\n          );\n          if (!generics.includes(fieldType)) {\n            this.getTypeInterface(fieldType)._encodeRaw.call(\n              this,\n              writer,\n              data[key],\n              fieldParams,\n              typeMap\n            );\n          } else {\n            const paramIdx = generics.indexOf(fieldType);\n            let { name, params } = this.parseTypeName(typeParams[paramIdx]);\n            if (this.hasType(name)) {\n              this.getTypeInterface(name)._encodeRaw.call(\n                this,\n                writer,\n                data[key],\n                params,\n                typeMap\n              );\n              continue;\n            }\n            if (!(name in typeMap)) {\n              throw new Error(\n                `Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`\n              );\n            }\n            let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n            this.getTypeInterface(innerName)._encodeRaw.call(\n              this,\n              writer,\n              data[key],\n              innerParams,\n              typeMap\n            );\n          }\n        }\n        return writer;\n      },\n      function decodeStruct(reader, typeParams, typeMap) {\n        if (typeParams.length !== generics.length) {\n          throw new Error(\n            `Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`\n          );\n        }\n        let result = {};\n        for (let key of canonicalOrder) {\n          const { name: fieldName, params: fieldParams } = this.parseTypeName(\n            struct[key]\n          );\n          if (!generics.includes(fieldName)) {\n            result[key] = this.getTypeInterface(fieldName)._decodeRaw.call(\n              this,\n              reader,\n              fieldParams,\n              typeMap\n            );\n          } else {\n            const paramIdx = generics.indexOf(fieldName);\n            let { name, params } = this.parseTypeName(typeParams[paramIdx]);\n            if (this.hasType(name)) {\n              result[key] = this.getTypeInterface(name)._decodeRaw.call(\n                this,\n                reader,\n                params,\n                typeMap\n              );\n              continue;\n            }\n            if (!(name in typeMap)) {\n              throw new Error(\n                `Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`\n              );\n            }\n            let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n            result[key] = this.getTypeInterface(innerName)._decodeRaw.call(\n              this,\n              reader,\n              innerParams,\n              typeMap\n            );\n          }\n        }\n        return result;\n      }\n    );\n  }\n  /**\n   * Safe method to register custom enum type where each invariant holds the value of another type.\n   * @example\n   * bcs.registerStructType('Coin', { value: 'u64' });\n   * bcs.registerEnumType('MyEnum', {\n   *  single: 'Coin',\n   *  multi: 'vector<Coin>',\n   *  empty: null\n   * });\n   *\n   * console.log(\n   *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }\n   *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }\n   * )\n   *\n   * // and serialization\n   * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();\n   * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });\n   *\n   * @param name\n   * @param variants\n   */\n  registerEnumType(typeName, variants) {\n    for (let key in variants) {\n      let internalName = this.tempKey();\n      let value = variants[key];\n      if (value !== null && !Array.isArray(value) && typeof value !== \"string\") {\n        variants[key] = internalName;\n        this.registerStructType(internalName, value);\n      }\n    }\n    let struct = Object.freeze(variants);\n    let canonicalOrder = Object.keys(struct);\n    let { name, params: canonicalTypeParams } = this.parseTypeName(typeName);\n    return this.registerType(\n      typeName,\n      function encodeEnum(writer, data, typeParams, typeMap) {\n        if (!data) {\n          throw new Error(`Unable to write enum \"${name}\", missing data.\nReceived: \"${data}\"`);\n        }\n        if (typeof data !== \"object\") {\n          throw new Error(\n            `Incorrect data passed into enum \"${name}\", expected object with properties: \"${canonicalOrder.join(\n              \" | \"\n            )}\".\nReceived: \"${JSON.stringify(data)}\"`\n          );\n        }\n        let key = Object.keys(data)[0];\n        if (key === void 0) {\n          throw new Error(`Empty object passed as invariant of the enum \"${name}\"`);\n        }\n        let orderByte = canonicalOrder.indexOf(key);\n        if (orderByte === -1) {\n          throw new Error(\n            `Unknown invariant of the enum \"${name}\", allowed values: \"${canonicalOrder.join(\n              \" | \"\n            )}\"; received \"${key}\"`\n          );\n        }\n        let invariant = canonicalOrder[orderByte];\n        let invariantType = struct[invariant];\n        writer.write8(orderByte);\n        if (invariantType === null) {\n          return writer;\n        }\n        let paramIndex = canonicalTypeParams.indexOf(invariantType);\n        let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n        {\n          let { name: name2, params } = this.parseTypeName(typeOrParam);\n          return this.getTypeInterface(name2)._encodeRaw.call(\n            this,\n            writer,\n            data[key],\n            params,\n            typeMap\n          );\n        }\n      },\n      function decodeEnum(reader, typeParams, typeMap) {\n        let orderByte = reader.readULEB();\n        let invariant = canonicalOrder[orderByte];\n        let invariantType = struct[invariant];\n        if (orderByte === -1) {\n          throw new Error(\n            `Decoding type mismatch, expected enum \"${name}\" invariant index, received \"${orderByte}\"`\n          );\n        }\n        if (invariantType === null) {\n          return { [invariant]: true };\n        }\n        let paramIndex = canonicalTypeParams.indexOf(invariantType);\n        let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n        {\n          let { name: name2, params } = this.parseTypeName(typeOrParam);\n          return {\n            [invariant]: this.getTypeInterface(name2)._decodeRaw.call(this, reader, params, typeMap)\n          };\n        }\n      }\n    );\n  }\n  /**\n   * Get a set of encoders/decoders for specific type.\n   * Mainly used to define custom type de/serialization logic.\n   *\n   * @param type\n   * @returns {TypeInterface}\n   */\n  getTypeInterface(type) {\n    let typeInterface = this.types.get(type);\n    if (typeof typeInterface === \"string\") {\n      let chain = [];\n      while (typeof typeInterface === \"string\") {\n        if (chain.includes(typeInterface)) {\n          throw new Error(`Recursive definition found: ${chain.join(\" -> \")} -> ${typeInterface}`);\n        }\n        chain.push(typeInterface);\n        typeInterface = this.types.get(typeInterface);\n      }\n    }\n    if (typeInterface === void 0) {\n      throw new Error(`Type ${type} is not registered`);\n    }\n    return typeInterface;\n  }\n  /**\n   * Parse a type name and get the type's generics.\n   * @example\n   * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');\n   * // typeName: Option\n   * // typeParams: [ 'Coin<SUI>' ]\n   *\n   * @param name Name of the type to process\n   * @returns Object with typeName and typeParams listed as Array\n   */\n  parseTypeName(name) {\n    if (Array.isArray(name)) {\n      let [typeName2, ...params2] = name;\n      return { name: typeName2, params: params2 };\n    }\n    if (typeof name !== \"string\") {\n      throw new Error(`Illegal type passed as a name of the type: ${name}`);\n    }\n    let [left, right] = this.schema.genericSeparators || [\"<\", \">\"];\n    let l_bound = name.indexOf(left);\n    let r_bound = Array.from(name).reverse().indexOf(right);\n    if (l_bound === -1 && r_bound === -1) {\n      return { name, params: [] };\n    }\n    if (l_bound === -1 || r_bound === -1) {\n      throw new Error(`Unclosed generic in name '${name}'`);\n    }\n    let typeName = name.slice(0, l_bound);\n    let params = splitGenericParameters(\n      name.slice(l_bound + 1, name.length - r_bound - 1),\n      this.schema.genericSeparators\n    );\n    return { name: typeName, params };\n  }\n};\n// Prefefined types constants\n_BCS.U8 = \"u8\";\n_BCS.U16 = \"u16\";\n_BCS.U32 = \"u32\";\n_BCS.U64 = \"u64\";\n_BCS.U128 = \"u128\";\n_BCS.U256 = \"u256\";\n_BCS.BOOL = \"bool\";\n_BCS.VECTOR = \"vector\";\n_BCS.ADDRESS = \"address\";\n_BCS.STRING = \"string\";\n_BCS.HEX = \"hex-string\";\n_BCS.BASE58 = \"base58-string\";\n_BCS.BASE64 = \"base64-string\";\nvar BCS = _BCS;\nfunction encodeStr(data, encoding) {\n  switch (encoding) {\n    case \"base58\":\n      return toB58(data);\n    case \"base64\":\n      return toB64(data);\n    case \"hex\":\n      return toHEX(data);\n    default:\n      throw new Error(\"Unsupported encoding, supported values are: base64, hex\");\n  }\n}\nfunction decodeStr(data, encoding) {\n  switch (encoding) {\n    case \"base58\":\n      return fromB58(data);\n    case \"base64\":\n      return fromB64(data);\n    case \"hex\":\n      return fromHEX(data);\n    default:\n      throw new Error(\"Unsupported encoding, supported values are: base64, hex\");\n  }\n}\nfunction registerPrimitives(bcs) {\n  bcs.registerType(\n    BCS.U8,\n    function(writer, data) {\n      return writer.write8(data);\n    },\n    function(reader) {\n      return reader.read8();\n    },\n    (u8) => u8 < 256\n  );\n  bcs.registerType(\n    BCS.U16,\n    function(writer, data) {\n      return writer.write16(data);\n    },\n    function(reader) {\n      return reader.read16();\n    },\n    (u16) => u16 < 65536\n  );\n  bcs.registerType(\n    BCS.U32,\n    function(writer, data) {\n      return writer.write32(data);\n    },\n    function(reader) {\n      return reader.read32();\n    },\n    (u32) => u32 <= 4294967296n\n  );\n  bcs.registerType(\n    BCS.U64,\n    function(writer, data) {\n      return writer.write64(data);\n    },\n    function(reader) {\n      return reader.read64();\n    }\n  );\n  bcs.registerType(\n    BCS.U128,\n    function(writer, data) {\n      return writer.write128(data);\n    },\n    function(reader) {\n      return reader.read128();\n    }\n  );\n  bcs.registerType(\n    BCS.U256,\n    function(writer, data) {\n      return writer.write256(data);\n    },\n    function(reader) {\n      return reader.read256();\n    }\n  );\n  bcs.registerType(\n    BCS.BOOL,\n    function(writer, data) {\n      return writer.write8(data);\n    },\n    function(reader) {\n      return reader.read8().toString(10) === \"1\";\n    }\n  );\n  bcs.registerType(\n    BCS.STRING,\n    function(writer, data) {\n      return writer.writeVec(Array.from(data), (writer2, el) => writer2.write8(el.charCodeAt(0)));\n    },\n    function(reader) {\n      return reader.readVec((reader2) => reader2.read8()).map((el) => String.fromCharCode(Number(el))).join(\"\");\n    },\n    (_str) => true\n  );\n  bcs.registerType(\n    BCS.HEX,\n    function(writer, data) {\n      return writer.writeVec(Array.from(fromHEX(data)), (writer2, el) => writer2.write8(el));\n    },\n    function(reader) {\n      let bytes = reader.readVec((reader2) => reader2.read8());\n      return toHEX(new Uint8Array(bytes));\n    }\n  );\n  bcs.registerType(\n    BCS.BASE58,\n    function(writer, data) {\n      return writer.writeVec(Array.from(fromB58(data)), (writer2, el) => writer2.write8(el));\n    },\n    function(reader) {\n      let bytes = reader.readVec((reader2) => reader2.read8());\n      return toB58(new Uint8Array(bytes));\n    }\n  );\n  bcs.registerType(\n    BCS.BASE64,\n    function(writer, data) {\n      return writer.writeVec(Array.from(fromB64(data)), (writer2, el) => writer2.write8(el));\n    },\n    function(reader) {\n      let bytes = reader.readVec((reader2) => reader2.read8());\n      return toB64(new Uint8Array(bytes));\n    }\n  );\n}\nfunction getRustConfig() {\n  return {\n    genericSeparators: [\"<\", \">\"],\n    vectorType: \"Vec\",\n    addressLength: SUI_ADDRESS_LENGTH,\n    addressEncoding: \"hex\"\n  };\n}\nfunction getSuiMoveConfig() {\n  return {\n    genericSeparators: [\"<\", \">\"],\n    vectorType: \"vector\",\n    addressLength: SUI_ADDRESS_LENGTH,\n    addressEncoding: \"hex\"\n  };\n}\nfunction splitGenericParameters(str, genericSeparators = [\"<\", \">\"]) {\n  const [left, right] = genericSeparators;\n  const tok = [];\n  let word = \"\";\n  let nestedAngleBrackets = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n    if (char === left) {\n      nestedAngleBrackets++;\n    }\n    if (char === right) {\n      nestedAngleBrackets--;\n    }\n    if (nestedAngleBrackets === 0 && char === \",\") {\n      tok.push(word.trim());\n      word = \"\";\n      continue;\n    }\n    word += char;\n  }\n  tok.push(word.trim());\n  return tok;\n}\nexport {\n  BCS,\n  BcsReader,\n  BcsWriter,\n  decodeStr,\n  encodeStr,\n  fromB58,\n  fromB64,\n  fromHEX,\n  getRustConfig,\n  getSuiMoveConfig,\n  registerPrimitives,\n  splitGenericParameters,\n  toB58,\n  toB64,\n  toHEX\n};\n//# sourceMappingURL=index.mjs.map","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n",null,null,null,null,null,null,null],"names":["CODE_TO_ERROR_TYPE","SuiHTTPTransportError","Error","JsonRpcError","constructor","message","code","super","this","type","SuiHTTPStatusError","status","statusText","_requestId","_disconnects","_webSocket","_connectionPromise","_subscriptions","_pendingRequests","_WebsocketClient_instances","setupWebSocket_fn","reconnect_fn","__typeError","msg","TypeError","__accessCheck","obj","member","has","__privateGet","getter","call","get","__privateAdd","value","WeakSet","add","set","__privateSet","setter","__privateMethod","method","DEFAULT_CLIENT_OPTIONS","WebSocketConstructor","WebSocket","callTimeout","reconnectTimeout","maxReconnects","WebsocketClient","endpoint","options","Set","Map","startsWith","httpUrl","url","URL","protocol","replace","toString","getWebsocketUrl","makeRequest","params","webSocket","Promise","resolve","reject","timeout","setTimeout","delete","send","JSON","stringify","jsonrpc","id","then","error","result","subscribe","input","subscription","RpcSubscription","unsubscribe","WeakMap","close","addEventListener","_","data","json","parse","resolve2","clearTimeout","forEach","subscriptionId","onMessage","async","allSettled","map","subscribed","client","newSubscriptionId","_options","_websocketClient","_SuiHTTPTransport_instances","getWebsocketClient_fn","SuiHTTPTransport","fetch","init","fetchFn","request","res","rpc","headers","body","ok","getFullnodeUrl","network","isBytes","a","Uint8Array","ArrayBuffer","isView","name","isArrayOf","isString","arr","Array","isArray","length","every","item","Number","isSafeInteger","afn","astr","label","anumber","n","aArr","astrArr","anumArr","chain","args","wrap","b","c","encode","x","reduceRight","decode","reduce","alphabet","letters","lettersA","split","len","indexes","l","i","digits","letter","undefined","join","separator","from","to","padding","bits","chr","push","end","slice","normalize","fn","convertRadix","pos","d","dlen","carry","done","digit","fromCarry","digitBase","div","rounded","Math","floor","reverse","websocket","gcd","radix2carry","powers","convertRadix2","max","mask","pow","radix2","revPadding","bytes","unsafeWrapper","apply","e","s","toUpperCase","genBase58","abc","num","base58","BECH_ALPHABET","POLYMOD_GENERATORS","bech32Polymod","pre","chk","bechChecksum","prefix","words","encodingConst","charCodeAt","v","genBech32","encoding","ENCODING_CONST","_words","fromWords","toWords","fromWordsUnsafe","limit","plen","actualLength","lowered","toLowerCase","sum","str","slen","sepIndex","lastIndexOf","endsWith","encodeFromBytes","decodeToBytes","decodeUnsafe","toBase58","buffer","fromBase58","fromBase64","base64String","atob","char","CHUNK_SIZE","toBase64","btoa","String","fromCharCode","output","chunk","fromHex","hexStr","normalized","padded","intArr","match","byte","parseInt","toHex","padStart","ulebEncode","BcsReader","bytePosition","dataView","DataView","shift","read8","getUint8","read16","getUint16","read32","getUint32","read64","value1","BigInt","read128","read256","readBytes","start","byteOffset","readULEB","total","ulebDecode","readVec","cb","splitGenericParameters","genericSeparators","left","right","tok","word","nestedAngleBrackets","trim","BcsWriter","initialSize","maxSize","Infinity","allocateSize","size","ensureSizeOrGrow","requiredSize","nextSize","min","nextBuffer","write8","setUint8","write16","setUint16","write32","setUint32","write64","toLittleEndian","el","write128","write256","writeULEB","writeVec","vector","Symbol","iterator","toBytes","encodeStr","bigint","_write","_serialize","_schema","_bytes","BcsType","_BcsType","read","serializedSize","write","serialize","options2","writer","validate","SerializedBcs","reader","hex","b64","transform","SERIALIZED_BCS_BRAND","for","isSerializedBcs","schema","fixedSizeBcsType","uIntBcsType","readMethod","writeMethod","maxValue","bigUIntBcsType","val","bcs","u8","u16","u32","u64","u128","u256","bool","uleb128","dynamicSizeBcsType","array","byteVector","string","fromBytes","stringLikeBcsType","TextEncoder","TextDecoder","fixedArray","option","enum","None","Some","$kind","tuple","types","t","values","struct","fields","canonicalOrder","Object","entries","field","index","enumEntry","kind","name2","filter","name3","hasOwn","optionName","optionType","keys","k","variant","keyType","valueType","key","lazy","lazyType","getType","lazyBcsType","Experimental_SuiClient","$extend","registrations","create","fromEntries","registration","register","experimental_asClientExtension","SUI_NS_NAME_REGEX","SUI_NS_DOMAIN_REGEX","NAME_PATTERN","VERSION_REGEX","isValidNamedPackage","parts","org","app","version","test","includes","isValidSuiNSName","isValidTransactionDigest","isValidSuiAddress","isHex","getHexByteLength","isValidSuiObjectId","parseStructTag","address","module","isMvrPackage","rest","indexOf","typeParams","typeParam","parseTypeTag","normalizeSuiAddress","normalizeStructTag","forceAdd0x","SUI_ADDRESS_LENGTH","normalizeSuiObjectId","VECTOR_REGEX","STRUCT_REGEX","TypeTagSerializer","parseFromStr","normalizeAddress","signer","vectorMatch","structMatch","parseStructTypeArgs","tagToString","tag","Address","ObjectDigest","SuiObjectRef","objectId","digest","SharedObjectRef","initialSharedVersion","mutable","ObjectArg","ImmOrOwnedObject","SharedObject","Receiving","CallArg","Pure","InnerTypeTag","StructTag","TypeTag","typeTag","Argument","GasCoin","Input","Result","NestedResult","ProgrammableMoveCall","package","function","typeArguments","arguments","Command","MoveCall","TransferObjects","objects","SplitCoins","coin","amounts","MergeCoins","destination","sources","Publish","modules","dependencies","MakeMoveVec","elements","Upgrade","ticket","ProgrammableTransaction","inputs","commands","TransactionKind","ChangeEpoch","Genesis","ConsensusCommitPrologue","TransactionExpiration","Epoch","GasData","payment","owner","price","budget","TransactionDataV1","sender","gasData","expiration","TransactionData","V1","IntentScope","TransactionEffects","CheckpointSummary","PersonalMessage","IntentVersion","V0","AppId","Sui","Intent","scope","appId","IntentMessage","T","intent","CompressedSignature","ED25519","Secp256k1","Secp256r1","ZkLogin","PublicKey","MultiSigPkMap","pubKey","weight","MultiSigPublicKey","pk_map","threshold","MultiSig","sigs","bitmap","multisig_pk","SenderSignedTransaction","intentMessage","txSignatures","SenderSignedData","PasskeyAuthenticator","authenticatorData","clientDataJson","userSignature","PackageUpgradeError","UnableToFetchPackage","packageId","NotAPackage","IncompatibleUpgrade","DigestDoesNotMatch","UnknownUpgradePolicy","policy","PackageIDDoesNotMatch","ticketId","ModuleId","MoveLocation","instruction","functionName","CommandArgumentError","TypeMismatch","InvalidBCSBytes","InvalidUsageOfPureArg","InvalidArgumentToPrivateEntryFunction","IndexOutOfBounds","idx","SecondaryIndexOutOfBounds","resultIdx","secondaryIdx","InvalidResultArity","InvalidGasCoinUsage","InvalidValueUsage","InvalidObjectByValue","InvalidObjectByMutRef","SharedObjectOperationNotAllowed","TypeArgumentError","TypeNotFound","ConstraintNotSatisfied","ExecutionFailureStatus","InsufficientGas","InvalidGasObject","InvariantViolation","FeatureNotYetSupported","MoveObjectTooBig","objectSize","maxObjectSize","MovePackageTooBig","CircularObjectOwnership","object","InsufficientCoinBalance","CoinBalanceOverflow","PublishErrorNonZeroAddress","SuiMoveVerificationError","MovePrimitiveRuntimeError","MoveAbort","VMVerificationOrDeserializationError","VMInvariantViolation","FunctionNotFound","ArityMismatch","TypeArityMismatch","NonEntryFunctionInvoked","argIdx","argumentIdx","UnusedValueWithoutDrop","InvalidPublicFunctionReturnType","InvalidTransferObject","EffectsTooLarge","currentSize","PublishUpgradeMissingDependency","PublishUpgradeDependencyDowngrade","upgradeError","WrittenObjectsTooLarge","CertificateDenied","SuiMoveVerificationTimedout","InputObjectDeleted","ExecutionCancelledDueToSharedObjectCongestion","congestedObjects","AddressDeniedForCoin","coinType","CoinTypeGlobalPause","ExecutionCancelledDueToRandomnessUnavailable","ExecutionStatus","Success","Failed","command","GasCostSummary","computationCost","storageCost","storageRebate","nonRefundableStorageFee","Owner","AddressOwner","ObjectOwner","Shared","Immutable","TransactionEffectsV1","executedEpoch","gasUsed","modifiedAtVersions","sharedObjects","transactionDigest","created","mutated","unwrapped","deleted","unwrappedThenDeleted","wrapped","gasObject","eventsDigest","VersionDigest","ObjectIn","NotExist","Exist","ObjectOut","ObjectWrite","PackageWrite","IDOperation","Created","Deleted","EffectsObjectChange","inputState","outputState","idOperation","UnchangedSharedKind","ReadOnlyRoot","MutateDeleted","ReadDeleted","Cancelled","PerEpochConfig","TransactionEffectsV2","gasObjectIndex","lamportVersion","changedObjects","unchangedSharedObjects","auxDataDigest","V2","pureBcsSchemaFromTypeName","generic","inner","suiBcs","U8","U16","U32","U64","U128","U256","ULEB128","Bool","_stringify","getPrototypeOf","_addIssue","context","dataset","config2","other","expected","expects","received","issue","requirement","path","issues","lang","abortEarly","abortPipeEarly","isSchema","reference","typed","_isValidObjectKey","object2","ValiError","check","_run","integer","isInteger","operation","getDefault","default","is","value2","itemDataset","pathItem","origin","unshift","boolean","literal","literal_","nullable","nullish","number","isNaN","valueDataset","optional","record","entryKey","entryValue","keyDataset","items","_subIssues","datasets","union","validDataset","typedDatasets","untypedDatasets","optionDataset","unknown","store","getGlobalConfig","pipe","pipe2","safeEnum","SuiAddress","ObjectID","BCSBytes","JsonU64","ObjectRef","OpenMoveTypeSignatureBody","datatype","typeParameters","typeParameter","OpenMoveTypeSignature","ref","_argumentTypes","$Intent","UnresolvedPure","UnresolvedObject","NormalizedCallArg","Commands","pkg","mod","target","o","dep","ImmOrOwned","TransactionInput","StringEncodedBigint","GasConfig","TransactionArgument","resultIndex","MoveCallTransaction","TransferObjectsTransaction","SplitCoinsTransaction","MergeCoinsTransaction","MakeMoveVecTransaction","TransactionType","serializeV1TransactionData","transactionData","gasConfig","transactions","arg","convertTransactionArgument","parseV1TransactionArgument","enumUnion","SerializedTransactionDataV2","Inputs","ReceivingRef","SUI_TYPE_ARG","abytes","lengths","aexists","instance","checkFinished","destroyed","finished","Uint32Array","byteLength","isLE","byteSwap","byteSwapIfBE","byteSwap32","utf8ToBytes","Hash","clone","_cloneInto","wrapConstructorWithOpts","hashCons","hashC","opts","update","tmp","outputLen","blockLen","SIGMA","BLAKE","keyLen","saltLen","persLen","salt","personalization","buffer32","offset","buf","compress","take","dataOffset","data32","pos32","subarray","digestInto","out","aoutput","fill","out32","destroy","dkLen","U32_MASK64","_32n","fromBig","le","h","u64$1","lst","Ah","Al","toBig","shrSH","_l","shrSL","rotrSH","rotrSL","rotrBH","rotrBL","rotr32H","_h","rotr32L","rotlSH","rotlSL","rotlBH","rotlBL","Bh","Bl","add3L","Cl","add3H","low","Ch","add4L","Dl","add4H","Dh","add5H","Eh","add5L","El","B2B_IV","BBUF","G1b","Xl","Xh","ll","G2b","BLAKE2b","v0l","v0h","v1l","v1h","v2l","v2h","v3l","v3h","v4l","v4h","v5l","v5h","v6l","v6h","v7l","v7h","keyLength","pers","isLast","j","blake2b","getPureBcsSchema","typeSignature","normalizedTypeToMoveTypeSignatureBody","Vector","Struct","TypeParameter","MAX_GAS","resolveTransactionData","next","moveCallsToResolve","moveFunctionsToResolve","some","amount","normalizeRawArgument","moveFunctionParameters","getClient","all","moduleId","functionId","def","getNormalizedMoveFunction","parameters","param","Reference","MutableReference","normalizedTypeToMoveTypeSignature","moveCall","isTxContext","at","fnName","inputValue","unresolvedObject","normalizeInputs","objectsToResolve","dedupedIds","objectChunks","ceil","resolved","chunk2","multiGetObjects","ids","showOwner","flat","responsesById","invalidObjects","initial_shared_version","objectsById","updated","isUsedAsMutable","isUsedAsReceiving","resolveObjectReferences","onlyTransactionKind","getReferenceGasPrice","setGasPrice","dryRunResult","dryRunTransactionBlock","transactionBlock","build","overrides","effects","cause","safeOverhead","baseComputationCostWithOverhead","gasBudget","setGasBudget","paymentCoins","getCoins","find","coinObjectId","setGasPayment","usedAsMutable","getInputUses","tx","argIndex","usedAsReceiving","isReceivingType","createPure","makePure","pure","typeOrSerializedValue","prepareSuiAddress","TransactionDataBuilder","fromKindBytes","programmableTx","restore","rawData","transaction","transactionDataFromV1","getDigestFromBytes","hash","typeTagBytes","dataWithTag","hashTypedData","maxSizeBytes","addInput","mapArguments","replaceCommand","replacement","sizeDiff","splice","getDigest","snapshot","getIdFromCallArg","_serializationPlugins","_buildPlugins","_intentResolvers","_data","_Transaction_instances","normalizeTransactionArgument_fn","resolveArgument_fn","prepareBuild_fn","runPlugins_fn","createTransactionResult","nestedResults","nestedResultFor","Proxy","property","Reflect","TRANSACTION_BRAND","isTransaction","modulePluginRegistry","buildPlugins","serializationPlugins","TRANSACTION_REGISTRY_KEY","getGlobalPluginRegistry","globalThis","plugins","createNext","plugin","calledNext","nextResolved","Transaction","_Transaction","makeObject","system","clock","random","denyList","createObjectMethods","inserted","globalPlugins","fromKind","serialized","newTransaction","getData","registerGlobalSerializationPlugin","stepOrStep","step","unregisterGlobalSerializationPlugin","registerGlobalBuildPlugin","unregisterGlobalBuildPlugin","addSerializationPlugin","addBuildPlugin","addIntentResolver","resolver","setSender","setSenderIfNotSet","setExpiration","setGasBudgetIfNotSet","setGasOwner","payments","blockData","defineProperty","enumerable","gas","objectRef","receivingRef","sharedObjectRef","splitCoins","mergeCoins","src","publish","upgrade","transferObjects","makeMoveVec","toJSON","prepareForSerialization","_key","sign","buildOptions","signTransaction","intents","steps","supportedIntents","Experimental_CoreClient","core","SuiClientError","ObjectError","fromResponse","response","object_id","parent_object_id","_jsonRpcClient","JSONRpcTransport","jsonRpcClient","getObjects","batches","batch","objectIds","results","batch2","showType","parseObject","getOwnedObjects","cursor","hasNextPage","nextCursor","coins","balance","content","Coin","getBalance","totalBalance","getAllBalances","balances","getTransaction","parseTransaction","getTransactionBlock","showRawInput","showObjectChanges","showRawEffects","showEvents","executeTransaction","executeTransactionBlock","signature","signatures","showEffects","dryRunTransaction","referenceGasPrice","dataType","bcsBytes","parseOwner","ConsensusV2Owner","authenticator","SingleOwner","ConsensusV2","startVersion","start_version","parsedTx","rawTransaction","rawEffects","Balance","COIN_WITH_BALANCE","SUI_TYPE","coinWithBalance","useGasCoin","resolveCoinBalance","CoinWithBalanceData","coinTypes","totalByType","usedIds","coinsByType","remainingBalance","loadMoreCoins","sortedCoins","sort","coinBalance","getCoinsOfType","mergedCoins","first","SUI_CLIENT_BRAND","SuiClient","transport","getRpcApiVersion","info","getAllCoins","getCoinMetadata","getTotalSupply","getMoveFunctionArgTypes","getNormalizedMoveModulesByPackage","getNormalizedMoveModule","getNormalizedMoveStruct","getObject","tryGetPastObject","queryTransactionBlocks","order","multiGetTransactionBlocks","digests","requestType","waitForTransaction","signAndExecuteTransaction","transactionBytes","toSuiAddress","getTotalTransactionBlocks","resp","getStakes","getStakesByIds","stakedSuiIds","getLatestSuiSystemState","queryEvents","query","subscribeEvent","subscribeTransaction","devInspectTransactionBlock","devInspectTxBytes","gasPrice","epoch","getDynamicFields","parentId","getDynamicFieldObject","getLatestCheckpointSequenceNumber","getCheckpoint","getCheckpoints","descendingOrder","getCommitteeInfo","getNetworkMetrics","getAddressMetrics","getEpochMetrics","getAllEpochAddressMetrics","getEpochs","getMoveCallMetrics","getCurrentEpoch","getValidatorsApy","getChainIdentifier","checkpoint","resolveNameServiceAddress","resolveNameServiceNames","format","lowerCase","labels","domain","normalizeSuiNSName","getProtocolConfig","signal","pollInterval","timeoutSignal","AbortSignal","timeoutPromise","reason","catch","aborted","throwIfAborted","race","isNumeric","mathceil","mathfloor","bignumberError","tooManyDigits","BASE","LOG_BASE","MAX_SAFE_INTEGER","POWS_TEN","SQRT_BASE","MAX","bitFloor","coeffToString","z","r","compare","y","xc","yc","intCheck","isOdd","toExponential","charAt","toFixedPoint","zs","BigNumber","configObject","convertBase","parseNumeric","pow2_53","random53bitInt","basePrefix","dotAfter","dotBefore","isInfinityOrNaN","whitespaceOrPlus","P","prototype","valueOf","ONE","DECIMAL_PLACES","ROUNDING_MODE","TO_EXP_NEG","TO_EXP_POS","MIN_EXP","MAX_EXP","CRYPTO","MODULO_MODE","POW_PRECISION","FORMAT","groupSize","secondaryGroupSize","groupSeparator","decimalSeparator","fractionGroupSize","fractionGroupSeparator","suffix","ALPHABET","alphabetHasNormalDecimalDigits","caseChanged","isNum","_isBigNumber","search","substring","round","DEBUG","rm","c0","ne","maxOrMin","normalise","pop","sd","ni","rd","pows10","ROUND_UP","ROUND_DOWN","ROUND_CEIL","ROUND_FLOOR","ROUND_HALF_UP","ROUND_HALF_DOWN","ROUND_HALF_EVEN","ROUND_HALF_CEIL","ROUND_HALF_FLOOR","EUCLID","config","p","hasOwnProperty","crypto","getRandomValues","randomBytes","EXPONENTIAL_AT","RANGE","isBigNumber","maximum","minimum","dp","rand","copy","plus","decimal","toBaseOut","baseIn","baseOut","arrL","callerIsToString","concat","multiply","base","m","temp","xlo","xhi","klo","khi","aL","bL","cmp","subtract","more","prod","prodL","q","qc","rem","remL","rem0","xi","xL","yc0","yL","yz","NaN","p1","p2","absoluteValue","abs","comparedTo","decimalPlaces","dividedBy","dividedToIntegerBy","idiv","exponentiatedBy","half","isModExp","nIsBig","nIsNeg","nIsOdd","times","integerValue","isEqualTo","eq","isFinite","isGreaterThan","gt","isGreaterThanOrEqualTo","gte","isLessThan","lt","isLessThanOrEqualTo","lte","isNegative","isPositive","isZero","minus","xLTy","xe","ye","modulo","multipliedBy","xcL","ycL","ylo","yhi","zc","sqrtBase","negated","precision","shiftedBy","squareRoot","sqrt","rep","toFixed","toFormat","g1","g2","intPart","fractionPart","isNeg","intDigits","substr","RegExp","toFraction","md","d0","d1","d2","exp","n0","n1","toNumber","toPrecision","toStringTag","basex","BASE_MAP","LEADER","FACTOR","log","iFACTOR","source","psz","zeroes","b256","charCode","it3","it4","vch","pbegin","pend","b58","it1","it2","repeat","bs58","exports","__esModule","digestLength","blockSize","K","hashBlocks","w","f","g","u","t1","t2","state","Int32Array","bufferLength","bytesHashed","reset","clean","dataLength","dataPos","finish","bitLenHi","bitLenLo","padLength","_saveState","_restoreState","HMAC","outer","pad","istate","ostate","hmac","fillBuffer","counter","hkdfSalt","hkdf","okm","hmac_","bufpos","pbkdf2","password","iterations","prf","ctr","dk","factory","sha256","b64ToUint6","nChr","fromB64","sBase64","nBlocksSize","nMod3","nMod4","sB64Enc","nInLen","nOutLen","taBytes","nUint24","nOutIdx","nInIdx","uint6ToB64","nUint6","toB64","aBytes","nLen","nIdx","fromCodePoint","fromHEX","toHEX","toB58","fromB58","_BCS","registerAddressType","ADDRESS","addressLength","addressEncoding","registerVectorType","vectorType","structs","registerStructType","enums","registerEnumType","aliases","registerAlias","withPrimitives","registerType","BCS","BOOL","STRING","writer2","reader2","_str","HEX","BASE58","BASE64","registerPrimitives","tempKey","ser","parseTypeName","getTypeInterface","de","decodeStr","hasType","forType","typeName","encodeCb","decodeCb","validateCb","generics","self","typeMap","acc","assign","_encodeRaw","_decodeRaw","elementType","params2","innerName","innerParams","internalName","freeze","structName","fieldType","fieldParams","paramIdx","fieldName","variants","canonicalTypeParams","orderByte","invariant","invariantType","paramIndex","typeOrParam","typeInterface","typeName2","l_bound","r_bound","VECTOR","ieee754","mLen","nBytes","eLen","eMax","eBias","nBits","rt","LN2","base64","base64Js","lens","getLens","validLen","placeHoldersLen","toByteArray","Arr","_byteLength","curByte","revLookup","fromByteArray","uint8","extraBytes","maxChunkLength","len2","encodeChunk","lookup","tripletToBase64","require$$0","require$$1","customInspectSymbol","Buffer","SlowBuffer","alloc","INSPECT_MAX_BYTES","K_MAX_LENGTH","createBuffer","RangeError","setPrototypeOf","encodingOrOffset","allocUnsafe","isEncoding","actual","fromString","arrayView","isInstance","fromArrayBuffer","fromArrayLike","fromArrayView","SharedArrayBuffer","isBuffer","checked","numberIsNaN","fromObject","toPrimitive","assertSize","mustMatch","loweredCase","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","bidirectionalIndexOf","dir","arrayIndexOf","indexSize","arrLength","valLength","readUInt16BE","foundIndex","found","hexWrite","remaining","strLen","parsed","utf8Write","blitBuffer","asciiWrite","byteArray","asciiToBytes","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","codePoints","MAX_ARGUMENTS_LENGTH","decodeCodePointsArray","kMaxLength","TYPED_ARRAY_SUPPORT","proto","foo","typedArraySupport","console","poolSize","allocUnsafeSlow","_isBuffer","list","swap16","swap32","swap64","toLocaleString","equals","inspect","thisStart","thisEnd","thisCopy","targetCopy","_arr","ret","hexSliceLookupTable","checkOffset","ext","checkInt","wrtBigUInt64LE","checkIntBI","wrtBigUInt64BE","checkIEEE754","writeFloat","littleEndian","noAssert","writeDouble","newBuf","readUintLE","readUIntLE","mul","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readBigUInt64LE","defineBigIntMethod","validateNumber","last","boundsError","readBigUInt64BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readBigInt64LE","readBigInt64BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","errors","E","sym","getMessage","Base","writable","configurable","stack","addNumericalSeparator","range","ERR_OUT_OF_RANGE","checkBounds","ERR_INVALID_ARG_TYPE","ERR_BUFFER_OUT_OF_BOUNDS","INVALID_BASE64_RE","leadSurrogate","base64clean","dst","table","i16","BufferBigIntNotDefined","formatError","serializeTypeName","isSortedTypes","typeX","typeY","bytesX","bytesY","lenX","lenY","minLen","compareByteArrays","orderType","SwapMath","static","mulToU128","square","mulDiv","U64_MAX","calcOptimalCoinValues","coinXDesired","coinYDesired","coinXReserve","coinYReserve","coinYReturned","coinXReturned","getFeeToTeam","feeRate","coinIn","FEE_SCALE","getExpectedLiquidityAmount","optimalCoinX","optimalCoinY","lpSupply","liquidityAmount","xLiq","yLiq","getAmountOut","amountIn","reserveIn","reserveOut","MAX_FEE_RATE","feeMultiplier","coinInValAfterFees","newReserveIn","amountOut","getAmountIn","numerator","denominator","assertLpValueIsIncreased","oldReserveX","oldReserveY","newReserveX","newReserveY","DEFAULT_SLIPPAGE","COIN_TYPE_SUI","DipCoinSDK","suiRpc","optionsField","buildAddLiquidityTx","suiWalletAddress","amountX","amountY","slippage","newTypeX","newTypeY","isChange","tempAmount","poolResponse","getPool","pooId","pool","bal_x","bal_y","expectedLp","lp_supply","minAddLiquidityLpAmount","min_add_liquidity_lp_amount","coinXMin","coinYMin","splitCoinX","splitCoinY","splitCoin","globalId","addLiquidity","getPublicKey","txId","buildRemoveLiquidityTx","removeLpAmount","lpType","getLpType","minRemoveLpAmount","mergedCoin","getMergedCoin","coinXOut","coinYOut","removeLiquidity","buildSwapExactXToYTx","sortedTypeX","sortedTypeY","isSwap","balanceX","balanceY","amountOutMin","fee_rate","splitCoinIn","swapExactXToY","buildSwapXToExactYTx","amountInMax","swapXToExactY","poolId","poolObjectId","showContent","showBcs","fee_bal_x","fee_bal_y","min_liquidity","getGlobal","global","globalObjectId","has_paused","is_open_protocol_fee","getPoolId","lpName","getLpName","registedPoolsId","keyValue","ownerAddress","selectedCoins","totalAmount","newCoin","buildTransferTx","transfer","dipCoinMainnet","initMainnetSDK","customRpc","dipCoinTestnet","initTestnetSDK","initDipCoinSDK"],"mappings":"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"}